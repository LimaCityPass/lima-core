// Code generated by Prisma CLI (https://github.com/prisma/prisma). DO NOT EDIT.

package prisma

import (
	"context"
	"errors"

	"github.com/prisma/prisma-client-lib-go"

	"github.com/machinebox/graphql"
)

var ErrNoResult = errors.New("query returned no result")

func Str(v string) *string { return &v }
func Int32(v int32) *int32 { return &v }
func Bool(v bool) *bool    { return &v }

type BatchPayloadExec struct {
	exec *prisma.BatchPayloadExec
}

func (exec *BatchPayloadExec) Exec(ctx context.Context) (BatchPayload, error) {
	bp, err := exec.exec.Exec(ctx)
	return BatchPayload(bp), err
}

type BatchPayload struct {
	Count int64 `json:"count"`
}

type Aggregate struct {
	Count int64 `json:"count"`
}

type Client struct {
	Client *prisma.Client
}

type Options struct {
	Endpoint string
	Secret   string
}

func New(options *Options, opts ...graphql.ClientOption) *Client {
	endpoint := DefaultEndpoint
	secret := Secret
	if options != nil {
		endpoint = options.Endpoint
		secret = options.Secret
	}
	return &Client{
		Client: prisma.New(endpoint, secret, opts...),
	}
}

func (client *Client) GraphQL(ctx context.Context, query string, variables map[string]interface{}) (map[string]interface{}, error) {
	return client.Client.GraphQL(ctx, query, variables)
}

var DefaultEndpoint = "http://db.limacitypass.com:4466/limadb/dev"
var Secret = ""

func (client *Client) Attraction(params AttractionWhereUniqueInput) *AttractionExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"AttractionWhereUniqueInput!", "Attraction"},
		"attraction",
		[]string{"id", "createdAt", "updatedAt", "maxUses", "address", "popularity", "types", "tags"})

	return &AttractionExec{ret}
}

type AttractionsParams struct {
	Where   *AttractionWhereInput   `json:"where,omitempty"`
	OrderBy *AttractionOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                  `json:"skip,omitempty"`
	After   *string                 `json:"after,omitempty"`
	Before  *string                 `json:"before,omitempty"`
	First   *int32                  `json:"first,omitempty"`
	Last    *int32                  `json:"last,omitempty"`
}

func (client *Client) Attractions(params *AttractionsParams) *AttractionExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"AttractionWhereInput", "AttractionOrderByInput", "Attraction"},
		"attractions",
		[]string{"id", "createdAt", "updatedAt", "maxUses", "address", "popularity", "types", "tags"})

	return &AttractionExecArray{ret}
}

type AttractionsConnectionParams struct {
	Where   *AttractionWhereInput   `json:"where,omitempty"`
	OrderBy *AttractionOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                  `json:"skip,omitempty"`
	After   *string                 `json:"after,omitempty"`
	Before  *string                 `json:"before,omitempty"`
	First   *int32                  `json:"first,omitempty"`
	Last    *int32                  `json:"last,omitempty"`
}

func (client *Client) AttractionsConnection(params *AttractionsConnectionParams) AttractionConnectionExec {
	panic("not implemented")
}

func (client *Client) Credential(params CredentialWhereUniqueInput) *CredentialExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"CredentialWhereUniqueInput!", "Credential"},
		"credential",
		[]string{"id", "createdAt", "updatedAt", "displayName", "isMain", "type", "validated", "validationID", "value", "rawPassword", "hashedPassword"})

	return &CredentialExec{ret}
}

type CredentialsParams struct {
	Where   *CredentialWhereInput   `json:"where,omitempty"`
	OrderBy *CredentialOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                  `json:"skip,omitempty"`
	After   *string                 `json:"after,omitempty"`
	Before  *string                 `json:"before,omitempty"`
	First   *int32                  `json:"first,omitempty"`
	Last    *int32                  `json:"last,omitempty"`
}

func (client *Client) Credentials(params *CredentialsParams) *CredentialExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"CredentialWhereInput", "CredentialOrderByInput", "Credential"},
		"credentials",
		[]string{"id", "createdAt", "updatedAt", "displayName", "isMain", "type", "validated", "validationID", "value", "rawPassword", "hashedPassword"})

	return &CredentialExecArray{ret}
}

type CredentialsConnectionParams struct {
	Where   *CredentialWhereInput   `json:"where,omitempty"`
	OrderBy *CredentialOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                  `json:"skip,omitempty"`
	After   *string                 `json:"after,omitempty"`
	Before  *string                 `json:"before,omitempty"`
	First   *int32                  `json:"first,omitempty"`
	Last    *int32                  `json:"last,omitempty"`
}

func (client *Client) CredentialsConnection(params *CredentialsConnectionParams) CredentialConnectionExec {
	panic("not implemented")
}

func (client *Client) CreditCard(params CreditCardWhereUniqueInput) *CreditCardExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"CreditCardWhereUniqueInput!", "CreditCard"},
		"creditCard",
		[]string{"id", "createdAt", "updatedAt", "cardNumber", "cardToken", "type", "lastUsed"})

	return &CreditCardExec{ret}
}

type CreditCardsParams struct {
	Where   *CreditCardWhereInput   `json:"where,omitempty"`
	OrderBy *CreditCardOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                  `json:"skip,omitempty"`
	After   *string                 `json:"after,omitempty"`
	Before  *string                 `json:"before,omitempty"`
	First   *int32                  `json:"first,omitempty"`
	Last    *int32                  `json:"last,omitempty"`
}

func (client *Client) CreditCards(params *CreditCardsParams) *CreditCardExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"CreditCardWhereInput", "CreditCardOrderByInput", "CreditCard"},
		"creditCards",
		[]string{"id", "createdAt", "updatedAt", "cardNumber", "cardToken", "type", "lastUsed"})

	return &CreditCardExecArray{ret}
}

type CreditCardsConnectionParams struct {
	Where   *CreditCardWhereInput   `json:"where,omitempty"`
	OrderBy *CreditCardOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                  `json:"skip,omitempty"`
	After   *string                 `json:"after,omitempty"`
	Before  *string                 `json:"before,omitempty"`
	First   *int32                  `json:"first,omitempty"`
	Last    *int32                  `json:"last,omitempty"`
}

func (client *Client) CreditCardsConnection(params *CreditCardsConnectionParams) CreditCardConnectionExec {
	panic("not implemented")
}

type DetailsesParams struct {
	Where   *DetailsWhereInput   `json:"where,omitempty"`
	OrderBy *DetailsOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32               `json:"skip,omitempty"`
	After   *string              `json:"after,omitempty"`
	Before  *string              `json:"before,omitempty"`
	First   *int32               `json:"first,omitempty"`
	Last    *int32               `json:"last,omitempty"`
}

func (client *Client) Detailses(params *DetailsesParams) *DetailsExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"DetailsWhereInput", "DetailsOrderByInput", "Details"},
		"detailses",
		[]string{"providerName", "providerWeb", "contactPhone", "contactEmail", "addressReference"})

	return &DetailsExecArray{ret}
}

type DetailsesConnectionParams struct {
	Where   *DetailsWhereInput   `json:"where,omitempty"`
	OrderBy *DetailsOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32               `json:"skip,omitempty"`
	After   *string              `json:"after,omitempty"`
	Before  *string              `json:"before,omitempty"`
	First   *int32               `json:"first,omitempty"`
	Last    *int32               `json:"last,omitempty"`
}

func (client *Client) DetailsesConnection(params *DetailsesConnectionParams) DetailsConnectionExec {
	panic("not implemented")
}

func (client *Client) EmailChannel(params EmailChannelWhereUniqueInput) *EmailChannelExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"EmailChannelWhereUniqueInput!", "EmailChannel"},
		"emailChannel",
		[]string{"id", "createdAt", "updatedAt", "displayName", "valid", "value", "extras"})

	return &EmailChannelExec{ret}
}

type EmailChannelsParams struct {
	Where   *EmailChannelWhereInput   `json:"where,omitempty"`
	OrderBy *EmailChannelOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                    `json:"skip,omitempty"`
	After   *string                   `json:"after,omitempty"`
	Before  *string                   `json:"before,omitempty"`
	First   *int32                    `json:"first,omitempty"`
	Last    *int32                    `json:"last,omitempty"`
}

func (client *Client) EmailChannels(params *EmailChannelsParams) *EmailChannelExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"EmailChannelWhereInput", "EmailChannelOrderByInput", "EmailChannel"},
		"emailChannels",
		[]string{"id", "createdAt", "updatedAt", "displayName", "valid", "value", "extras"})

	return &EmailChannelExecArray{ret}
}

type EmailChannelsConnectionParams struct {
	Where   *EmailChannelWhereInput   `json:"where,omitempty"`
	OrderBy *EmailChannelOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                    `json:"skip,omitempty"`
	After   *string                   `json:"after,omitempty"`
	Before  *string                   `json:"before,omitempty"`
	First   *int32                    `json:"first,omitempty"`
	Last    *int32                    `json:"last,omitempty"`
}

func (client *Client) EmailChannelsConnection(params *EmailChannelsConnectionParams) EmailChannelConnectionExec {
	panic("not implemented")
}

type FeaturesParams struct {
	Where   *FeatureWhereInput   `json:"where,omitempty"`
	OrderBy *FeatureOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32               `json:"skip,omitempty"`
	After   *string              `json:"after,omitempty"`
	Before  *string              `json:"before,omitempty"`
	First   *int32               `json:"first,omitempty"`
	Last    *int32               `json:"last,omitempty"`
}

func (client *Client) Features(params *FeaturesParams) *FeatureExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"FeatureWhereInput", "FeatureOrderByInput", "Feature"},
		"features",
		[]string{"name", "image"})

	return &FeatureExecArray{ret}
}

type FeaturesConnectionParams struct {
	Where   *FeatureWhereInput   `json:"where,omitempty"`
	OrderBy *FeatureOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32               `json:"skip,omitempty"`
	After   *string              `json:"after,omitempty"`
	Before  *string              `json:"before,omitempty"`
	First   *int32               `json:"first,omitempty"`
	Last    *int32               `json:"last,omitempty"`
}

func (client *Client) FeaturesConnection(params *FeaturesConnectionParams) FeatureConnectionExec {
	panic("not implemented")
}

func (client *Client) IDentificationDocument(params IDentificationDocumentWhereUniqueInput) *IDentificationDocumentExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"IdentificationDocumentWhereUniqueInput!", "IdentificationDocument"},
		"identificationDocument",
		[]string{"id", "createdAt", "updatedAt", "type", "value", "validated"})

	return &IDentificationDocumentExec{ret}
}

type IDentificationDocumentsParams struct {
	Where   *IDentificationDocumentWhereInput   `json:"where,omitempty"`
	OrderBy *IDentificationDocumentOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                              `json:"skip,omitempty"`
	After   *string                             `json:"after,omitempty"`
	Before  *string                             `json:"before,omitempty"`
	First   *int32                              `json:"first,omitempty"`
	Last    *int32                              `json:"last,omitempty"`
}

func (client *Client) IDentificationDocuments(params *IDentificationDocumentsParams) *IDentificationDocumentExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"IdentificationDocumentWhereInput", "IdentificationDocumentOrderByInput", "IdentificationDocument"},
		"identificationDocuments",
		[]string{"id", "createdAt", "updatedAt", "type", "value", "validated"})

	return &IDentificationDocumentExecArray{ret}
}

type IDentificationDocumentsConnectionParams struct {
	Where   *IDentificationDocumentWhereInput   `json:"where,omitempty"`
	OrderBy *IDentificationDocumentOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                              `json:"skip,omitempty"`
	After   *string                             `json:"after,omitempty"`
	Before  *string                             `json:"before,omitempty"`
	First   *int32                              `json:"first,omitempty"`
	Last    *int32                              `json:"last,omitempty"`
}

func (client *Client) IDentificationDocumentsConnection(params *IDentificationDocumentsConnectionParams) IDentificationDocumentConnectionExec {
	panic("not implemented")
}

type LocationsParams struct {
	Where   *LocationWhereInput   `json:"where,omitempty"`
	OrderBy *LocationOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                `json:"skip,omitempty"`
	After   *string               `json:"after,omitempty"`
	Before  *string               `json:"before,omitempty"`
	First   *int32                `json:"first,omitempty"`
	Last    *int32                `json:"last,omitempty"`
}

func (client *Client) Locations(params *LocationsParams) *LocationExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"LocationWhereInput", "LocationOrderByInput", "Location"},
		"locations",
		[]string{"longitude", "latitude", "description"})

	return &LocationExecArray{ret}
}

type LocationsConnectionParams struct {
	Where   *LocationWhereInput   `json:"where,omitempty"`
	OrderBy *LocationOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                `json:"skip,omitempty"`
	After   *string               `json:"after,omitempty"`
	Before  *string               `json:"before,omitempty"`
	First   *int32                `json:"first,omitempty"`
	Last    *int32                `json:"last,omitempty"`
}

func (client *Client) LocationsConnection(params *LocationsConnectionParams) LocationConnectionExec {
	panic("not implemented")
}

type OpeningHoursesParams struct {
	Where   *OpeningHoursWhereInput   `json:"where,omitempty"`
	OrderBy *OpeningHoursOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                    `json:"skip,omitempty"`
	After   *string                   `json:"after,omitempty"`
	Before  *string                   `json:"before,omitempty"`
	First   *int32                    `json:"first,omitempty"`
	Last    *int32                    `json:"last,omitempty"`
}

func (client *Client) OpeningHourses(params *OpeningHoursesParams) *OpeningHoursExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"OpeningHoursWhereInput", "OpeningHoursOrderByInput", "OpeningHours"},
		"openingHourses",
		[]string{"from", "to"})

	return &OpeningHoursExecArray{ret}
}

type OpeningHoursesConnectionParams struct {
	Where   *OpeningHoursWhereInput   `json:"where,omitempty"`
	OrderBy *OpeningHoursOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                    `json:"skip,omitempty"`
	After   *string                   `json:"after,omitempty"`
	Before  *string                   `json:"before,omitempty"`
	First   *int32                    `json:"first,omitempty"`
	Last    *int32                    `json:"last,omitempty"`
}

func (client *Client) OpeningHoursesConnection(params *OpeningHoursesConnectionParams) OpeningHoursConnectionExec {
	panic("not implemented")
}

type OverviewsParams struct {
	Where   *OverviewWhereInput   `json:"where,omitempty"`
	OrderBy *OverviewOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                `json:"skip,omitempty"`
	After   *string               `json:"after,omitempty"`
	Before  *string               `json:"before,omitempty"`
	First   *int32                `json:"first,omitempty"`
	Last    *int32                `json:"last,omitempty"`
}

func (client *Client) Overviews(params *OverviewsParams) *OverviewExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"OverviewWhereInput", "OverviewOrderByInput", "Overview"},
		"overviews",
		[]string{"name", "description"})

	return &OverviewExecArray{ret}
}

type OverviewsConnectionParams struct {
	Where   *OverviewWhereInput   `json:"where,omitempty"`
	OrderBy *OverviewOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                `json:"skip,omitempty"`
	After   *string               `json:"after,omitempty"`
	Before  *string               `json:"before,omitempty"`
	First   *int32                `json:"first,omitempty"`
	Last    *int32                `json:"last,omitempty"`
}

func (client *Client) OverviewsConnection(params *OverviewsConnectionParams) OverviewConnectionExec {
	panic("not implemented")
}

func (client *Client) Partner(params PartnerWhereUniqueInput) *PartnerExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"PartnerWhereUniqueInput!", "Partner"},
		"partner",
		[]string{"id", "createdAt", "updatedAt", "brandName", "socialReason", "ruc", "address"})

	return &PartnerExec{ret}
}

type PartnersParams struct {
	Where   *PartnerWhereInput   `json:"where,omitempty"`
	OrderBy *PartnerOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32               `json:"skip,omitempty"`
	After   *string              `json:"after,omitempty"`
	Before  *string              `json:"before,omitempty"`
	First   *int32               `json:"first,omitempty"`
	Last    *int32               `json:"last,omitempty"`
}

func (client *Client) Partners(params *PartnersParams) *PartnerExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"PartnerWhereInput", "PartnerOrderByInput", "Partner"},
		"partners",
		[]string{"id", "createdAt", "updatedAt", "brandName", "socialReason", "ruc", "address"})

	return &PartnerExecArray{ret}
}

type PartnersConnectionParams struct {
	Where   *PartnerWhereInput   `json:"where,omitempty"`
	OrderBy *PartnerOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32               `json:"skip,omitempty"`
	After   *string              `json:"after,omitempty"`
	Before  *string              `json:"before,omitempty"`
	First   *int32               `json:"first,omitempty"`
	Last    *int32               `json:"last,omitempty"`
}

func (client *Client) PartnersConnection(params *PartnersConnectionParams) PartnerConnectionExec {
	panic("not implemented")
}

func (client *Client) PaymentEntry(params PaymentEntryWhereUniqueInput) *PaymentEntryExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"PaymentEntryWhereUniqueInput!", "PaymentEntry"},
		"paymentEntry",
		[]string{"id", "createdAt", "updatedAt", "externalID", "productID", "product", "gatewayResponse", "amount", "discountID", "discount"})

	return &PaymentEntryExec{ret}
}

type PaymentEntriesParams struct {
	Where   *PaymentEntryWhereInput   `json:"where,omitempty"`
	OrderBy *PaymentEntryOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                    `json:"skip,omitempty"`
	After   *string                   `json:"after,omitempty"`
	Before  *string                   `json:"before,omitempty"`
	First   *int32                    `json:"first,omitempty"`
	Last    *int32                    `json:"last,omitempty"`
}

func (client *Client) PaymentEntries(params *PaymentEntriesParams) *PaymentEntryExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"PaymentEntryWhereInput", "PaymentEntryOrderByInput", "PaymentEntry"},
		"paymentEntries",
		[]string{"id", "createdAt", "updatedAt", "externalID", "productID", "product", "gatewayResponse", "amount", "discountID", "discount"})

	return &PaymentEntryExecArray{ret}
}

type PaymentEntriesConnectionParams struct {
	Where   *PaymentEntryWhereInput   `json:"where,omitempty"`
	OrderBy *PaymentEntryOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                    `json:"skip,omitempty"`
	After   *string                   `json:"after,omitempty"`
	Before  *string                   `json:"before,omitempty"`
	First   *int32                    `json:"first,omitempty"`
	Last    *int32                    `json:"last,omitempty"`
}

func (client *Client) PaymentEntriesConnection(params *PaymentEntriesConnectionParams) PaymentEntryConnectionExec {
	panic("not implemented")
}

func (client *Client) Person(params PersonWhereUniqueInput) *PersonExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"PersonWhereUniqueInput!", "Person"},
		"person",
		[]string{"id", "createdAt", "updatedAt", "mID", "name", "photo", "birthday", "from", "tags"})

	return &PersonExec{ret}
}

type PersonsParams struct {
	Where   *PersonWhereInput   `json:"where,omitempty"`
	OrderBy *PersonOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32              `json:"skip,omitempty"`
	After   *string             `json:"after,omitempty"`
	Before  *string             `json:"before,omitempty"`
	First   *int32              `json:"first,omitempty"`
	Last    *int32              `json:"last,omitempty"`
}

func (client *Client) Persons(params *PersonsParams) *PersonExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"PersonWhereInput", "PersonOrderByInput", "Person"},
		"persons",
		[]string{"id", "createdAt", "updatedAt", "mID", "name", "photo", "birthday", "from", "tags"})

	return &PersonExecArray{ret}
}

type PersonsConnectionParams struct {
	Where   *PersonWhereInput   `json:"where,omitempty"`
	OrderBy *PersonOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32              `json:"skip,omitempty"`
	After   *string             `json:"after,omitempty"`
	Before  *string             `json:"before,omitempty"`
	First   *int32              `json:"first,omitempty"`
	Last    *int32              `json:"last,omitempty"`
}

func (client *Client) PersonsConnection(params *PersonsConnectionParams) PersonConnectionExec {
	panic("not implemented")
}

func (client *Client) PersonReviews(params PersonReviewsWhereUniqueInput) *PersonReviewsExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"PersonReviewsWhereUniqueInput!", "PersonReviews"},
		"personReviews",
		[]string{"id", "createdAt", "updatedAt", "title", "description", "aproveNumber", "declineNumber"})

	return &PersonReviewsExec{ret}
}

type PersonReviewsesParams struct {
	Where   *PersonReviewsWhereInput   `json:"where,omitempty"`
	OrderBy *PersonReviewsOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                     `json:"skip,omitempty"`
	After   *string                    `json:"after,omitempty"`
	Before  *string                    `json:"before,omitempty"`
	First   *int32                     `json:"first,omitempty"`
	Last    *int32                     `json:"last,omitempty"`
}

func (client *Client) PersonReviewses(params *PersonReviewsesParams) *PersonReviewsExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"PersonReviewsWhereInput", "PersonReviewsOrderByInput", "PersonReviews"},
		"personReviewses",
		[]string{"id", "createdAt", "updatedAt", "title", "description", "aproveNumber", "declineNumber"})

	return &PersonReviewsExecArray{ret}
}

type PersonReviewsesConnectionParams struct {
	Where   *PersonReviewsWhereInput   `json:"where,omitempty"`
	OrderBy *PersonReviewsOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                     `json:"skip,omitempty"`
	After   *string                    `json:"after,omitempty"`
	Before  *string                    `json:"before,omitempty"`
	First   *int32                     `json:"first,omitempty"`
	Last    *int32                     `json:"last,omitempty"`
}

func (client *Client) PersonReviewsesConnection(params *PersonReviewsesConnectionParams) PersonReviewsConnectionExec {
	panic("not implemented")
}

func (client *Client) PhoneChannel(params PhoneChannelWhereUniqueInput) *PhoneChannelExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"PhoneChannelWhereUniqueInput!", "PhoneChannel"},
		"phoneChannel",
		[]string{"id", "createdAt", "updatedAt", "displayName", "valid", "countryCode", "number"})

	return &PhoneChannelExec{ret}
}

type PhoneChannelsParams struct {
	Where   *PhoneChannelWhereInput   `json:"where,omitempty"`
	OrderBy *PhoneChannelOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                    `json:"skip,omitempty"`
	After   *string                   `json:"after,omitempty"`
	Before  *string                   `json:"before,omitempty"`
	First   *int32                    `json:"first,omitempty"`
	Last    *int32                    `json:"last,omitempty"`
}

func (client *Client) PhoneChannels(params *PhoneChannelsParams) *PhoneChannelExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"PhoneChannelWhereInput", "PhoneChannelOrderByInput", "PhoneChannel"},
		"phoneChannels",
		[]string{"id", "createdAt", "updatedAt", "displayName", "valid", "countryCode", "number"})

	return &PhoneChannelExecArray{ret}
}

type PhoneChannelsConnectionParams struct {
	Where   *PhoneChannelWhereInput   `json:"where,omitempty"`
	OrderBy *PhoneChannelOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                    `json:"skip,omitempty"`
	After   *string                   `json:"after,omitempty"`
	Before  *string                   `json:"before,omitempty"`
	First   *int32                    `json:"first,omitempty"`
	Last    *int32                    `json:"last,omitempty"`
}

func (client *Client) PhoneChannelsConnection(params *PhoneChannelsConnectionParams) PhoneChannelConnectionExec {
	panic("not implemented")
}

func (client *Client) Ticket(params TicketWhereUniqueInput) *TicketExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"TicketWhereUniqueInput!", "Ticket"},
		"ticket",
		[]string{"id", "createdAt", "updatedAt", "expireAt"})

	return &TicketExec{ret}
}

type TicketsParams struct {
	Where   *TicketWhereInput   `json:"where,omitempty"`
	OrderBy *TicketOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32              `json:"skip,omitempty"`
	After   *string             `json:"after,omitempty"`
	Before  *string             `json:"before,omitempty"`
	First   *int32              `json:"first,omitempty"`
	Last    *int32              `json:"last,omitempty"`
}

func (client *Client) Tickets(params *TicketsParams) *TicketExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"TicketWhereInput", "TicketOrderByInput", "Ticket"},
		"tickets",
		[]string{"id", "createdAt", "updatedAt", "expireAt"})

	return &TicketExecArray{ret}
}

type TicketsConnectionParams struct {
	Where   *TicketWhereInput   `json:"where,omitempty"`
	OrderBy *TicketOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32              `json:"skip,omitempty"`
	After   *string             `json:"after,omitempty"`
	Before  *string             `json:"before,omitempty"`
	First   *int32              `json:"first,omitempty"`
	Last    *int32              `json:"last,omitempty"`
}

func (client *Client) TicketsConnection(params *TicketsConnectionParams) TicketConnectionExec {
	panic("not implemented")
}

func (client *Client) TicketType(params TicketTypeWhereUniqueInput) *TicketTypeExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"TicketTypeWhereUniqueInput!", "TicketType"},
		"ticketType",
		[]string{"id", "createdAt", "updatedAt", "creatorID", "cost"})

	return &TicketTypeExec{ret}
}

type TicketTypesParams struct {
	Where   *TicketTypeWhereInput   `json:"where,omitempty"`
	OrderBy *TicketTypeOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                  `json:"skip,omitempty"`
	After   *string                 `json:"after,omitempty"`
	Before  *string                 `json:"before,omitempty"`
	First   *int32                  `json:"first,omitempty"`
	Last    *int32                  `json:"last,omitempty"`
}

func (client *Client) TicketTypes(params *TicketTypesParams) *TicketTypeExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"TicketTypeWhereInput", "TicketTypeOrderByInput", "TicketType"},
		"ticketTypes",
		[]string{"id", "createdAt", "updatedAt", "creatorID", "cost"})

	return &TicketTypeExecArray{ret}
}

type TicketTypesConnectionParams struct {
	Where   *TicketTypeWhereInput   `json:"where,omitempty"`
	OrderBy *TicketTypeOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                  `json:"skip,omitempty"`
	After   *string                 `json:"after,omitempty"`
	Before  *string                 `json:"before,omitempty"`
	First   *int32                  `json:"first,omitempty"`
	Last    *int32                  `json:"last,omitempty"`
}

func (client *Client) TicketTypesConnection(params *TicketTypesConnectionParams) TicketTypeConnectionExec {
	panic("not implemented")
}

func (client *Client) Traveler(params TravelerWhereUniqueInput) *TravelerExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"TravelerWhereUniqueInput!", "Traveler"},
		"traveler",
		[]string{"id", "createdAt", "updatedAt", "username"})

	return &TravelerExec{ret}
}

type TravelersParams struct {
	Where   *TravelerWhereInput   `json:"where,omitempty"`
	OrderBy *TravelerOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                `json:"skip,omitempty"`
	After   *string               `json:"after,omitempty"`
	Before  *string               `json:"before,omitempty"`
	First   *int32                `json:"first,omitempty"`
	Last    *int32                `json:"last,omitempty"`
}

func (client *Client) Travelers(params *TravelersParams) *TravelerExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"TravelerWhereInput", "TravelerOrderByInput", "Traveler"},
		"travelers",
		[]string{"id", "createdAt", "updatedAt", "username"})

	return &TravelerExecArray{ret}
}

type TravelersConnectionParams struct {
	Where   *TravelerWhereInput   `json:"where,omitempty"`
	OrderBy *TravelerOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                `json:"skip,omitempty"`
	After   *string               `json:"after,omitempty"`
	Before  *string               `json:"before,omitempty"`
	First   *int32                `json:"first,omitempty"`
	Last    *int32                `json:"last,omitempty"`
}

func (client *Client) TravelersConnection(params *TravelersConnectionParams) TravelerConnectionExec {
	panic("not implemented")
}

func (client *Client) CreateAttraction(params AttractionCreateInput) *AttractionExec {
	ret := client.Client.Create(
		params,
		[2]string{"AttractionCreateInput!", "Attraction"},
		"createAttraction",
		[]string{"id", "createdAt", "updatedAt", "maxUses", "address", "popularity", "types", "tags"})

	return &AttractionExec{ret}
}

type AttractionUpdateParams struct {
	Data  AttractionUpdateInput      `json:"data"`
	Where AttractionWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateAttraction(params AttractionUpdateParams) *AttractionExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"AttractionUpdateInput!", "AttractionWhereUniqueInput!", "Attraction"},
		"updateAttraction",
		[]string{"id", "createdAt", "updatedAt", "maxUses", "address", "popularity", "types", "tags"})

	return &AttractionExec{ret}
}

type AttractionUpdateManyParams struct {
	Data  AttractionUpdateManyMutationInput `json:"data"`
	Where *AttractionWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyAttractions(params AttractionUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"AttractionUpdateManyMutationInput!", "AttractionWhereInput"},
		"updateManyAttractions")
	return &BatchPayloadExec{exec}
}

type AttractionUpsertParams struct {
	Where  AttractionWhereUniqueInput `json:"where"`
	Create AttractionCreateInput      `json:"create"`
	Update AttractionUpdateInput      `json:"update"`
}

func (client *Client) UpsertAttraction(params AttractionUpsertParams) *AttractionExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"AttractionWhereUniqueInput!", "AttractionCreateInput!", "AttractionUpdateInput!", "Attraction"},
		"upsertAttraction",
		[]string{"id", "createdAt", "updatedAt", "maxUses", "address", "popularity", "types", "tags"})

	return &AttractionExec{ret}
}

func (client *Client) DeleteAttraction(params AttractionWhereUniqueInput) *AttractionExec {
	ret := client.Client.Delete(
		params,
		[2]string{"AttractionWhereUniqueInput!", "Attraction"},
		"deleteAttraction",
		[]string{"id", "createdAt", "updatedAt", "maxUses", "address", "popularity", "types", "tags"})

	return &AttractionExec{ret}
}

func (client *Client) DeleteManyAttractions(params *AttractionWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "AttractionWhereInput", "deleteManyAttractions")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreateCredential(params CredentialCreateInput) *CredentialExec {
	ret := client.Client.Create(
		params,
		[2]string{"CredentialCreateInput!", "Credential"},
		"createCredential",
		[]string{"id", "createdAt", "updatedAt", "displayName", "isMain", "type", "validated", "validationID", "value", "rawPassword", "hashedPassword"})

	return &CredentialExec{ret}
}

type CredentialUpdateParams struct {
	Data  CredentialUpdateInput      `json:"data"`
	Where CredentialWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateCredential(params CredentialUpdateParams) *CredentialExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"CredentialUpdateInput!", "CredentialWhereUniqueInput!", "Credential"},
		"updateCredential",
		[]string{"id", "createdAt", "updatedAt", "displayName", "isMain", "type", "validated", "validationID", "value", "rawPassword", "hashedPassword"})

	return &CredentialExec{ret}
}

type CredentialUpdateManyParams struct {
	Data  CredentialUpdateManyMutationInput `json:"data"`
	Where *CredentialWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyCredentials(params CredentialUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"CredentialUpdateManyMutationInput!", "CredentialWhereInput"},
		"updateManyCredentials")
	return &BatchPayloadExec{exec}
}

type CredentialUpsertParams struct {
	Where  CredentialWhereUniqueInput `json:"where"`
	Create CredentialCreateInput      `json:"create"`
	Update CredentialUpdateInput      `json:"update"`
}

func (client *Client) UpsertCredential(params CredentialUpsertParams) *CredentialExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"CredentialWhereUniqueInput!", "CredentialCreateInput!", "CredentialUpdateInput!", "Credential"},
		"upsertCredential",
		[]string{"id", "createdAt", "updatedAt", "displayName", "isMain", "type", "validated", "validationID", "value", "rawPassword", "hashedPassword"})

	return &CredentialExec{ret}
}

func (client *Client) DeleteCredential(params CredentialWhereUniqueInput) *CredentialExec {
	ret := client.Client.Delete(
		params,
		[2]string{"CredentialWhereUniqueInput!", "Credential"},
		"deleteCredential",
		[]string{"id", "createdAt", "updatedAt", "displayName", "isMain", "type", "validated", "validationID", "value", "rawPassword", "hashedPassword"})

	return &CredentialExec{ret}
}

func (client *Client) DeleteManyCredentials(params *CredentialWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "CredentialWhereInput", "deleteManyCredentials")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreateCreditCard(params CreditCardCreateInput) *CreditCardExec {
	ret := client.Client.Create(
		params,
		[2]string{"CreditCardCreateInput!", "CreditCard"},
		"createCreditCard",
		[]string{"id", "createdAt", "updatedAt", "cardNumber", "cardToken", "type", "lastUsed"})

	return &CreditCardExec{ret}
}

type CreditCardUpdateParams struct {
	Data  CreditCardUpdateInput      `json:"data"`
	Where CreditCardWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateCreditCard(params CreditCardUpdateParams) *CreditCardExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"CreditCardUpdateInput!", "CreditCardWhereUniqueInput!", "CreditCard"},
		"updateCreditCard",
		[]string{"id", "createdAt", "updatedAt", "cardNumber", "cardToken", "type", "lastUsed"})

	return &CreditCardExec{ret}
}

type CreditCardUpdateManyParams struct {
	Data  CreditCardUpdateManyMutationInput `json:"data"`
	Where *CreditCardWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyCreditCards(params CreditCardUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"CreditCardUpdateManyMutationInput!", "CreditCardWhereInput"},
		"updateManyCreditCards")
	return &BatchPayloadExec{exec}
}

type CreditCardUpsertParams struct {
	Where  CreditCardWhereUniqueInput `json:"where"`
	Create CreditCardCreateInput      `json:"create"`
	Update CreditCardUpdateInput      `json:"update"`
}

func (client *Client) UpsertCreditCard(params CreditCardUpsertParams) *CreditCardExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"CreditCardWhereUniqueInput!", "CreditCardCreateInput!", "CreditCardUpdateInput!", "CreditCard"},
		"upsertCreditCard",
		[]string{"id", "createdAt", "updatedAt", "cardNumber", "cardToken", "type", "lastUsed"})

	return &CreditCardExec{ret}
}

func (client *Client) DeleteCreditCard(params CreditCardWhereUniqueInput) *CreditCardExec {
	ret := client.Client.Delete(
		params,
		[2]string{"CreditCardWhereUniqueInput!", "CreditCard"},
		"deleteCreditCard",
		[]string{"id", "createdAt", "updatedAt", "cardNumber", "cardToken", "type", "lastUsed"})

	return &CreditCardExec{ret}
}

func (client *Client) DeleteManyCreditCards(params *CreditCardWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "CreditCardWhereInput", "deleteManyCreditCards")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreateDetails(params DetailsCreateInput) *DetailsExec {
	ret := client.Client.Create(
		params,
		[2]string{"DetailsCreateInput!", "Details"},
		"createDetails",
		[]string{"providerName", "providerWeb", "contactPhone", "contactEmail", "addressReference"})

	return &DetailsExec{ret}
}

type DetailsUpdateManyParams struct {
	Data  DetailsUpdateManyMutationInput `json:"data"`
	Where *DetailsWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyDetailses(params DetailsUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"DetailsUpdateManyMutationInput!", "DetailsWhereInput"},
		"updateManyDetailses")
	return &BatchPayloadExec{exec}
}

func (client *Client) DeleteManyDetailses(params *DetailsWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "DetailsWhereInput", "deleteManyDetailses")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreateEmailChannel(params EmailChannelCreateInput) *EmailChannelExec {
	ret := client.Client.Create(
		params,
		[2]string{"EmailChannelCreateInput!", "EmailChannel"},
		"createEmailChannel",
		[]string{"id", "createdAt", "updatedAt", "displayName", "valid", "value", "extras"})

	return &EmailChannelExec{ret}
}

type EmailChannelUpdateParams struct {
	Data  EmailChannelUpdateInput      `json:"data"`
	Where EmailChannelWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateEmailChannel(params EmailChannelUpdateParams) *EmailChannelExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"EmailChannelUpdateInput!", "EmailChannelWhereUniqueInput!", "EmailChannel"},
		"updateEmailChannel",
		[]string{"id", "createdAt", "updatedAt", "displayName", "valid", "value", "extras"})

	return &EmailChannelExec{ret}
}

type EmailChannelUpdateManyParams struct {
	Data  EmailChannelUpdateManyMutationInput `json:"data"`
	Where *EmailChannelWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyEmailChannels(params EmailChannelUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"EmailChannelUpdateManyMutationInput!", "EmailChannelWhereInput"},
		"updateManyEmailChannels")
	return &BatchPayloadExec{exec}
}

type EmailChannelUpsertParams struct {
	Where  EmailChannelWhereUniqueInput `json:"where"`
	Create EmailChannelCreateInput      `json:"create"`
	Update EmailChannelUpdateInput      `json:"update"`
}

func (client *Client) UpsertEmailChannel(params EmailChannelUpsertParams) *EmailChannelExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"EmailChannelWhereUniqueInput!", "EmailChannelCreateInput!", "EmailChannelUpdateInput!", "EmailChannel"},
		"upsertEmailChannel",
		[]string{"id", "createdAt", "updatedAt", "displayName", "valid", "value", "extras"})

	return &EmailChannelExec{ret}
}

func (client *Client) DeleteEmailChannel(params EmailChannelWhereUniqueInput) *EmailChannelExec {
	ret := client.Client.Delete(
		params,
		[2]string{"EmailChannelWhereUniqueInput!", "EmailChannel"},
		"deleteEmailChannel",
		[]string{"id", "createdAt", "updatedAt", "displayName", "valid", "value", "extras"})

	return &EmailChannelExec{ret}
}

func (client *Client) DeleteManyEmailChannels(params *EmailChannelWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "EmailChannelWhereInput", "deleteManyEmailChannels")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreateFeature(params FeatureCreateInput) *FeatureExec {
	ret := client.Client.Create(
		params,
		[2]string{"FeatureCreateInput!", "Feature"},
		"createFeature",
		[]string{"name", "image"})

	return &FeatureExec{ret}
}

type FeatureUpdateManyParams struct {
	Data  FeatureUpdateManyMutationInput `json:"data"`
	Where *FeatureWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyFeatures(params FeatureUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"FeatureUpdateManyMutationInput!", "FeatureWhereInput"},
		"updateManyFeatures")
	return &BatchPayloadExec{exec}
}

func (client *Client) DeleteManyFeatures(params *FeatureWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "FeatureWhereInput", "deleteManyFeatures")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreateIdentificationDocument(params IDentificationDocumentCreateInput) *IDentificationDocumentExec {
	ret := client.Client.Create(
		params,
		[2]string{"IdentificationDocumentCreateInput!", "IdentificationDocument"},
		"createIdentificationDocument",
		[]string{"id", "createdAt", "updatedAt", "type", "value", "validated"})

	return &IDentificationDocumentExec{ret}
}

type IDentificationDocumentUpdateParams struct {
	Data  IDentificationDocumentUpdateInput      `json:"data"`
	Where IDentificationDocumentWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateIdentificationDocument(params IDentificationDocumentUpdateParams) *IDentificationDocumentExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"IdentificationDocumentUpdateInput!", "IdentificationDocumentWhereUniqueInput!", "IdentificationDocument"},
		"updateIdentificationDocument",
		[]string{"id", "createdAt", "updatedAt", "type", "value", "validated"})

	return &IDentificationDocumentExec{ret}
}

type IDentificationDocumentUpdateManyParams struct {
	Data  IDentificationDocumentUpdateManyMutationInput `json:"data"`
	Where *IDentificationDocumentWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyIdentificationDocuments(params IDentificationDocumentUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"IdentificationDocumentUpdateManyMutationInput!", "IdentificationDocumentWhereInput"},
		"updateManyIdentificationDocuments")
	return &BatchPayloadExec{exec}
}

type IDentificationDocumentUpsertParams struct {
	Where  IDentificationDocumentWhereUniqueInput `json:"where"`
	Create IDentificationDocumentCreateInput      `json:"create"`
	Update IDentificationDocumentUpdateInput      `json:"update"`
}

func (client *Client) UpsertIdentificationDocument(params IDentificationDocumentUpsertParams) *IDentificationDocumentExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"IdentificationDocumentWhereUniqueInput!", "IdentificationDocumentCreateInput!", "IdentificationDocumentUpdateInput!", "IdentificationDocument"},
		"upsertIdentificationDocument",
		[]string{"id", "createdAt", "updatedAt", "type", "value", "validated"})

	return &IDentificationDocumentExec{ret}
}

func (client *Client) DeleteIdentificationDocument(params IDentificationDocumentWhereUniqueInput) *IDentificationDocumentExec {
	ret := client.Client.Delete(
		params,
		[2]string{"IdentificationDocumentWhereUniqueInput!", "IdentificationDocument"},
		"deleteIdentificationDocument",
		[]string{"id", "createdAt", "updatedAt", "type", "value", "validated"})

	return &IDentificationDocumentExec{ret}
}

func (client *Client) DeleteManyIdentificationDocuments(params *IDentificationDocumentWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "IdentificationDocumentWhereInput", "deleteManyIdentificationDocuments")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreateLocation(params LocationCreateInput) *LocationExec {
	ret := client.Client.Create(
		params,
		[2]string{"LocationCreateInput!", "Location"},
		"createLocation",
		[]string{"longitude", "latitude", "description"})

	return &LocationExec{ret}
}

type LocationUpdateManyParams struct {
	Data  LocationUpdateManyMutationInput `json:"data"`
	Where *LocationWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyLocations(params LocationUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"LocationUpdateManyMutationInput!", "LocationWhereInput"},
		"updateManyLocations")
	return &BatchPayloadExec{exec}
}

func (client *Client) DeleteManyLocations(params *LocationWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "LocationWhereInput", "deleteManyLocations")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreateOpeningHours(params OpeningHoursCreateInput) *OpeningHoursExec {
	ret := client.Client.Create(
		params,
		[2]string{"OpeningHoursCreateInput!", "OpeningHours"},
		"createOpeningHours",
		[]string{"from", "to"})

	return &OpeningHoursExec{ret}
}

type OpeningHoursUpdateManyParams struct {
	Data  OpeningHoursUpdateManyMutationInput `json:"data"`
	Where *OpeningHoursWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyOpeningHourses(params OpeningHoursUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"OpeningHoursUpdateManyMutationInput!", "OpeningHoursWhereInput"},
		"updateManyOpeningHourses")
	return &BatchPayloadExec{exec}
}

func (client *Client) DeleteManyOpeningHourses(params *OpeningHoursWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "OpeningHoursWhereInput", "deleteManyOpeningHourses")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreateOverview(params OverviewCreateInput) *OverviewExec {
	ret := client.Client.Create(
		params,
		[2]string{"OverviewCreateInput!", "Overview"},
		"createOverview",
		[]string{"name", "description"})

	return &OverviewExec{ret}
}

type OverviewUpdateManyParams struct {
	Data  OverviewUpdateManyMutationInput `json:"data"`
	Where *OverviewWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyOverviews(params OverviewUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"OverviewUpdateManyMutationInput!", "OverviewWhereInput"},
		"updateManyOverviews")
	return &BatchPayloadExec{exec}
}

func (client *Client) DeleteManyOverviews(params *OverviewWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "OverviewWhereInput", "deleteManyOverviews")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreatePartner(params PartnerCreateInput) *PartnerExec {
	ret := client.Client.Create(
		params,
		[2]string{"PartnerCreateInput!", "Partner"},
		"createPartner",
		[]string{"id", "createdAt", "updatedAt", "brandName", "socialReason", "ruc", "address"})

	return &PartnerExec{ret}
}

type PartnerUpdateParams struct {
	Data  PartnerUpdateInput      `json:"data"`
	Where PartnerWhereUniqueInput `json:"where"`
}

func (client *Client) UpdatePartner(params PartnerUpdateParams) *PartnerExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"PartnerUpdateInput!", "PartnerWhereUniqueInput!", "Partner"},
		"updatePartner",
		[]string{"id", "createdAt", "updatedAt", "brandName", "socialReason", "ruc", "address"})

	return &PartnerExec{ret}
}

type PartnerUpdateManyParams struct {
	Data  PartnerUpdateManyMutationInput `json:"data"`
	Where *PartnerWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyPartners(params PartnerUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"PartnerUpdateManyMutationInput!", "PartnerWhereInput"},
		"updateManyPartners")
	return &BatchPayloadExec{exec}
}

type PartnerUpsertParams struct {
	Where  PartnerWhereUniqueInput `json:"where"`
	Create PartnerCreateInput      `json:"create"`
	Update PartnerUpdateInput      `json:"update"`
}

func (client *Client) UpsertPartner(params PartnerUpsertParams) *PartnerExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"PartnerWhereUniqueInput!", "PartnerCreateInput!", "PartnerUpdateInput!", "Partner"},
		"upsertPartner",
		[]string{"id", "createdAt", "updatedAt", "brandName", "socialReason", "ruc", "address"})

	return &PartnerExec{ret}
}

func (client *Client) DeletePartner(params PartnerWhereUniqueInput) *PartnerExec {
	ret := client.Client.Delete(
		params,
		[2]string{"PartnerWhereUniqueInput!", "Partner"},
		"deletePartner",
		[]string{"id", "createdAt", "updatedAt", "brandName", "socialReason", "ruc", "address"})

	return &PartnerExec{ret}
}

func (client *Client) DeleteManyPartners(params *PartnerWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "PartnerWhereInput", "deleteManyPartners")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreatePaymentEntry(params PaymentEntryCreateInput) *PaymentEntryExec {
	ret := client.Client.Create(
		params,
		[2]string{"PaymentEntryCreateInput!", "PaymentEntry"},
		"createPaymentEntry",
		[]string{"id", "createdAt", "updatedAt", "externalID", "productID", "product", "gatewayResponse", "amount", "discountID", "discount"})

	return &PaymentEntryExec{ret}
}

type PaymentEntryUpdateParams struct {
	Data  PaymentEntryUpdateInput      `json:"data"`
	Where PaymentEntryWhereUniqueInput `json:"where"`
}

func (client *Client) UpdatePaymentEntry(params PaymentEntryUpdateParams) *PaymentEntryExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"PaymentEntryUpdateInput!", "PaymentEntryWhereUniqueInput!", "PaymentEntry"},
		"updatePaymentEntry",
		[]string{"id", "createdAt", "updatedAt", "externalID", "productID", "product", "gatewayResponse", "amount", "discountID", "discount"})

	return &PaymentEntryExec{ret}
}

type PaymentEntryUpdateManyParams struct {
	Data  PaymentEntryUpdateManyMutationInput `json:"data"`
	Where *PaymentEntryWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyPaymentEntries(params PaymentEntryUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"PaymentEntryUpdateManyMutationInput!", "PaymentEntryWhereInput"},
		"updateManyPaymentEntries")
	return &BatchPayloadExec{exec}
}

type PaymentEntryUpsertParams struct {
	Where  PaymentEntryWhereUniqueInput `json:"where"`
	Create PaymentEntryCreateInput      `json:"create"`
	Update PaymentEntryUpdateInput      `json:"update"`
}

func (client *Client) UpsertPaymentEntry(params PaymentEntryUpsertParams) *PaymentEntryExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"PaymentEntryWhereUniqueInput!", "PaymentEntryCreateInput!", "PaymentEntryUpdateInput!", "PaymentEntry"},
		"upsertPaymentEntry",
		[]string{"id", "createdAt", "updatedAt", "externalID", "productID", "product", "gatewayResponse", "amount", "discountID", "discount"})

	return &PaymentEntryExec{ret}
}

func (client *Client) DeletePaymentEntry(params PaymentEntryWhereUniqueInput) *PaymentEntryExec {
	ret := client.Client.Delete(
		params,
		[2]string{"PaymentEntryWhereUniqueInput!", "PaymentEntry"},
		"deletePaymentEntry",
		[]string{"id", "createdAt", "updatedAt", "externalID", "productID", "product", "gatewayResponse", "amount", "discountID", "discount"})

	return &PaymentEntryExec{ret}
}

func (client *Client) DeleteManyPaymentEntries(params *PaymentEntryWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "PaymentEntryWhereInput", "deleteManyPaymentEntries")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreatePerson(params PersonCreateInput) *PersonExec {
	ret := client.Client.Create(
		params,
		[2]string{"PersonCreateInput!", "Person"},
		"createPerson",
		[]string{"id", "createdAt", "updatedAt", "mID", "name", "photo", "birthday", "from", "tags"})

	return &PersonExec{ret}
}

type PersonUpdateParams struct {
	Data  PersonUpdateInput      `json:"data"`
	Where PersonWhereUniqueInput `json:"where"`
}

func (client *Client) UpdatePerson(params PersonUpdateParams) *PersonExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"PersonUpdateInput!", "PersonWhereUniqueInput!", "Person"},
		"updatePerson",
		[]string{"id", "createdAt", "updatedAt", "mID", "name", "photo", "birthday", "from", "tags"})

	return &PersonExec{ret}
}

type PersonUpdateManyParams struct {
	Data  PersonUpdateManyMutationInput `json:"data"`
	Where *PersonWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyPersons(params PersonUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"PersonUpdateManyMutationInput!", "PersonWhereInput"},
		"updateManyPersons")
	return &BatchPayloadExec{exec}
}

type PersonUpsertParams struct {
	Where  PersonWhereUniqueInput `json:"where"`
	Create PersonCreateInput      `json:"create"`
	Update PersonUpdateInput      `json:"update"`
}

func (client *Client) UpsertPerson(params PersonUpsertParams) *PersonExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"PersonWhereUniqueInput!", "PersonCreateInput!", "PersonUpdateInput!", "Person"},
		"upsertPerson",
		[]string{"id", "createdAt", "updatedAt", "mID", "name", "photo", "birthday", "from", "tags"})

	return &PersonExec{ret}
}

func (client *Client) DeletePerson(params PersonWhereUniqueInput) *PersonExec {
	ret := client.Client.Delete(
		params,
		[2]string{"PersonWhereUniqueInput!", "Person"},
		"deletePerson",
		[]string{"id", "createdAt", "updatedAt", "mID", "name", "photo", "birthday", "from", "tags"})

	return &PersonExec{ret}
}

func (client *Client) DeleteManyPersons(params *PersonWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "PersonWhereInput", "deleteManyPersons")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreatePersonReviews(params PersonReviewsCreateInput) *PersonReviewsExec {
	ret := client.Client.Create(
		params,
		[2]string{"PersonReviewsCreateInput!", "PersonReviews"},
		"createPersonReviews",
		[]string{"id", "createdAt", "updatedAt", "title", "description", "aproveNumber", "declineNumber"})

	return &PersonReviewsExec{ret}
}

type PersonReviewsUpdateParams struct {
	Data  PersonReviewsUpdateInput      `json:"data"`
	Where PersonReviewsWhereUniqueInput `json:"where"`
}

func (client *Client) UpdatePersonReviews(params PersonReviewsUpdateParams) *PersonReviewsExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"PersonReviewsUpdateInput!", "PersonReviewsWhereUniqueInput!", "PersonReviews"},
		"updatePersonReviews",
		[]string{"id", "createdAt", "updatedAt", "title", "description", "aproveNumber", "declineNumber"})

	return &PersonReviewsExec{ret}
}

type PersonReviewsUpdateManyParams struct {
	Data  PersonReviewsUpdateManyMutationInput `json:"data"`
	Where *PersonReviewsWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyPersonReviewses(params PersonReviewsUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"PersonReviewsUpdateManyMutationInput!", "PersonReviewsWhereInput"},
		"updateManyPersonReviewses")
	return &BatchPayloadExec{exec}
}

type PersonReviewsUpsertParams struct {
	Where  PersonReviewsWhereUniqueInput `json:"where"`
	Create PersonReviewsCreateInput      `json:"create"`
	Update PersonReviewsUpdateInput      `json:"update"`
}

func (client *Client) UpsertPersonReviews(params PersonReviewsUpsertParams) *PersonReviewsExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"PersonReviewsWhereUniqueInput!", "PersonReviewsCreateInput!", "PersonReviewsUpdateInput!", "PersonReviews"},
		"upsertPersonReviews",
		[]string{"id", "createdAt", "updatedAt", "title", "description", "aproveNumber", "declineNumber"})

	return &PersonReviewsExec{ret}
}

func (client *Client) DeletePersonReviews(params PersonReviewsWhereUniqueInput) *PersonReviewsExec {
	ret := client.Client.Delete(
		params,
		[2]string{"PersonReviewsWhereUniqueInput!", "PersonReviews"},
		"deletePersonReviews",
		[]string{"id", "createdAt", "updatedAt", "title", "description", "aproveNumber", "declineNumber"})

	return &PersonReviewsExec{ret}
}

func (client *Client) DeleteManyPersonReviewses(params *PersonReviewsWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "PersonReviewsWhereInput", "deleteManyPersonReviewses")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreatePhoneChannel(params PhoneChannelCreateInput) *PhoneChannelExec {
	ret := client.Client.Create(
		params,
		[2]string{"PhoneChannelCreateInput!", "PhoneChannel"},
		"createPhoneChannel",
		[]string{"id", "createdAt", "updatedAt", "displayName", "valid", "countryCode", "number"})

	return &PhoneChannelExec{ret}
}

type PhoneChannelUpdateParams struct {
	Data  PhoneChannelUpdateInput      `json:"data"`
	Where PhoneChannelWhereUniqueInput `json:"where"`
}

func (client *Client) UpdatePhoneChannel(params PhoneChannelUpdateParams) *PhoneChannelExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"PhoneChannelUpdateInput!", "PhoneChannelWhereUniqueInput!", "PhoneChannel"},
		"updatePhoneChannel",
		[]string{"id", "createdAt", "updatedAt", "displayName", "valid", "countryCode", "number"})

	return &PhoneChannelExec{ret}
}

type PhoneChannelUpdateManyParams struct {
	Data  PhoneChannelUpdateManyMutationInput `json:"data"`
	Where *PhoneChannelWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyPhoneChannels(params PhoneChannelUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"PhoneChannelUpdateManyMutationInput!", "PhoneChannelWhereInput"},
		"updateManyPhoneChannels")
	return &BatchPayloadExec{exec}
}

type PhoneChannelUpsertParams struct {
	Where  PhoneChannelWhereUniqueInput `json:"where"`
	Create PhoneChannelCreateInput      `json:"create"`
	Update PhoneChannelUpdateInput      `json:"update"`
}

func (client *Client) UpsertPhoneChannel(params PhoneChannelUpsertParams) *PhoneChannelExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"PhoneChannelWhereUniqueInput!", "PhoneChannelCreateInput!", "PhoneChannelUpdateInput!", "PhoneChannel"},
		"upsertPhoneChannel",
		[]string{"id", "createdAt", "updatedAt", "displayName", "valid", "countryCode", "number"})

	return &PhoneChannelExec{ret}
}

func (client *Client) DeletePhoneChannel(params PhoneChannelWhereUniqueInput) *PhoneChannelExec {
	ret := client.Client.Delete(
		params,
		[2]string{"PhoneChannelWhereUniqueInput!", "PhoneChannel"},
		"deletePhoneChannel",
		[]string{"id", "createdAt", "updatedAt", "displayName", "valid", "countryCode", "number"})

	return &PhoneChannelExec{ret}
}

func (client *Client) DeleteManyPhoneChannels(params *PhoneChannelWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "PhoneChannelWhereInput", "deleteManyPhoneChannels")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreateTicket(params TicketCreateInput) *TicketExec {
	ret := client.Client.Create(
		params,
		[2]string{"TicketCreateInput!", "Ticket"},
		"createTicket",
		[]string{"id", "createdAt", "updatedAt", "expireAt"})

	return &TicketExec{ret}
}

type TicketUpdateParams struct {
	Data  TicketUpdateInput      `json:"data"`
	Where TicketWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateTicket(params TicketUpdateParams) *TicketExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"TicketUpdateInput!", "TicketWhereUniqueInput!", "Ticket"},
		"updateTicket",
		[]string{"id", "createdAt", "updatedAt", "expireAt"})

	return &TicketExec{ret}
}

type TicketUpdateManyParams struct {
	Data  TicketUpdateManyMutationInput `json:"data"`
	Where *TicketWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyTickets(params TicketUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"TicketUpdateManyMutationInput!", "TicketWhereInput"},
		"updateManyTickets")
	return &BatchPayloadExec{exec}
}

type TicketUpsertParams struct {
	Where  TicketWhereUniqueInput `json:"where"`
	Create TicketCreateInput      `json:"create"`
	Update TicketUpdateInput      `json:"update"`
}

func (client *Client) UpsertTicket(params TicketUpsertParams) *TicketExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"TicketWhereUniqueInput!", "TicketCreateInput!", "TicketUpdateInput!", "Ticket"},
		"upsertTicket",
		[]string{"id", "createdAt", "updatedAt", "expireAt"})

	return &TicketExec{ret}
}

func (client *Client) DeleteTicket(params TicketWhereUniqueInput) *TicketExec {
	ret := client.Client.Delete(
		params,
		[2]string{"TicketWhereUniqueInput!", "Ticket"},
		"deleteTicket",
		[]string{"id", "createdAt", "updatedAt", "expireAt"})

	return &TicketExec{ret}
}

func (client *Client) DeleteManyTickets(params *TicketWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "TicketWhereInput", "deleteManyTickets")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreateTicketType(params TicketTypeCreateInput) *TicketTypeExec {
	ret := client.Client.Create(
		params,
		[2]string{"TicketTypeCreateInput!", "TicketType"},
		"createTicketType",
		[]string{"id", "createdAt", "updatedAt", "creatorID", "cost"})

	return &TicketTypeExec{ret}
}

type TicketTypeUpdateParams struct {
	Data  TicketTypeUpdateInput      `json:"data"`
	Where TicketTypeWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateTicketType(params TicketTypeUpdateParams) *TicketTypeExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"TicketTypeUpdateInput!", "TicketTypeWhereUniqueInput!", "TicketType"},
		"updateTicketType",
		[]string{"id", "createdAt", "updatedAt", "creatorID", "cost"})

	return &TicketTypeExec{ret}
}

type TicketTypeUpdateManyParams struct {
	Data  TicketTypeUpdateManyMutationInput `json:"data"`
	Where *TicketTypeWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyTicketTypes(params TicketTypeUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"TicketTypeUpdateManyMutationInput!", "TicketTypeWhereInput"},
		"updateManyTicketTypes")
	return &BatchPayloadExec{exec}
}

type TicketTypeUpsertParams struct {
	Where  TicketTypeWhereUniqueInput `json:"where"`
	Create TicketTypeCreateInput      `json:"create"`
	Update TicketTypeUpdateInput      `json:"update"`
}

func (client *Client) UpsertTicketType(params TicketTypeUpsertParams) *TicketTypeExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"TicketTypeWhereUniqueInput!", "TicketTypeCreateInput!", "TicketTypeUpdateInput!", "TicketType"},
		"upsertTicketType",
		[]string{"id", "createdAt", "updatedAt", "creatorID", "cost"})

	return &TicketTypeExec{ret}
}

func (client *Client) DeleteTicketType(params TicketTypeWhereUniqueInput) *TicketTypeExec {
	ret := client.Client.Delete(
		params,
		[2]string{"TicketTypeWhereUniqueInput!", "TicketType"},
		"deleteTicketType",
		[]string{"id", "createdAt", "updatedAt", "creatorID", "cost"})

	return &TicketTypeExec{ret}
}

func (client *Client) DeleteManyTicketTypes(params *TicketTypeWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "TicketTypeWhereInput", "deleteManyTicketTypes")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreateTraveler(params TravelerCreateInput) *TravelerExec {
	ret := client.Client.Create(
		params,
		[2]string{"TravelerCreateInput!", "Traveler"},
		"createTraveler",
		[]string{"id", "createdAt", "updatedAt", "username"})

	return &TravelerExec{ret}
}

type TravelerUpdateParams struct {
	Data  TravelerUpdateInput      `json:"data"`
	Where TravelerWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateTraveler(params TravelerUpdateParams) *TravelerExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"TravelerUpdateInput!", "TravelerWhereUniqueInput!", "Traveler"},
		"updateTraveler",
		[]string{"id", "createdAt", "updatedAt", "username"})

	return &TravelerExec{ret}
}

type TravelerUpdateManyParams struct {
	Data  TravelerUpdateManyMutationInput `json:"data"`
	Where *TravelerWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyTravelers(params TravelerUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"TravelerUpdateManyMutationInput!", "TravelerWhereInput"},
		"updateManyTravelers")
	return &BatchPayloadExec{exec}
}

type TravelerUpsertParams struct {
	Where  TravelerWhereUniqueInput `json:"where"`
	Create TravelerCreateInput      `json:"create"`
	Update TravelerUpdateInput      `json:"update"`
}

func (client *Client) UpsertTraveler(params TravelerUpsertParams) *TravelerExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"TravelerWhereUniqueInput!", "TravelerCreateInput!", "TravelerUpdateInput!", "Traveler"},
		"upsertTraveler",
		[]string{"id", "createdAt", "updatedAt", "username"})

	return &TravelerExec{ret}
}

func (client *Client) DeleteTraveler(params TravelerWhereUniqueInput) *TravelerExec {
	ret := client.Client.Delete(
		params,
		[2]string{"TravelerWhereUniqueInput!", "Traveler"},
		"deleteTraveler",
		[]string{"id", "createdAt", "updatedAt", "username"})

	return &TravelerExec{ret}
}

func (client *Client) DeleteManyTravelers(params *TravelerWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "TravelerWhereInput", "deleteManyTravelers")
	return &BatchPayloadExec{exec}
}

type EmailChannelOrderByInput string

const (
	EmailChannelOrderByInputIDAsc           EmailChannelOrderByInput = "id_ASC"
	EmailChannelOrderByInputIDDesc          EmailChannelOrderByInput = "id_DESC"
	EmailChannelOrderByInputCreatedAtAsc    EmailChannelOrderByInput = "createdAt_ASC"
	EmailChannelOrderByInputCreatedAtDesc   EmailChannelOrderByInput = "createdAt_DESC"
	EmailChannelOrderByInputUpdatedAtAsc    EmailChannelOrderByInput = "updatedAt_ASC"
	EmailChannelOrderByInputUpdatedAtDesc   EmailChannelOrderByInput = "updatedAt_DESC"
	EmailChannelOrderByInputDisplayNameAsc  EmailChannelOrderByInput = "displayName_ASC"
	EmailChannelOrderByInputDisplayNameDesc EmailChannelOrderByInput = "displayName_DESC"
	EmailChannelOrderByInputValidAsc        EmailChannelOrderByInput = "valid_ASC"
	EmailChannelOrderByInputValidDesc       EmailChannelOrderByInput = "valid_DESC"
	EmailChannelOrderByInputValueAsc        EmailChannelOrderByInput = "value_ASC"
	EmailChannelOrderByInputValueDesc       EmailChannelOrderByInput = "value_DESC"
)

type AttractionOrderByInput string

const (
	AttractionOrderByInputIDAsc          AttractionOrderByInput = "id_ASC"
	AttractionOrderByInputIDDesc         AttractionOrderByInput = "id_DESC"
	AttractionOrderByInputCreatedAtAsc   AttractionOrderByInput = "createdAt_ASC"
	AttractionOrderByInputCreatedAtDesc  AttractionOrderByInput = "createdAt_DESC"
	AttractionOrderByInputUpdatedAtAsc   AttractionOrderByInput = "updatedAt_ASC"
	AttractionOrderByInputUpdatedAtDesc  AttractionOrderByInput = "updatedAt_DESC"
	AttractionOrderByInputMaxUsesAsc     AttractionOrderByInput = "maxUses_ASC"
	AttractionOrderByInputMaxUsesDesc    AttractionOrderByInput = "maxUses_DESC"
	AttractionOrderByInputAddressAsc     AttractionOrderByInput = "address_ASC"
	AttractionOrderByInputAddressDesc    AttractionOrderByInput = "address_DESC"
	AttractionOrderByInputPopularityAsc  AttractionOrderByInput = "popularity_ASC"
	AttractionOrderByInputPopularityDesc AttractionOrderByInput = "popularity_DESC"
)

type TicketOrderByInput string

const (
	TicketOrderByInputIDAsc         TicketOrderByInput = "id_ASC"
	TicketOrderByInputIDDesc        TicketOrderByInput = "id_DESC"
	TicketOrderByInputCreatedAtAsc  TicketOrderByInput = "createdAt_ASC"
	TicketOrderByInputCreatedAtDesc TicketOrderByInput = "createdAt_DESC"
	TicketOrderByInputUpdatedAtAsc  TicketOrderByInput = "updatedAt_ASC"
	TicketOrderByInputUpdatedAtDesc TicketOrderByInput = "updatedAt_DESC"
	TicketOrderByInputExpireAtAsc   TicketOrderByInput = "expireAt_ASC"
	TicketOrderByInputExpireAtDesc  TicketOrderByInput = "expireAt_DESC"
)

type TravelerOrderByInput string

const (
	TravelerOrderByInputIDAsc         TravelerOrderByInput = "id_ASC"
	TravelerOrderByInputIDDesc        TravelerOrderByInput = "id_DESC"
	TravelerOrderByInputCreatedAtAsc  TravelerOrderByInput = "createdAt_ASC"
	TravelerOrderByInputCreatedAtDesc TravelerOrderByInput = "createdAt_DESC"
	TravelerOrderByInputUpdatedAtAsc  TravelerOrderByInput = "updatedAt_ASC"
	TravelerOrderByInputUpdatedAtDesc TravelerOrderByInput = "updatedAt_DESC"
	TravelerOrderByInputUsernameAsc   TravelerOrderByInput = "username_ASC"
	TravelerOrderByInputUsernameDesc  TravelerOrderByInput = "username_DESC"
)

type CreditCardOrderByInput string

const (
	CreditCardOrderByInputIDAsc          CreditCardOrderByInput = "id_ASC"
	CreditCardOrderByInputIDDesc         CreditCardOrderByInput = "id_DESC"
	CreditCardOrderByInputCreatedAtAsc   CreditCardOrderByInput = "createdAt_ASC"
	CreditCardOrderByInputCreatedAtDesc  CreditCardOrderByInput = "createdAt_DESC"
	CreditCardOrderByInputUpdatedAtAsc   CreditCardOrderByInput = "updatedAt_ASC"
	CreditCardOrderByInputUpdatedAtDesc  CreditCardOrderByInput = "updatedAt_DESC"
	CreditCardOrderByInputCardNumberAsc  CreditCardOrderByInput = "cardNumber_ASC"
	CreditCardOrderByInputCardNumberDesc CreditCardOrderByInput = "cardNumber_DESC"
	CreditCardOrderByInputCardTokenAsc   CreditCardOrderByInput = "cardToken_ASC"
	CreditCardOrderByInputCardTokenDesc  CreditCardOrderByInput = "cardToken_DESC"
	CreditCardOrderByInputTypeAsc        CreditCardOrderByInput = "type_ASC"
	CreditCardOrderByInputTypeDesc       CreditCardOrderByInput = "type_DESC"
	CreditCardOrderByInputLastUsedAsc    CreditCardOrderByInput = "lastUsed_ASC"
	CreditCardOrderByInputLastUsedDesc   CreditCardOrderByInput = "lastUsed_DESC"
)

type PartnerOrderByInput string

const (
	PartnerOrderByInputIDAsc            PartnerOrderByInput = "id_ASC"
	PartnerOrderByInputIDDesc           PartnerOrderByInput = "id_DESC"
	PartnerOrderByInputCreatedAtAsc     PartnerOrderByInput = "createdAt_ASC"
	PartnerOrderByInputCreatedAtDesc    PartnerOrderByInput = "createdAt_DESC"
	PartnerOrderByInputUpdatedAtAsc     PartnerOrderByInput = "updatedAt_ASC"
	PartnerOrderByInputUpdatedAtDesc    PartnerOrderByInput = "updatedAt_DESC"
	PartnerOrderByInputBrandNameAsc     PartnerOrderByInput = "brandName_ASC"
	PartnerOrderByInputBrandNameDesc    PartnerOrderByInput = "brandName_DESC"
	PartnerOrderByInputSocialReasonAsc  PartnerOrderByInput = "socialReason_ASC"
	PartnerOrderByInputSocialReasonDesc PartnerOrderByInput = "socialReason_DESC"
	PartnerOrderByInputRucAsc           PartnerOrderByInput = "ruc_ASC"
	PartnerOrderByInputRucDesc          PartnerOrderByInput = "ruc_DESC"
	PartnerOrderByInputAddressAsc       PartnerOrderByInput = "address_ASC"
	PartnerOrderByInputAddressDesc      PartnerOrderByInput = "address_DESC"
)

type IDentificationType string

const (
	IDentificationTypeDni      IDentificationType = "DNI"
	IDentificationTypePassport IDentificationType = "PASSPORT"
)

type OpeningHoursOrderByInput string

const (
	OpeningHoursOrderByInputFromAsc       OpeningHoursOrderByInput = "from_ASC"
	OpeningHoursOrderByInputFromDesc      OpeningHoursOrderByInput = "from_DESC"
	OpeningHoursOrderByInputToAsc         OpeningHoursOrderByInput = "to_ASC"
	OpeningHoursOrderByInputToDesc        OpeningHoursOrderByInput = "to_DESC"
	OpeningHoursOrderByInputIDAsc         OpeningHoursOrderByInput = "id_ASC"
	OpeningHoursOrderByInputIDDesc        OpeningHoursOrderByInput = "id_DESC"
	OpeningHoursOrderByInputCreatedAtAsc  OpeningHoursOrderByInput = "createdAt_ASC"
	OpeningHoursOrderByInputCreatedAtDesc OpeningHoursOrderByInput = "createdAt_DESC"
	OpeningHoursOrderByInputUpdatedAtAsc  OpeningHoursOrderByInput = "updatedAt_ASC"
	OpeningHoursOrderByInputUpdatedAtDesc OpeningHoursOrderByInput = "updatedAt_DESC"
)

type CreditCardType string

const (
	CreditCardTypeVisa       CreditCardType = "VISA"
	CreditCardTypeMastercard CreditCardType = "MASTERCARD"
	CreditCardTypeAmerican   CreditCardType = "AMERICAN"
)

type PhoneChannelOrderByInput string

const (
	PhoneChannelOrderByInputIDAsc           PhoneChannelOrderByInput = "id_ASC"
	PhoneChannelOrderByInputIDDesc          PhoneChannelOrderByInput = "id_DESC"
	PhoneChannelOrderByInputCreatedAtAsc    PhoneChannelOrderByInput = "createdAt_ASC"
	PhoneChannelOrderByInputCreatedAtDesc   PhoneChannelOrderByInput = "createdAt_DESC"
	PhoneChannelOrderByInputUpdatedAtAsc    PhoneChannelOrderByInput = "updatedAt_ASC"
	PhoneChannelOrderByInputUpdatedAtDesc   PhoneChannelOrderByInput = "updatedAt_DESC"
	PhoneChannelOrderByInputDisplayNameAsc  PhoneChannelOrderByInput = "displayName_ASC"
	PhoneChannelOrderByInputDisplayNameDesc PhoneChannelOrderByInput = "displayName_DESC"
	PhoneChannelOrderByInputValidAsc        PhoneChannelOrderByInput = "valid_ASC"
	PhoneChannelOrderByInputValidDesc       PhoneChannelOrderByInput = "valid_DESC"
	PhoneChannelOrderByInputCountryCodeAsc  PhoneChannelOrderByInput = "countryCode_ASC"
	PhoneChannelOrderByInputCountryCodeDesc PhoneChannelOrderByInput = "countryCode_DESC"
	PhoneChannelOrderByInputNumberAsc       PhoneChannelOrderByInput = "number_ASC"
	PhoneChannelOrderByInputNumberDesc      PhoneChannelOrderByInput = "number_DESC"
)

type PersonReviewsOrderByInput string

const (
	PersonReviewsOrderByInputIDAsc             PersonReviewsOrderByInput = "id_ASC"
	PersonReviewsOrderByInputIDDesc            PersonReviewsOrderByInput = "id_DESC"
	PersonReviewsOrderByInputCreatedAtAsc      PersonReviewsOrderByInput = "createdAt_ASC"
	PersonReviewsOrderByInputCreatedAtDesc     PersonReviewsOrderByInput = "createdAt_DESC"
	PersonReviewsOrderByInputUpdatedAtAsc      PersonReviewsOrderByInput = "updatedAt_ASC"
	PersonReviewsOrderByInputUpdatedAtDesc     PersonReviewsOrderByInput = "updatedAt_DESC"
	PersonReviewsOrderByInputTitleAsc          PersonReviewsOrderByInput = "title_ASC"
	PersonReviewsOrderByInputTitleDesc         PersonReviewsOrderByInput = "title_DESC"
	PersonReviewsOrderByInputDescriptionAsc    PersonReviewsOrderByInput = "description_ASC"
	PersonReviewsOrderByInputDescriptionDesc   PersonReviewsOrderByInput = "description_DESC"
	PersonReviewsOrderByInputAproveNumberAsc   PersonReviewsOrderByInput = "aproveNumber_ASC"
	PersonReviewsOrderByInputAproveNumberDesc  PersonReviewsOrderByInput = "aproveNumber_DESC"
	PersonReviewsOrderByInputDeclineNumberAsc  PersonReviewsOrderByInput = "declineNumber_ASC"
	PersonReviewsOrderByInputDeclineNumberDesc PersonReviewsOrderByInput = "declineNumber_DESC"
)

type DetailsOrderByInput string

const (
	DetailsOrderByInputProviderNameAsc      DetailsOrderByInput = "providerName_ASC"
	DetailsOrderByInputProviderNameDesc     DetailsOrderByInput = "providerName_DESC"
	DetailsOrderByInputProviderWebAsc       DetailsOrderByInput = "providerWeb_ASC"
	DetailsOrderByInputProviderWebDesc      DetailsOrderByInput = "providerWeb_DESC"
	DetailsOrderByInputContactPhoneAsc      DetailsOrderByInput = "contactPhone_ASC"
	DetailsOrderByInputContactPhoneDesc     DetailsOrderByInput = "contactPhone_DESC"
	DetailsOrderByInputContactEmailAsc      DetailsOrderByInput = "contactEmail_ASC"
	DetailsOrderByInputContactEmailDesc     DetailsOrderByInput = "contactEmail_DESC"
	DetailsOrderByInputAddressReferenceAsc  DetailsOrderByInput = "addressReference_ASC"
	DetailsOrderByInputAddressReferenceDesc DetailsOrderByInput = "addressReference_DESC"
	DetailsOrderByInputIDAsc                DetailsOrderByInput = "id_ASC"
	DetailsOrderByInputIDDesc               DetailsOrderByInput = "id_DESC"
	DetailsOrderByInputCreatedAtAsc         DetailsOrderByInput = "createdAt_ASC"
	DetailsOrderByInputCreatedAtDesc        DetailsOrderByInput = "createdAt_DESC"
	DetailsOrderByInputUpdatedAtAsc         DetailsOrderByInput = "updatedAt_ASC"
	DetailsOrderByInputUpdatedAtDesc        DetailsOrderByInput = "updatedAt_DESC"
)

type AttractionType string

const (
	AttractionTypeAdventure  AttractionType = "ADVENTURE"
	AttractionTypeHistory    AttractionType = "HISTORY"
	AttractionTypeRestaurant AttractionType = "RESTAURANT"
	AttractionTypeHotel      AttractionType = "HOTEL"
	AttractionTypeNature     AttractionType = "NATURE"
	AttractionTypeDiscount   AttractionType = "DISCOUNT"
)

type MutationType string

const (
	MutationTypeCreated MutationType = "CREATED"
	MutationTypeUpdated MutationType = "UPDATED"
	MutationTypeDeleted MutationType = "DELETED"
)

type FeatureOrderByInput string

const (
	FeatureOrderByInputNameAsc       FeatureOrderByInput = "name_ASC"
	FeatureOrderByInputNameDesc      FeatureOrderByInput = "name_DESC"
	FeatureOrderByInputImageAsc      FeatureOrderByInput = "image_ASC"
	FeatureOrderByInputImageDesc     FeatureOrderByInput = "image_DESC"
	FeatureOrderByInputIDAsc         FeatureOrderByInput = "id_ASC"
	FeatureOrderByInputIDDesc        FeatureOrderByInput = "id_DESC"
	FeatureOrderByInputCreatedAtAsc  FeatureOrderByInput = "createdAt_ASC"
	FeatureOrderByInputCreatedAtDesc FeatureOrderByInput = "createdAt_DESC"
	FeatureOrderByInputUpdatedAtAsc  FeatureOrderByInput = "updatedAt_ASC"
	FeatureOrderByInputUpdatedAtDesc FeatureOrderByInput = "updatedAt_DESC"
)

type PersonOrderByInput string

const (
	PersonOrderByInputIDAsc         PersonOrderByInput = "id_ASC"
	PersonOrderByInputIDDesc        PersonOrderByInput = "id_DESC"
	PersonOrderByInputCreatedAtAsc  PersonOrderByInput = "createdAt_ASC"
	PersonOrderByInputCreatedAtDesc PersonOrderByInput = "createdAt_DESC"
	PersonOrderByInputUpdatedAtAsc  PersonOrderByInput = "updatedAt_ASC"
	PersonOrderByInputUpdatedAtDesc PersonOrderByInput = "updatedAt_DESC"
	PersonOrderByInputMIdAsc        PersonOrderByInput = "mID_ASC"
	PersonOrderByInputMIdDesc       PersonOrderByInput = "mID_DESC"
	PersonOrderByInputNameAsc       PersonOrderByInput = "name_ASC"
	PersonOrderByInputNameDesc      PersonOrderByInput = "name_DESC"
	PersonOrderByInputPhotoAsc      PersonOrderByInput = "photo_ASC"
	PersonOrderByInputPhotoDesc     PersonOrderByInput = "photo_DESC"
	PersonOrderByInputBirthdayAsc   PersonOrderByInput = "birthday_ASC"
	PersonOrderByInputBirthdayDesc  PersonOrderByInput = "birthday_DESC"
	PersonOrderByInputFromAsc       PersonOrderByInput = "from_ASC"
	PersonOrderByInputFromDesc      PersonOrderByInput = "from_DESC"
)

type CredentialOrderByInput string

const (
	CredentialOrderByInputIDAsc              CredentialOrderByInput = "id_ASC"
	CredentialOrderByInputIDDesc             CredentialOrderByInput = "id_DESC"
	CredentialOrderByInputCreatedAtAsc       CredentialOrderByInput = "createdAt_ASC"
	CredentialOrderByInputCreatedAtDesc      CredentialOrderByInput = "createdAt_DESC"
	CredentialOrderByInputUpdatedAtAsc       CredentialOrderByInput = "updatedAt_ASC"
	CredentialOrderByInputUpdatedAtDesc      CredentialOrderByInput = "updatedAt_DESC"
	CredentialOrderByInputDisplayNameAsc     CredentialOrderByInput = "displayName_ASC"
	CredentialOrderByInputDisplayNameDesc    CredentialOrderByInput = "displayName_DESC"
	CredentialOrderByInputIsMainAsc          CredentialOrderByInput = "isMain_ASC"
	CredentialOrderByInputIsMainDesc         CredentialOrderByInput = "isMain_DESC"
	CredentialOrderByInputTypeAsc            CredentialOrderByInput = "type_ASC"
	CredentialOrderByInputTypeDesc           CredentialOrderByInput = "type_DESC"
	CredentialOrderByInputValidatedAsc       CredentialOrderByInput = "validated_ASC"
	CredentialOrderByInputValidatedDesc      CredentialOrderByInput = "validated_DESC"
	CredentialOrderByInputValidationIdAsc    CredentialOrderByInput = "validationID_ASC"
	CredentialOrderByInputValidationIdDesc   CredentialOrderByInput = "validationID_DESC"
	CredentialOrderByInputValueAsc           CredentialOrderByInput = "value_ASC"
	CredentialOrderByInputValueDesc          CredentialOrderByInput = "value_DESC"
	CredentialOrderByInputRawPasswordAsc     CredentialOrderByInput = "rawPassword_ASC"
	CredentialOrderByInputRawPasswordDesc    CredentialOrderByInput = "rawPassword_DESC"
	CredentialOrderByInputHashedPasswordAsc  CredentialOrderByInput = "hashedPassword_ASC"
	CredentialOrderByInputHashedPasswordDesc CredentialOrderByInput = "hashedPassword_DESC"
)

type CredentialType string

const (
	CredentialTypeEmail     CredentialType = "EMAIL"
	CredentialTypePhone     CredentialType = "PHONE"
	CredentialTypeGmail     CredentialType = "GMAIL"
	CredentialTypeFacebook  CredentialType = "FACEBOOK"
	CredentialTypeAnonymous CredentialType = "ANONYMOUS"
)

type TicketTypeOrderByInput string

const (
	TicketTypeOrderByInputIDAsc         TicketTypeOrderByInput = "id_ASC"
	TicketTypeOrderByInputIDDesc        TicketTypeOrderByInput = "id_DESC"
	TicketTypeOrderByInputCreatedAtAsc  TicketTypeOrderByInput = "createdAt_ASC"
	TicketTypeOrderByInputCreatedAtDesc TicketTypeOrderByInput = "createdAt_DESC"
	TicketTypeOrderByInputUpdatedAtAsc  TicketTypeOrderByInput = "updatedAt_ASC"
	TicketTypeOrderByInputUpdatedAtDesc TicketTypeOrderByInput = "updatedAt_DESC"
	TicketTypeOrderByInputCreatorIdAsc  TicketTypeOrderByInput = "creatorID_ASC"
	TicketTypeOrderByInputCreatorIdDesc TicketTypeOrderByInput = "creatorID_DESC"
	TicketTypeOrderByInputCostAsc       TicketTypeOrderByInput = "cost_ASC"
	TicketTypeOrderByInputCostDesc      TicketTypeOrderByInput = "cost_DESC"
)

type PaymentEntryOrderByInput string

const (
	PaymentEntryOrderByInputIDAsc               PaymentEntryOrderByInput = "id_ASC"
	PaymentEntryOrderByInputIDDesc              PaymentEntryOrderByInput = "id_DESC"
	PaymentEntryOrderByInputCreatedAtAsc        PaymentEntryOrderByInput = "createdAt_ASC"
	PaymentEntryOrderByInputCreatedAtDesc       PaymentEntryOrderByInput = "createdAt_DESC"
	PaymentEntryOrderByInputUpdatedAtAsc        PaymentEntryOrderByInput = "updatedAt_ASC"
	PaymentEntryOrderByInputUpdatedAtDesc       PaymentEntryOrderByInput = "updatedAt_DESC"
	PaymentEntryOrderByInputExternalIdAsc       PaymentEntryOrderByInput = "externalID_ASC"
	PaymentEntryOrderByInputExternalIdDesc      PaymentEntryOrderByInput = "externalID_DESC"
	PaymentEntryOrderByInputProductIdAsc        PaymentEntryOrderByInput = "productID_ASC"
	PaymentEntryOrderByInputProductIdDesc       PaymentEntryOrderByInput = "productID_DESC"
	PaymentEntryOrderByInputProductAsc          PaymentEntryOrderByInput = "product_ASC"
	PaymentEntryOrderByInputProductDesc         PaymentEntryOrderByInput = "product_DESC"
	PaymentEntryOrderByInputGatewayResponseAsc  PaymentEntryOrderByInput = "gatewayResponse_ASC"
	PaymentEntryOrderByInputGatewayResponseDesc PaymentEntryOrderByInput = "gatewayResponse_DESC"
	PaymentEntryOrderByInputAmountAsc           PaymentEntryOrderByInput = "amount_ASC"
	PaymentEntryOrderByInputAmountDesc          PaymentEntryOrderByInput = "amount_DESC"
	PaymentEntryOrderByInputDiscountIdAsc       PaymentEntryOrderByInput = "discountID_ASC"
	PaymentEntryOrderByInputDiscountIdDesc      PaymentEntryOrderByInput = "discountID_DESC"
	PaymentEntryOrderByInputDiscountAsc         PaymentEntryOrderByInput = "discount_ASC"
	PaymentEntryOrderByInputDiscountDesc        PaymentEntryOrderByInput = "discount_DESC"
)

type IDentificationDocumentOrderByInput string

const (
	IDentificationDocumentOrderByInputIDAsc         IDentificationDocumentOrderByInput = "id_ASC"
	IDentificationDocumentOrderByInputIDDesc        IDentificationDocumentOrderByInput = "id_DESC"
	IDentificationDocumentOrderByInputCreatedAtAsc  IDentificationDocumentOrderByInput = "createdAt_ASC"
	IDentificationDocumentOrderByInputCreatedAtDesc IDentificationDocumentOrderByInput = "createdAt_DESC"
	IDentificationDocumentOrderByInputUpdatedAtAsc  IDentificationDocumentOrderByInput = "updatedAt_ASC"
	IDentificationDocumentOrderByInputUpdatedAtDesc IDentificationDocumentOrderByInput = "updatedAt_DESC"
	IDentificationDocumentOrderByInputTypeAsc       IDentificationDocumentOrderByInput = "type_ASC"
	IDentificationDocumentOrderByInputTypeDesc      IDentificationDocumentOrderByInput = "type_DESC"
	IDentificationDocumentOrderByInputValueAsc      IDentificationDocumentOrderByInput = "value_ASC"
	IDentificationDocumentOrderByInputValueDesc     IDentificationDocumentOrderByInput = "value_DESC"
	IDentificationDocumentOrderByInputValidatedAsc  IDentificationDocumentOrderByInput = "validated_ASC"
	IDentificationDocumentOrderByInputValidatedDesc IDentificationDocumentOrderByInput = "validated_DESC"
)

type LocationOrderByInput string

const (
	LocationOrderByInputLongitudeAsc    LocationOrderByInput = "longitude_ASC"
	LocationOrderByInputLongitudeDesc   LocationOrderByInput = "longitude_DESC"
	LocationOrderByInputLatitudeAsc     LocationOrderByInput = "latitude_ASC"
	LocationOrderByInputLatitudeDesc    LocationOrderByInput = "latitude_DESC"
	LocationOrderByInputDescriptionAsc  LocationOrderByInput = "description_ASC"
	LocationOrderByInputDescriptionDesc LocationOrderByInput = "description_DESC"
	LocationOrderByInputIDAsc           LocationOrderByInput = "id_ASC"
	LocationOrderByInputIDDesc          LocationOrderByInput = "id_DESC"
	LocationOrderByInputCreatedAtAsc    LocationOrderByInput = "createdAt_ASC"
	LocationOrderByInputCreatedAtDesc   LocationOrderByInput = "createdAt_DESC"
	LocationOrderByInputUpdatedAtAsc    LocationOrderByInput = "updatedAt_ASC"
	LocationOrderByInputUpdatedAtDesc   LocationOrderByInput = "updatedAt_DESC"
)

type OverviewOrderByInput string

const (
	OverviewOrderByInputNameAsc         OverviewOrderByInput = "name_ASC"
	OverviewOrderByInputNameDesc        OverviewOrderByInput = "name_DESC"
	OverviewOrderByInputDescriptionAsc  OverviewOrderByInput = "description_ASC"
	OverviewOrderByInputDescriptionDesc OverviewOrderByInput = "description_DESC"
	OverviewOrderByInputIDAsc           OverviewOrderByInput = "id_ASC"
	OverviewOrderByInputIDDesc          OverviewOrderByInput = "id_DESC"
	OverviewOrderByInputCreatedAtAsc    OverviewOrderByInput = "createdAt_ASC"
	OverviewOrderByInputCreatedAtDesc   OverviewOrderByInput = "createdAt_DESC"
	OverviewOrderByInputUpdatedAtAsc    OverviewOrderByInput = "updatedAt_ASC"
	OverviewOrderByInputUpdatedAtDesc   OverviewOrderByInput = "updatedAt_DESC"
)

type LocationUpdateOneRequiredInput struct {
	Create *LocationCreateInput       `json:"create,omitempty"`
	Update *LocationUpdateDataInput   `json:"update,omitempty"`
	Upsert *LocationUpsertNestedInput `json:"upsert,omitempty"`
}

type AttractionWhereUniqueInput struct {
	ID *string `json:"id,omitempty"`
}

type OverviewUpdateDataInput struct {
	Name        *string `json:"name,omitempty"`
	Description *string `json:"description,omitempty"`
}

type LocationWhereInput struct {
	Longitude                *float64             `json:"longitude,omitempty"`
	LongitudeNot             *float64             `json:"longitude_not,omitempty"`
	LongitudeIn              []float64            `json:"longitude_in,omitempty"`
	LongitudeNotIn           []float64            `json:"longitude_not_in,omitempty"`
	LongitudeLt              *float64             `json:"longitude_lt,omitempty"`
	LongitudeLte             *float64             `json:"longitude_lte,omitempty"`
	LongitudeGt              *float64             `json:"longitude_gt,omitempty"`
	LongitudeGte             *float64             `json:"longitude_gte,omitempty"`
	Latitude                 *float64             `json:"latitude,omitempty"`
	LatitudeNot              *float64             `json:"latitude_not,omitempty"`
	LatitudeIn               []float64            `json:"latitude_in,omitempty"`
	LatitudeNotIn            []float64            `json:"latitude_not_in,omitempty"`
	LatitudeLt               *float64             `json:"latitude_lt,omitempty"`
	LatitudeLte              *float64             `json:"latitude_lte,omitempty"`
	LatitudeGt               *float64             `json:"latitude_gt,omitempty"`
	LatitudeGte              *float64             `json:"latitude_gte,omitempty"`
	Description              *string              `json:"description,omitempty"`
	DescriptionNot           *string              `json:"description_not,omitempty"`
	DescriptionIn            []string             `json:"description_in,omitempty"`
	DescriptionNotIn         []string             `json:"description_not_in,omitempty"`
	DescriptionLt            *string              `json:"description_lt,omitempty"`
	DescriptionLte           *string              `json:"description_lte,omitempty"`
	DescriptionGt            *string              `json:"description_gt,omitempty"`
	DescriptionGte           *string              `json:"description_gte,omitempty"`
	DescriptionContains      *string              `json:"description_contains,omitempty"`
	DescriptionNotContains   *string              `json:"description_not_contains,omitempty"`
	DescriptionStartsWith    *string              `json:"description_starts_with,omitempty"`
	DescriptionNotStartsWith *string              `json:"description_not_starts_with,omitempty"`
	DescriptionEndsWith      *string              `json:"description_ends_with,omitempty"`
	DescriptionNotEndsWith   *string              `json:"description_not_ends_with,omitempty"`
	And                      []LocationWhereInput `json:"AND,omitempty"`
	Or                       []LocationWhereInput `json:"OR,omitempty"`
	Not                      []LocationWhereInput `json:"NOT,omitempty"`
}

type OverviewUpsertNestedInput struct {
	Update OverviewUpdateDataInput `json:"update"`
	Create OverviewCreateInput     `json:"create"`
}

type FeatureWhereInput struct {
	Name               *string             `json:"name,omitempty"`
	NameNot            *string             `json:"name_not,omitempty"`
	NameIn             []string            `json:"name_in,omitempty"`
	NameNotIn          []string            `json:"name_not_in,omitempty"`
	NameLt             *string             `json:"name_lt,omitempty"`
	NameLte            *string             `json:"name_lte,omitempty"`
	NameGt             *string             `json:"name_gt,omitempty"`
	NameGte            *string             `json:"name_gte,omitempty"`
	NameContains       *string             `json:"name_contains,omitempty"`
	NameNotContains    *string             `json:"name_not_contains,omitempty"`
	NameStartsWith     *string             `json:"name_starts_with,omitempty"`
	NameNotStartsWith  *string             `json:"name_not_starts_with,omitempty"`
	NameEndsWith       *string             `json:"name_ends_with,omitempty"`
	NameNotEndsWith    *string             `json:"name_not_ends_with,omitempty"`
	Image              *string             `json:"image,omitempty"`
	ImageNot           *string             `json:"image_not,omitempty"`
	ImageIn            []string            `json:"image_in,omitempty"`
	ImageNotIn         []string            `json:"image_not_in,omitempty"`
	ImageLt            *string             `json:"image_lt,omitempty"`
	ImageLte           *string             `json:"image_lte,omitempty"`
	ImageGt            *string             `json:"image_gt,omitempty"`
	ImageGte           *string             `json:"image_gte,omitempty"`
	ImageContains      *string             `json:"image_contains,omitempty"`
	ImageNotContains   *string             `json:"image_not_contains,omitempty"`
	ImageStartsWith    *string             `json:"image_starts_with,omitempty"`
	ImageNotStartsWith *string             `json:"image_not_starts_with,omitempty"`
	ImageEndsWith      *string             `json:"image_ends_with,omitempty"`
	ImageNotEndsWith   *string             `json:"image_not_ends_with,omitempty"`
	And                []FeatureWhereInput `json:"AND,omitempty"`
	Or                 []FeatureWhereInput `json:"OR,omitempty"`
	Not                []FeatureWhereInput `json:"NOT,omitempty"`
}

type PersonUpdateManyInput struct {
	Create     []PersonCreateInput                      `json:"create,omitempty"`
	Update     []PersonUpdateWithWhereUniqueNestedInput `json:"update,omitempty"`
	Upsert     []PersonUpsertWithWhereUniqueNestedInput `json:"upsert,omitempty"`
	Delete     []PersonWhereUniqueInput                 `json:"delete,omitempty"`
	Connect    []PersonWhereUniqueInput                 `json:"connect,omitempty"`
	Set        []PersonWhereUniqueInput                 `json:"set,omitempty"`
	Disconnect []PersonWhereUniqueInput                 `json:"disconnect,omitempty"`
	DeleteMany []PersonScalarWhereInput                 `json:"deleteMany,omitempty"`
	UpdateMany []PersonUpdateManyWithWhereNestedInput   `json:"updateMany,omitempty"`
}

type OverviewWhereInput struct {
	Name                     *string              `json:"name,omitempty"`
	NameNot                  *string              `json:"name_not,omitempty"`
	NameIn                   []string             `json:"name_in,omitempty"`
	NameNotIn                []string             `json:"name_not_in,omitempty"`
	NameLt                   *string              `json:"name_lt,omitempty"`
	NameLte                  *string              `json:"name_lte,omitempty"`
	NameGt                   *string              `json:"name_gt,omitempty"`
	NameGte                  *string              `json:"name_gte,omitempty"`
	NameContains             *string              `json:"name_contains,omitempty"`
	NameNotContains          *string              `json:"name_not_contains,omitempty"`
	NameStartsWith           *string              `json:"name_starts_with,omitempty"`
	NameNotStartsWith        *string              `json:"name_not_starts_with,omitempty"`
	NameEndsWith             *string              `json:"name_ends_with,omitempty"`
	NameNotEndsWith          *string              `json:"name_not_ends_with,omitempty"`
	Description              *string              `json:"description,omitempty"`
	DescriptionNot           *string              `json:"description_not,omitempty"`
	DescriptionIn            []string             `json:"description_in,omitempty"`
	DescriptionNotIn         []string             `json:"description_not_in,omitempty"`
	DescriptionLt            *string              `json:"description_lt,omitempty"`
	DescriptionLte           *string              `json:"description_lte,omitempty"`
	DescriptionGt            *string              `json:"description_gt,omitempty"`
	DescriptionGte           *string              `json:"description_gte,omitempty"`
	DescriptionContains      *string              `json:"description_contains,omitempty"`
	DescriptionNotContains   *string              `json:"description_not_contains,omitempty"`
	DescriptionStartsWith    *string              `json:"description_starts_with,omitempty"`
	DescriptionNotStartsWith *string              `json:"description_not_starts_with,omitempty"`
	DescriptionEndsWith      *string              `json:"description_ends_with,omitempty"`
	DescriptionNotEndsWith   *string              `json:"description_not_ends_with,omitempty"`
	And                      []OverviewWhereInput `json:"AND,omitempty"`
	Or                       []OverviewWhereInput `json:"OR,omitempty"`
	Not                      []OverviewWhereInput `json:"NOT,omitempty"`
}

type PersonUpdateWithWhereUniqueNestedInput struct {
	Where PersonWhereUniqueInput `json:"where"`
	Data  PersonUpdateDataInput  `json:"data"`
}

type DetailsWhereInput struct {
	ProviderName                  *string             `json:"providerName,omitempty"`
	ProviderNameNot               *string             `json:"providerName_not,omitempty"`
	ProviderNameIn                []string            `json:"providerName_in,omitempty"`
	ProviderNameNotIn             []string            `json:"providerName_not_in,omitempty"`
	ProviderNameLt                *string             `json:"providerName_lt,omitempty"`
	ProviderNameLte               *string             `json:"providerName_lte,omitempty"`
	ProviderNameGt                *string             `json:"providerName_gt,omitempty"`
	ProviderNameGte               *string             `json:"providerName_gte,omitempty"`
	ProviderNameContains          *string             `json:"providerName_contains,omitempty"`
	ProviderNameNotContains       *string             `json:"providerName_not_contains,omitempty"`
	ProviderNameStartsWith        *string             `json:"providerName_starts_with,omitempty"`
	ProviderNameNotStartsWith     *string             `json:"providerName_not_starts_with,omitempty"`
	ProviderNameEndsWith          *string             `json:"providerName_ends_with,omitempty"`
	ProviderNameNotEndsWith       *string             `json:"providerName_not_ends_with,omitempty"`
	ProviderWeb                   *string             `json:"providerWeb,omitempty"`
	ProviderWebNot                *string             `json:"providerWeb_not,omitempty"`
	ProviderWebIn                 []string            `json:"providerWeb_in,omitempty"`
	ProviderWebNotIn              []string            `json:"providerWeb_not_in,omitempty"`
	ProviderWebLt                 *string             `json:"providerWeb_lt,omitempty"`
	ProviderWebLte                *string             `json:"providerWeb_lte,omitempty"`
	ProviderWebGt                 *string             `json:"providerWeb_gt,omitempty"`
	ProviderWebGte                *string             `json:"providerWeb_gte,omitempty"`
	ProviderWebContains           *string             `json:"providerWeb_contains,omitempty"`
	ProviderWebNotContains        *string             `json:"providerWeb_not_contains,omitempty"`
	ProviderWebStartsWith         *string             `json:"providerWeb_starts_with,omitempty"`
	ProviderWebNotStartsWith      *string             `json:"providerWeb_not_starts_with,omitempty"`
	ProviderWebEndsWith           *string             `json:"providerWeb_ends_with,omitempty"`
	ProviderWebNotEndsWith        *string             `json:"providerWeb_not_ends_with,omitempty"`
	ContactPhone                  *string             `json:"contactPhone,omitempty"`
	ContactPhoneNot               *string             `json:"contactPhone_not,omitempty"`
	ContactPhoneIn                []string            `json:"contactPhone_in,omitempty"`
	ContactPhoneNotIn             []string            `json:"contactPhone_not_in,omitempty"`
	ContactPhoneLt                *string             `json:"contactPhone_lt,omitempty"`
	ContactPhoneLte               *string             `json:"contactPhone_lte,omitempty"`
	ContactPhoneGt                *string             `json:"contactPhone_gt,omitempty"`
	ContactPhoneGte               *string             `json:"contactPhone_gte,omitempty"`
	ContactPhoneContains          *string             `json:"contactPhone_contains,omitempty"`
	ContactPhoneNotContains       *string             `json:"contactPhone_not_contains,omitempty"`
	ContactPhoneStartsWith        *string             `json:"contactPhone_starts_with,omitempty"`
	ContactPhoneNotStartsWith     *string             `json:"contactPhone_not_starts_with,omitempty"`
	ContactPhoneEndsWith          *string             `json:"contactPhone_ends_with,omitempty"`
	ContactPhoneNotEndsWith       *string             `json:"contactPhone_not_ends_with,omitempty"`
	ContactEmail                  *string             `json:"contactEmail,omitempty"`
	ContactEmailNot               *string             `json:"contactEmail_not,omitempty"`
	ContactEmailIn                []string            `json:"contactEmail_in,omitempty"`
	ContactEmailNotIn             []string            `json:"contactEmail_not_in,omitempty"`
	ContactEmailLt                *string             `json:"contactEmail_lt,omitempty"`
	ContactEmailLte               *string             `json:"contactEmail_lte,omitempty"`
	ContactEmailGt                *string             `json:"contactEmail_gt,omitempty"`
	ContactEmailGte               *string             `json:"contactEmail_gte,omitempty"`
	ContactEmailContains          *string             `json:"contactEmail_contains,omitempty"`
	ContactEmailNotContains       *string             `json:"contactEmail_not_contains,omitempty"`
	ContactEmailStartsWith        *string             `json:"contactEmail_starts_with,omitempty"`
	ContactEmailNotStartsWith     *string             `json:"contactEmail_not_starts_with,omitempty"`
	ContactEmailEndsWith          *string             `json:"contactEmail_ends_with,omitempty"`
	ContactEmailNotEndsWith       *string             `json:"contactEmail_not_ends_with,omitempty"`
	AddressReference              *string             `json:"addressReference,omitempty"`
	AddressReferenceNot           *string             `json:"addressReference_not,omitempty"`
	AddressReferenceIn            []string            `json:"addressReference_in,omitempty"`
	AddressReferenceNotIn         []string            `json:"addressReference_not_in,omitempty"`
	AddressReferenceLt            *string             `json:"addressReference_lt,omitempty"`
	AddressReferenceLte           *string             `json:"addressReference_lte,omitempty"`
	AddressReferenceGt            *string             `json:"addressReference_gt,omitempty"`
	AddressReferenceGte           *string             `json:"addressReference_gte,omitempty"`
	AddressReferenceContains      *string             `json:"addressReference_contains,omitempty"`
	AddressReferenceNotContains   *string             `json:"addressReference_not_contains,omitempty"`
	AddressReferenceStartsWith    *string             `json:"addressReference_starts_with,omitempty"`
	AddressReferenceNotStartsWith *string             `json:"addressReference_not_starts_with,omitempty"`
	AddressReferenceEndsWith      *string             `json:"addressReference_ends_with,omitempty"`
	AddressReferenceNotEndsWith   *string             `json:"addressReference_not_ends_with,omitempty"`
	And                           []DetailsWhereInput `json:"AND,omitempty"`
	Or                            []DetailsWhereInput `json:"OR,omitempty"`
	Not                           []DetailsWhereInput `json:"NOT,omitempty"`
}

type OverviewCreateOneInput struct {
	Create *OverviewCreateInput `json:"create,omitempty"`
}

type PaymentEntryUpsertNestedInput struct {
	Update PaymentEntryUpdateDataInput `json:"update"`
	Create PaymentEntryCreateInput     `json:"create"`
}

type OverviewCreateInput struct {
	Name        string `json:"name"`
	Description string `json:"description"`
}

type PersonUpsertWithWhereUniqueNestedInput struct {
	Where  PersonWhereUniqueInput `json:"where"`
	Update PersonUpdateDataInput  `json:"update"`
	Create PersonCreateInput      `json:"create"`
}

type PersonCreateManyInput struct {
	Create  []PersonCreateInput      `json:"create,omitempty"`
	Connect []PersonWhereUniqueInput `json:"connect,omitempty"`
}

type TicketTypeSubscriptionWhereInput struct {
	MutationIn                 []MutationType                     `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                            `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                           `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                           `json:"updatedFields_contains_some,omitempty"`
	Node                       *TicketTypeWhereInput              `json:"node,omitempty"`
	And                        []TicketTypeSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []TicketTypeSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []TicketTypeSubscriptionWhereInput `json:"NOT,omitempty"`
}

type AttractionCreatetypesInput struct {
	Set []AttractionType `json:"set,omitempty"`
}

type PhoneChannelSubscriptionWhereInput struct {
	MutationIn                 []MutationType                       `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                              `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                             `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                             `json:"updatedFields_contains_some,omitempty"`
	Node                       *PhoneChannelWhereInput              `json:"node,omitempty"`
	And                        []PhoneChannelSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []PhoneChannelSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []PhoneChannelSubscriptionWhereInput `json:"NOT,omitempty"`
}

type AttractionCreatetagsInput struct {
	Set []string `json:"set,omitempty"`
}

type PersonWhereInput struct {
	ID                 *string                           `json:"id,omitempty"`
	IDNot              *string                           `json:"id_not,omitempty"`
	IDIn               []string                          `json:"id_in,omitempty"`
	IDNotIn            []string                          `json:"id_not_in,omitempty"`
	IDLt               *string                           `json:"id_lt,omitempty"`
	IDLte              *string                           `json:"id_lte,omitempty"`
	IDGt               *string                           `json:"id_gt,omitempty"`
	IDGte              *string                           `json:"id_gte,omitempty"`
	IDContains         *string                           `json:"id_contains,omitempty"`
	IDNotContains      *string                           `json:"id_not_contains,omitempty"`
	IDStartsWith       *string                           `json:"id_starts_with,omitempty"`
	IDNotStartsWith    *string                           `json:"id_not_starts_with,omitempty"`
	IDEndsWith         *string                           `json:"id_ends_with,omitempty"`
	IDNotEndsWith      *string                           `json:"id_not_ends_with,omitempty"`
	CreatedAt          *string                           `json:"createdAt,omitempty"`
	CreatedAtNot       *string                           `json:"createdAt_not,omitempty"`
	CreatedAtIn        []string                          `json:"createdAt_in,omitempty"`
	CreatedAtNotIn     []string                          `json:"createdAt_not_in,omitempty"`
	CreatedAtLt        *string                           `json:"createdAt_lt,omitempty"`
	CreatedAtLte       *string                           `json:"createdAt_lte,omitempty"`
	CreatedAtGt        *string                           `json:"createdAt_gt,omitempty"`
	CreatedAtGte       *string                           `json:"createdAt_gte,omitempty"`
	UpdatedAt          *string                           `json:"updatedAt,omitempty"`
	UpdatedAtNot       *string                           `json:"updatedAt_not,omitempty"`
	UpdatedAtIn        []string                          `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn     []string                          `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt        *string                           `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte       *string                           `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt        *string                           `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte       *string                           `json:"updatedAt_gte,omitempty"`
	MId                *string                           `json:"mID,omitempty"`
	MIdNot             *string                           `json:"mID_not,omitempty"`
	MIdIn              []string                          `json:"mID_in,omitempty"`
	MIdNotIn           []string                          `json:"mID_not_in,omitempty"`
	MIdLt              *string                           `json:"mID_lt,omitempty"`
	MIdLte             *string                           `json:"mID_lte,omitempty"`
	MIdGt              *string                           `json:"mID_gt,omitempty"`
	MIdGte             *string                           `json:"mID_gte,omitempty"`
	MIdContains        *string                           `json:"mID_contains,omitempty"`
	MIdNotContains     *string                           `json:"mID_not_contains,omitempty"`
	MIdStartsWith      *string                           `json:"mID_starts_with,omitempty"`
	MIdNotStartsWith   *string                           `json:"mID_not_starts_with,omitempty"`
	MIdEndsWith        *string                           `json:"mID_ends_with,omitempty"`
	MIdNotEndsWith     *string                           `json:"mID_not_ends_with,omitempty"`
	Name               *string                           `json:"name,omitempty"`
	NameNot            *string                           `json:"name_not,omitempty"`
	NameIn             []string                          `json:"name_in,omitempty"`
	NameNotIn          []string                          `json:"name_not_in,omitempty"`
	NameLt             *string                           `json:"name_lt,omitempty"`
	NameLte            *string                           `json:"name_lte,omitempty"`
	NameGt             *string                           `json:"name_gt,omitempty"`
	NameGte            *string                           `json:"name_gte,omitempty"`
	NameContains       *string                           `json:"name_contains,omitempty"`
	NameNotContains    *string                           `json:"name_not_contains,omitempty"`
	NameStartsWith     *string                           `json:"name_starts_with,omitempty"`
	NameNotStartsWith  *string                           `json:"name_not_starts_with,omitempty"`
	NameEndsWith       *string                           `json:"name_ends_with,omitempty"`
	NameNotEndsWith    *string                           `json:"name_not_ends_with,omitempty"`
	Photo              *string                           `json:"photo,omitempty"`
	PhotoNot           *string                           `json:"photo_not,omitempty"`
	PhotoIn            []string                          `json:"photo_in,omitempty"`
	PhotoNotIn         []string                          `json:"photo_not_in,omitempty"`
	PhotoLt            *string                           `json:"photo_lt,omitempty"`
	PhotoLte           *string                           `json:"photo_lte,omitempty"`
	PhotoGt            *string                           `json:"photo_gt,omitempty"`
	PhotoGte           *string                           `json:"photo_gte,omitempty"`
	PhotoContains      *string                           `json:"photo_contains,omitempty"`
	PhotoNotContains   *string                           `json:"photo_not_contains,omitempty"`
	PhotoStartsWith    *string                           `json:"photo_starts_with,omitempty"`
	PhotoNotStartsWith *string                           `json:"photo_not_starts_with,omitempty"`
	PhotoEndsWith      *string                           `json:"photo_ends_with,omitempty"`
	PhotoNotEndsWith   *string                           `json:"photo_not_ends_with,omitempty"`
	Birthday           *string                           `json:"birthday,omitempty"`
	BirthdayNot        *string                           `json:"birthday_not,omitempty"`
	BirthdayIn         []string                          `json:"birthday_in,omitempty"`
	BirthdayNotIn      []string                          `json:"birthday_not_in,omitempty"`
	BirthdayLt         *string                           `json:"birthday_lt,omitempty"`
	BirthdayLte        *string                           `json:"birthday_lte,omitempty"`
	BirthdayGt         *string                           `json:"birthday_gt,omitempty"`
	BirthdayGte        *string                           `json:"birthday_gte,omitempty"`
	From               *string                           `json:"from,omitempty"`
	FromNot            *string                           `json:"from_not,omitempty"`
	FromIn             []string                          `json:"from_in,omitempty"`
	FromNotIn          []string                          `json:"from_not_in,omitempty"`
	FromLt             *string                           `json:"from_lt,omitempty"`
	FromLte            *string                           `json:"from_lte,omitempty"`
	FromGt             *string                           `json:"from_gt,omitempty"`
	FromGte            *string                           `json:"from_gte,omitempty"`
	FromContains       *string                           `json:"from_contains,omitempty"`
	FromNotContains    *string                           `json:"from_not_contains,omitempty"`
	FromStartsWith     *string                           `json:"from_starts_with,omitempty"`
	FromNotStartsWith  *string                           `json:"from_not_starts_with,omitempty"`
	FromEndsWith       *string                           `json:"from_ends_with,omitempty"`
	FromNotEndsWith    *string                           `json:"from_not_ends_with,omitempty"`
	ChannelsPhoneEvery *PhoneChannelWhereInput           `json:"channelsPhone_every,omitempty"`
	ChannelsPhoneSome  *PhoneChannelWhereInput           `json:"channelsPhone_some,omitempty"`
	ChannelsPhoneNone  *PhoneChannelWhereInput           `json:"channelsPhone_none,omitempty"`
	ChannelsEmailEvery *EmailChannelWhereInput           `json:"channelsEmail_every,omitempty"`
	ChannelsEmailSome  *EmailChannelWhereInput           `json:"channelsEmail_some,omitempty"`
	ChannelsEmailNone  *EmailChannelWhereInput           `json:"channelsEmail_none,omitempty"`
	IDentification     *IDentificationDocumentWhereInput `json:"identification,omitempty"`
	CredentialsEvery   *CredentialWhereInput             `json:"credentials_every,omitempty"`
	CredentialsSome    *CredentialWhereInput             `json:"credentials_some,omitempty"`
	CredentialsNone    *CredentialWhereInput             `json:"credentials_none,omitempty"`
	And                []PersonWhereInput                `json:"AND,omitempty"`
	Or                 []PersonWhereInput                `json:"OR,omitempty"`
	Not                []PersonWhereInput                `json:"NOT,omitempty"`
}

type PersonReviewsCreateManyInput struct {
	Create  []PersonReviewsCreateInput      `json:"create,omitempty"`
	Connect []PersonReviewsWhereUniqueInput `json:"connect,omitempty"`
}

type PersonSubscriptionWhereInput struct {
	MutationIn                 []MutationType                 `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                        `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                       `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                       `json:"updatedFields_contains_some,omitempty"`
	Node                       *PersonWhereInput              `json:"node,omitempty"`
	And                        []PersonSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []PersonSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []PersonSubscriptionWhereInput `json:"NOT,omitempty"`
}

type PersonReviewsCreateInput struct {
	Person        PersonCreateOneInput          `json:"person"`
	Title         string                        `json:"title"`
	Description   *string                       `json:"description,omitempty"`
	AproveNumber  *int32                        `json:"aproveNumber,omitempty"`
	DeclineNumber *int32                        `json:"declineNumber,omitempty"`
	Comments      *PersonReviewsCreateManyInput `json:"comments,omitempty"`
}

type PartnerSubscriptionWhereInput struct {
	MutationIn                 []MutationType                  `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                         `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                        `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                        `json:"updatedFields_contains_some,omitempty"`
	Node                       *PartnerWhereInput              `json:"node,omitempty"`
	And                        []PartnerSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []PartnerSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []PartnerSubscriptionWhereInput `json:"NOT,omitempty"`
}

type DetailsCreateOneInput struct {
	Create *DetailsCreateInput `json:"create,omitempty"`
}

type OpeningHoursSubscriptionWhereInput struct {
	MutationIn                 []MutationType                       `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                              `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                             `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                             `json:"updatedFields_contains_some,omitempty"`
	Node                       *OpeningHoursWhereInput              `json:"node,omitempty"`
	And                        []OpeningHoursSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []OpeningHoursSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []OpeningHoursSubscriptionWhereInput `json:"NOT,omitempty"`
}

type DetailsCreateInput struct {
	ProviderName     string  `json:"providerName"`
	ProviderWeb      *string `json:"providerWeb,omitempty"`
	ContactPhone     *string `json:"contactPhone,omitempty"`
	ContactEmail     *string `json:"contactEmail,omitempty"`
	AddressReference *string `json:"addressReference,omitempty"`
}

type LocationSubscriptionWhereInput struct {
	MutationIn                 []MutationType                   `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                          `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                         `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                         `json:"updatedFields_contains_some,omitempty"`
	Node                       *LocationWhereInput              `json:"node,omitempty"`
	And                        []LocationSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []LocationSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []LocationSubscriptionWhereInput `json:"NOT,omitempty"`
}

type AttractionUpdateInput struct {
	Owner      *PartnerUpdateOneRequiredWithoutAttractionsInput `json:"owner,omitempty"`
	Overview   *OverviewUpdateOneRequiredInput                  `json:"overview,omitempty"`
	MaxUses    *int32                                           `json:"maxUses,omitempty"`
	Address    *string                                          `json:"address,omitempty"`
	Location   *LocationUpdateOneRequiredInput                  `json:"location,omitempty"`
	Popularity *float64                                         `json:"popularity,omitempty"`
	LikedBy    *PersonUpdateManyInput                           `json:"likedBy,omitempty"`
	Types      *AttractionUpdatetypesInput                      `json:"types,omitempty"`
	Tags       *AttractionUpdatetagsInput                       `json:"tags,omitempty"`
	Reviews    *PersonReviewsUpdateManyInput                    `json:"reviews,omitempty"`
	Details    *DetailsUpdateOneInput                           `json:"details,omitempty"`
}

type FeatureSubscriptionWhereInput struct {
	MutationIn                 []MutationType                  `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                         `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                        `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                        `json:"updatedFields_contains_some,omitempty"`
	Node                       *FeatureWhereInput              `json:"node,omitempty"`
	And                        []FeatureSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []FeatureSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []FeatureSubscriptionWhereInput `json:"NOT,omitempty"`
}

type PartnerUpdateOneRequiredWithoutAttractionsInput struct {
	Create  *PartnerCreateWithoutAttractionsInput     `json:"create,omitempty"`
	Update  *PartnerUpdateWithoutAttractionsDataInput `json:"update,omitempty"`
	Upsert  *PartnerUpsertWithoutAttractionsInput     `json:"upsert,omitempty"`
	Connect *PartnerWhereUniqueInput                  `json:"connect,omitempty"`
}

type EmailChannelSubscriptionWhereInput struct {
	MutationIn                 []MutationType                       `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                              `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                             `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                             `json:"updatedFields_contains_some,omitempty"`
	Node                       *EmailChannelWhereInput              `json:"node,omitempty"`
	And                        []EmailChannelSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []EmailChannelSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []EmailChannelSubscriptionWhereInput `json:"NOT,omitempty"`
}

type PartnerUpdateWithoutAttractionsDataInput struct {
	Person       *PersonUpdateOneRequiredInput       `json:"person,omitempty"`
	BrandName    *string                             `json:"brandName,omitempty"`
	SocialReason *string                             `json:"socialReason,omitempty"`
	Ruc          *string                             `json:"ruc,omitempty"`
	Address      *string                             `json:"address,omitempty"`
	Location     *LocationUpdateOneRequiredInput     `json:"location,omitempty"`
	Features     *FeatureUpdateManyInput             `json:"features,omitempty"`
	OpeningHours *OpeningHoursUpdateOneRequiredInput `json:"openingHours,omitempty"`
}

type CreditCardWhereInput struct {
	ID                      *string                 `json:"id,omitempty"`
	IDNot                   *string                 `json:"id_not,omitempty"`
	IDIn                    []string                `json:"id_in,omitempty"`
	IDNotIn                 []string                `json:"id_not_in,omitempty"`
	IDLt                    *string                 `json:"id_lt,omitempty"`
	IDLte                   *string                 `json:"id_lte,omitempty"`
	IDGt                    *string                 `json:"id_gt,omitempty"`
	IDGte                   *string                 `json:"id_gte,omitempty"`
	IDContains              *string                 `json:"id_contains,omitempty"`
	IDNotContains           *string                 `json:"id_not_contains,omitempty"`
	IDStartsWith            *string                 `json:"id_starts_with,omitempty"`
	IDNotStartsWith         *string                 `json:"id_not_starts_with,omitempty"`
	IDEndsWith              *string                 `json:"id_ends_with,omitempty"`
	IDNotEndsWith           *string                 `json:"id_not_ends_with,omitempty"`
	CreatedAt               *string                 `json:"createdAt,omitempty"`
	CreatedAtNot            *string                 `json:"createdAt_not,omitempty"`
	CreatedAtIn             []string                `json:"createdAt_in,omitempty"`
	CreatedAtNotIn          []string                `json:"createdAt_not_in,omitempty"`
	CreatedAtLt             *string                 `json:"createdAt_lt,omitempty"`
	CreatedAtLte            *string                 `json:"createdAt_lte,omitempty"`
	CreatedAtGt             *string                 `json:"createdAt_gt,omitempty"`
	CreatedAtGte            *string                 `json:"createdAt_gte,omitempty"`
	UpdatedAt               *string                 `json:"updatedAt,omitempty"`
	UpdatedAtNot            *string                 `json:"updatedAt_not,omitempty"`
	UpdatedAtIn             []string                `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn          []string                `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt             *string                 `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte            *string                 `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt             *string                 `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte            *string                 `json:"updatedAt_gte,omitempty"`
	Owner                   *TravelerWhereInput     `json:"owner,omitempty"`
	CardNumber              *string                 `json:"cardNumber,omitempty"`
	CardNumberNot           *string                 `json:"cardNumber_not,omitempty"`
	CardNumberIn            []string                `json:"cardNumber_in,omitempty"`
	CardNumberNotIn         []string                `json:"cardNumber_not_in,omitempty"`
	CardNumberLt            *string                 `json:"cardNumber_lt,omitempty"`
	CardNumberLte           *string                 `json:"cardNumber_lte,omitempty"`
	CardNumberGt            *string                 `json:"cardNumber_gt,omitempty"`
	CardNumberGte           *string                 `json:"cardNumber_gte,omitempty"`
	CardNumberContains      *string                 `json:"cardNumber_contains,omitempty"`
	CardNumberNotContains   *string                 `json:"cardNumber_not_contains,omitempty"`
	CardNumberStartsWith    *string                 `json:"cardNumber_starts_with,omitempty"`
	CardNumberNotStartsWith *string                 `json:"cardNumber_not_starts_with,omitempty"`
	CardNumberEndsWith      *string                 `json:"cardNumber_ends_with,omitempty"`
	CardNumberNotEndsWith   *string                 `json:"cardNumber_not_ends_with,omitempty"`
	CardToken               *string                 `json:"cardToken,omitempty"`
	CardTokenNot            *string                 `json:"cardToken_not,omitempty"`
	CardTokenIn             []string                `json:"cardToken_in,omitempty"`
	CardTokenNotIn          []string                `json:"cardToken_not_in,omitempty"`
	CardTokenLt             *string                 `json:"cardToken_lt,omitempty"`
	CardTokenLte            *string                 `json:"cardToken_lte,omitempty"`
	CardTokenGt             *string                 `json:"cardToken_gt,omitempty"`
	CardTokenGte            *string                 `json:"cardToken_gte,omitempty"`
	CardTokenContains       *string                 `json:"cardToken_contains,omitempty"`
	CardTokenNotContains    *string                 `json:"cardToken_not_contains,omitempty"`
	CardTokenStartsWith     *string                 `json:"cardToken_starts_with,omitempty"`
	CardTokenNotStartsWith  *string                 `json:"cardToken_not_starts_with,omitempty"`
	CardTokenEndsWith       *string                 `json:"cardToken_ends_with,omitempty"`
	CardTokenNotEndsWith    *string                 `json:"cardToken_not_ends_with,omitempty"`
	Type                    *CreditCardType         `json:"type,omitempty"`
	TypeNot                 *CreditCardType         `json:"type_not,omitempty"`
	TypeIn                  []CreditCardType        `json:"type_in,omitempty"`
	TypeNotIn               []CreditCardType        `json:"type_not_in,omitempty"`
	LastUsed                *string                 `json:"lastUsed,omitempty"`
	LastUsedNot             *string                 `json:"lastUsed_not,omitempty"`
	LastUsedIn              []string                `json:"lastUsed_in,omitempty"`
	LastUsedNotIn           []string                `json:"lastUsed_not_in,omitempty"`
	LastUsedLt              *string                 `json:"lastUsed_lt,omitempty"`
	LastUsedLte             *string                 `json:"lastUsed_lte,omitempty"`
	LastUsedGt              *string                 `json:"lastUsed_gt,omitempty"`
	LastUsedGte             *string                 `json:"lastUsed_gte,omitempty"`
	UsesEvery               *PaymentEntryWhereInput `json:"uses_every,omitempty"`
	UsesSome                *PaymentEntryWhereInput `json:"uses_some,omitempty"`
	UsesNone                *PaymentEntryWhereInput `json:"uses_none,omitempty"`
	And                     []CreditCardWhereInput  `json:"AND,omitempty"`
	Or                      []CreditCardWhereInput  `json:"OR,omitempty"`
	Not                     []CreditCardWhereInput  `json:"NOT,omitempty"`
}

type PersonUpdateOneRequiredInput struct {
	Create  *PersonCreateInput       `json:"create,omitempty"`
	Update  *PersonUpdateDataInput   `json:"update,omitempty"`
	Upsert  *PersonUpsertNestedInput `json:"upsert,omitempty"`
	Connect *PersonWhereUniqueInput  `json:"connect,omitempty"`
}

type TicketWhereInput struct {
	ID              *string                 `json:"id,omitempty"`
	IDNot           *string                 `json:"id_not,omitempty"`
	IDIn            []string                `json:"id_in,omitempty"`
	IDNotIn         []string                `json:"id_not_in,omitempty"`
	IDLt            *string                 `json:"id_lt,omitempty"`
	IDLte           *string                 `json:"id_lte,omitempty"`
	IDGt            *string                 `json:"id_gt,omitempty"`
	IDGte           *string                 `json:"id_gte,omitempty"`
	IDContains      *string                 `json:"id_contains,omitempty"`
	IDNotContains   *string                 `json:"id_not_contains,omitempty"`
	IDStartsWith    *string                 `json:"id_starts_with,omitempty"`
	IDNotStartsWith *string                 `json:"id_not_starts_with,omitempty"`
	IDEndsWith      *string                 `json:"id_ends_with,omitempty"`
	IDNotEndsWith   *string                 `json:"id_not_ends_with,omitempty"`
	CreatedAt       *string                 `json:"createdAt,omitempty"`
	CreatedAtNot    *string                 `json:"createdAt_not,omitempty"`
	CreatedAtIn     []string                `json:"createdAt_in,omitempty"`
	CreatedAtNotIn  []string                `json:"createdAt_not_in,omitempty"`
	CreatedAtLt     *string                 `json:"createdAt_lt,omitempty"`
	CreatedAtLte    *string                 `json:"createdAt_lte,omitempty"`
	CreatedAtGt     *string                 `json:"createdAt_gt,omitempty"`
	CreatedAtGte    *string                 `json:"createdAt_gte,omitempty"`
	UpdatedAt       *string                 `json:"updatedAt,omitempty"`
	UpdatedAtNot    *string                 `json:"updatedAt_not,omitempty"`
	UpdatedAtIn     []string                `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn  []string                `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt     *string                 `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte    *string                 `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt     *string                 `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte    *string                 `json:"updatedAt_gte,omitempty"`
	Type            *TicketTypeWhereInput   `json:"type,omitempty"`
	Owner           *PersonWhereInput       `json:"owner,omitempty"`
	Receive         *PaymentEntryWhereInput `json:"receive,omitempty"`
	ExpireAt        *string                 `json:"expireAt,omitempty"`
	ExpireAtNot     *string                 `json:"expireAt_not,omitempty"`
	ExpireAtIn      []string                `json:"expireAt_in,omitempty"`
	ExpireAtNotIn   []string                `json:"expireAt_not_in,omitempty"`
	ExpireAtLt      *string                 `json:"expireAt_lt,omitempty"`
	ExpireAtLte     *string                 `json:"expireAt_lte,omitempty"`
	ExpireAtGt      *string                 `json:"expireAt_gt,omitempty"`
	ExpireAtGte     *string                 `json:"expireAt_gte,omitempty"`
	VisitedEvery    *AttractionWhereInput   `json:"visited_every,omitempty"`
	VisitedSome     *AttractionWhereInput   `json:"visited_some,omitempty"`
	VisitedNone     *AttractionWhereInput   `json:"visited_none,omitempty"`
	And             []TicketWhereInput      `json:"AND,omitempty"`
	Or              []TicketWhereInput      `json:"OR,omitempty"`
	Not             []TicketWhereInput      `json:"NOT,omitempty"`
}

type PersonUpdateDataInput struct {
	MId            *string                                                    `json:"mID,omitempty"`
	Name           *string                                                    `json:"name,omitempty"`
	Photo          *string                                                    `json:"photo,omitempty"`
	Birthday       *string                                                    `json:"birthday,omitempty"`
	From           *string                                                    `json:"from,omitempty"`
	ChannelsPhone  *PhoneChannelUpdateManyInput                               `json:"channelsPhone,omitempty"`
	ChannelsEmail  *EmailChannelUpdateManyInput                               `json:"channelsEmail,omitempty"`
	IDentification *IDentificationDocumentUpdateOneRequiredWithoutPersonInput `json:"identification,omitempty"`
	Tags           *PersonUpdatetagsInput                                     `json:"tags,omitempty"`
	Credentials    *CredentialUpdateManyWithoutOwnerInput                     `json:"credentials,omitempty"`
}

type PaymentEntryWhereInput struct {
	ID                           *string                  `json:"id,omitempty"`
	IDNot                        *string                  `json:"id_not,omitempty"`
	IDIn                         []string                 `json:"id_in,omitempty"`
	IDNotIn                      []string                 `json:"id_not_in,omitempty"`
	IDLt                         *string                  `json:"id_lt,omitempty"`
	IDLte                        *string                  `json:"id_lte,omitempty"`
	IDGt                         *string                  `json:"id_gt,omitempty"`
	IDGte                        *string                  `json:"id_gte,omitempty"`
	IDContains                   *string                  `json:"id_contains,omitempty"`
	IDNotContains                *string                  `json:"id_not_contains,omitempty"`
	IDStartsWith                 *string                  `json:"id_starts_with,omitempty"`
	IDNotStartsWith              *string                  `json:"id_not_starts_with,omitempty"`
	IDEndsWith                   *string                  `json:"id_ends_with,omitempty"`
	IDNotEndsWith                *string                  `json:"id_not_ends_with,omitempty"`
	CreatedAt                    *string                  `json:"createdAt,omitempty"`
	CreatedAtNot                 *string                  `json:"createdAt_not,omitempty"`
	CreatedAtIn                  []string                 `json:"createdAt_in,omitempty"`
	CreatedAtNotIn               []string                 `json:"createdAt_not_in,omitempty"`
	CreatedAtLt                  *string                  `json:"createdAt_lt,omitempty"`
	CreatedAtLte                 *string                  `json:"createdAt_lte,omitempty"`
	CreatedAtGt                  *string                  `json:"createdAt_gt,omitempty"`
	CreatedAtGte                 *string                  `json:"createdAt_gte,omitempty"`
	UpdatedAt                    *string                  `json:"updatedAt,omitempty"`
	UpdatedAtNot                 *string                  `json:"updatedAt_not,omitempty"`
	UpdatedAtIn                  []string                 `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn               []string                 `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt                  *string                  `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte                 *string                  `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt                  *string                  `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte                 *string                  `json:"updatedAt_gte,omitempty"`
	ExternalId                   *string                  `json:"externalID,omitempty"`
	ExternalIdNot                *string                  `json:"externalID_not,omitempty"`
	ExternalIdIn                 []string                 `json:"externalID_in,omitempty"`
	ExternalIdNotIn              []string                 `json:"externalID_not_in,omitempty"`
	ExternalIdLt                 *string                  `json:"externalID_lt,omitempty"`
	ExternalIdLte                *string                  `json:"externalID_lte,omitempty"`
	ExternalIdGt                 *string                  `json:"externalID_gt,omitempty"`
	ExternalIdGte                *string                  `json:"externalID_gte,omitempty"`
	ExternalIdContains           *string                  `json:"externalID_contains,omitempty"`
	ExternalIdNotContains        *string                  `json:"externalID_not_contains,omitempty"`
	ExternalIdStartsWith         *string                  `json:"externalID_starts_with,omitempty"`
	ExternalIdNotStartsWith      *string                  `json:"externalID_not_starts_with,omitempty"`
	ExternalIdEndsWith           *string                  `json:"externalID_ends_with,omitempty"`
	ExternalIdNotEndsWith        *string                  `json:"externalID_not_ends_with,omitempty"`
	WithCard                     *CreditCardWhereInput    `json:"withCard,omitempty"`
	ProductId                    *string                  `json:"productID,omitempty"`
	ProductIdNot                 *string                  `json:"productID_not,omitempty"`
	ProductIdIn                  []string                 `json:"productID_in,omitempty"`
	ProductIdNotIn               []string                 `json:"productID_not_in,omitempty"`
	ProductIdLt                  *string                  `json:"productID_lt,omitempty"`
	ProductIdLte                 *string                  `json:"productID_lte,omitempty"`
	ProductIdGt                  *string                  `json:"productID_gt,omitempty"`
	ProductIdGte                 *string                  `json:"productID_gte,omitempty"`
	ProductIdContains            *string                  `json:"productID_contains,omitempty"`
	ProductIdNotContains         *string                  `json:"productID_not_contains,omitempty"`
	ProductIdStartsWith          *string                  `json:"productID_starts_with,omitempty"`
	ProductIdNotStartsWith       *string                  `json:"productID_not_starts_with,omitempty"`
	ProductIdEndsWith            *string                  `json:"productID_ends_with,omitempty"`
	ProductIdNotEndsWith         *string                  `json:"productID_not_ends_with,omitempty"`
	Product                      *string                  `json:"product,omitempty"`
	ProductNot                   *string                  `json:"product_not,omitempty"`
	ProductIn                    []string                 `json:"product_in,omitempty"`
	ProductNotIn                 []string                 `json:"product_not_in,omitempty"`
	ProductLt                    *string                  `json:"product_lt,omitempty"`
	ProductLte                   *string                  `json:"product_lte,omitempty"`
	ProductGt                    *string                  `json:"product_gt,omitempty"`
	ProductGte                   *string                  `json:"product_gte,omitempty"`
	ProductContains              *string                  `json:"product_contains,omitempty"`
	ProductNotContains           *string                  `json:"product_not_contains,omitempty"`
	ProductStartsWith            *string                  `json:"product_starts_with,omitempty"`
	ProductNotStartsWith         *string                  `json:"product_not_starts_with,omitempty"`
	ProductEndsWith              *string                  `json:"product_ends_with,omitempty"`
	ProductNotEndsWith           *string                  `json:"product_not_ends_with,omitempty"`
	GatewayResponse              *string                  `json:"gatewayResponse,omitempty"`
	GatewayResponseNot           *string                  `json:"gatewayResponse_not,omitempty"`
	GatewayResponseIn            []string                 `json:"gatewayResponse_in,omitempty"`
	GatewayResponseNotIn         []string                 `json:"gatewayResponse_not_in,omitempty"`
	GatewayResponseLt            *string                  `json:"gatewayResponse_lt,omitempty"`
	GatewayResponseLte           *string                  `json:"gatewayResponse_lte,omitempty"`
	GatewayResponseGt            *string                  `json:"gatewayResponse_gt,omitempty"`
	GatewayResponseGte           *string                  `json:"gatewayResponse_gte,omitempty"`
	GatewayResponseContains      *string                  `json:"gatewayResponse_contains,omitempty"`
	GatewayResponseNotContains   *string                  `json:"gatewayResponse_not_contains,omitempty"`
	GatewayResponseStartsWith    *string                  `json:"gatewayResponse_starts_with,omitempty"`
	GatewayResponseNotStartsWith *string                  `json:"gatewayResponse_not_starts_with,omitempty"`
	GatewayResponseEndsWith      *string                  `json:"gatewayResponse_ends_with,omitempty"`
	GatewayResponseNotEndsWith   *string                  `json:"gatewayResponse_not_ends_with,omitempty"`
	Amount                       *int32                   `json:"amount,omitempty"`
	AmountNot                    *int32                   `json:"amount_not,omitempty"`
	AmountIn                     []int32                  `json:"amount_in,omitempty"`
	AmountNotIn                  []int32                  `json:"amount_not_in,omitempty"`
	AmountLt                     *int32                   `json:"amount_lt,omitempty"`
	AmountLte                    *int32                   `json:"amount_lte,omitempty"`
	AmountGt                     *int32                   `json:"amount_gt,omitempty"`
	AmountGte                    *int32                   `json:"amount_gte,omitempty"`
	DiscountId                   *string                  `json:"discountID,omitempty"`
	DiscountIdNot                *string                  `json:"discountID_not,omitempty"`
	DiscountIdIn                 []string                 `json:"discountID_in,omitempty"`
	DiscountIdNotIn              []string                 `json:"discountID_not_in,omitempty"`
	DiscountIdLt                 *string                  `json:"discountID_lt,omitempty"`
	DiscountIdLte                *string                  `json:"discountID_lte,omitempty"`
	DiscountIdGt                 *string                  `json:"discountID_gt,omitempty"`
	DiscountIdGte                *string                  `json:"discountID_gte,omitempty"`
	DiscountIdContains           *string                  `json:"discountID_contains,omitempty"`
	DiscountIdNotContains        *string                  `json:"discountID_not_contains,omitempty"`
	DiscountIdStartsWith         *string                  `json:"discountID_starts_with,omitempty"`
	DiscountIdNotStartsWith      *string                  `json:"discountID_not_starts_with,omitempty"`
	DiscountIdEndsWith           *string                  `json:"discountID_ends_with,omitempty"`
	DiscountIdNotEndsWith        *string                  `json:"discountID_not_ends_with,omitempty"`
	Discount                     *int32                   `json:"discount,omitempty"`
	DiscountNot                  *int32                   `json:"discount_not,omitempty"`
	DiscountIn                   []int32                  `json:"discount_in,omitempty"`
	DiscountNotIn                []int32                  `json:"discount_not_in,omitempty"`
	DiscountLt                   *int32                   `json:"discount_lt,omitempty"`
	DiscountLte                  *int32                   `json:"discount_lte,omitempty"`
	DiscountGt                   *int32                   `json:"discount_gt,omitempty"`
	DiscountGte                  *int32                   `json:"discount_gte,omitempty"`
	And                          []PaymentEntryWhereInput `json:"AND,omitempty"`
	Or                           []PaymentEntryWhereInput `json:"OR,omitempty"`
	Not                          []PaymentEntryWhereInput `json:"NOT,omitempty"`
}

type PhoneChannelUpdateManyInput struct {
	Create     []PhoneChannelCreateInput                      `json:"create,omitempty"`
	Update     []PhoneChannelUpdateWithWhereUniqueNestedInput `json:"update,omitempty"`
	Upsert     []PhoneChannelUpsertWithWhereUniqueNestedInput `json:"upsert,omitempty"`
	Delete     []PhoneChannelWhereUniqueInput                 `json:"delete,omitempty"`
	Connect    []PhoneChannelWhereUniqueInput                 `json:"connect,omitempty"`
	Set        []PhoneChannelWhereUniqueInput                 `json:"set,omitempty"`
	Disconnect []PhoneChannelWhereUniqueInput                 `json:"disconnect,omitempty"`
	DeleteMany []PhoneChannelScalarWhereInput                 `json:"deleteMany,omitempty"`
	UpdateMany []PhoneChannelUpdateManyWithWhereNestedInput   `json:"updateMany,omitempty"`
}

type CreditCardSubscriptionWhereInput struct {
	MutationIn                 []MutationType                     `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                            `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                           `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                           `json:"updatedFields_contains_some,omitempty"`
	Node                       *CreditCardWhereInput              `json:"node,omitempty"`
	And                        []CreditCardSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []CreditCardSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []CreditCardSubscriptionWhereInput `json:"NOT,omitempty"`
}

type PhoneChannelUpdateWithWhereUniqueNestedInput struct {
	Where PhoneChannelWhereUniqueInput `json:"where"`
	Data  PhoneChannelUpdateDataInput  `json:"data"`
}

type AttractionSubscriptionWhereInput struct {
	MutationIn                 []MutationType                     `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                            `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                           `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                           `json:"updatedFields_contains_some,omitempty"`
	Node                       *AttractionWhereInput              `json:"node,omitempty"`
	And                        []AttractionSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []AttractionSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []AttractionSubscriptionWhereInput `json:"NOT,omitempty"`
}

type PhoneChannelUpdateDataInput struct {
	DisplayName *string `json:"displayName,omitempty"`
	Valid       *bool   `json:"valid,omitempty"`
	CountryCode *string `json:"countryCode,omitempty"`
	Number      *string `json:"number,omitempty"`
}

type CreditCardUpdateManyDataInput struct {
	CardNumber *string         `json:"cardNumber,omitempty"`
	CardToken  *string         `json:"cardToken,omitempty"`
	Type       *CreditCardType `json:"type,omitempty"`
	LastUsed   *string         `json:"lastUsed,omitempty"`
}

type PhoneChannelUpsertWithWhereUniqueNestedInput struct {
	Where  PhoneChannelWhereUniqueInput `json:"where"`
	Update PhoneChannelUpdateDataInput  `json:"update"`
	Create PhoneChannelCreateInput      `json:"create"`
}

type CreditCardUpdateManyWithWhereNestedInput struct {
	Where CreditCardScalarWhereInput    `json:"where"`
	Data  CreditCardUpdateManyDataInput `json:"data"`
}

type PhoneChannelScalarWhereInput struct {
	ID                       *string                        `json:"id,omitempty"`
	IDNot                    *string                        `json:"id_not,omitempty"`
	IDIn                     []string                       `json:"id_in,omitempty"`
	IDNotIn                  []string                       `json:"id_not_in,omitempty"`
	IDLt                     *string                        `json:"id_lt,omitempty"`
	IDLte                    *string                        `json:"id_lte,omitempty"`
	IDGt                     *string                        `json:"id_gt,omitempty"`
	IDGte                    *string                        `json:"id_gte,omitempty"`
	IDContains               *string                        `json:"id_contains,omitempty"`
	IDNotContains            *string                        `json:"id_not_contains,omitempty"`
	IDStartsWith             *string                        `json:"id_starts_with,omitempty"`
	IDNotStartsWith          *string                        `json:"id_not_starts_with,omitempty"`
	IDEndsWith               *string                        `json:"id_ends_with,omitempty"`
	IDNotEndsWith            *string                        `json:"id_not_ends_with,omitempty"`
	CreatedAt                *string                        `json:"createdAt,omitempty"`
	CreatedAtNot             *string                        `json:"createdAt_not,omitempty"`
	CreatedAtIn              []string                       `json:"createdAt_in,omitempty"`
	CreatedAtNotIn           []string                       `json:"createdAt_not_in,omitempty"`
	CreatedAtLt              *string                        `json:"createdAt_lt,omitempty"`
	CreatedAtLte             *string                        `json:"createdAt_lte,omitempty"`
	CreatedAtGt              *string                        `json:"createdAt_gt,omitempty"`
	CreatedAtGte             *string                        `json:"createdAt_gte,omitempty"`
	UpdatedAt                *string                        `json:"updatedAt,omitempty"`
	UpdatedAtNot             *string                        `json:"updatedAt_not,omitempty"`
	UpdatedAtIn              []string                       `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn           []string                       `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt              *string                        `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte             *string                        `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt              *string                        `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte             *string                        `json:"updatedAt_gte,omitempty"`
	DisplayName              *string                        `json:"displayName,omitempty"`
	DisplayNameNot           *string                        `json:"displayName_not,omitempty"`
	DisplayNameIn            []string                       `json:"displayName_in,omitempty"`
	DisplayNameNotIn         []string                       `json:"displayName_not_in,omitempty"`
	DisplayNameLt            *string                        `json:"displayName_lt,omitempty"`
	DisplayNameLte           *string                        `json:"displayName_lte,omitempty"`
	DisplayNameGt            *string                        `json:"displayName_gt,omitempty"`
	DisplayNameGte           *string                        `json:"displayName_gte,omitempty"`
	DisplayNameContains      *string                        `json:"displayName_contains,omitempty"`
	DisplayNameNotContains   *string                        `json:"displayName_not_contains,omitempty"`
	DisplayNameStartsWith    *string                        `json:"displayName_starts_with,omitempty"`
	DisplayNameNotStartsWith *string                        `json:"displayName_not_starts_with,omitempty"`
	DisplayNameEndsWith      *string                        `json:"displayName_ends_with,omitempty"`
	DisplayNameNotEndsWith   *string                        `json:"displayName_not_ends_with,omitempty"`
	Valid                    *bool                          `json:"valid,omitempty"`
	ValidNot                 *bool                          `json:"valid_not,omitempty"`
	CountryCode              *string                        `json:"countryCode,omitempty"`
	CountryCodeNot           *string                        `json:"countryCode_not,omitempty"`
	CountryCodeIn            []string                       `json:"countryCode_in,omitempty"`
	CountryCodeNotIn         []string                       `json:"countryCode_not_in,omitempty"`
	CountryCodeLt            *string                        `json:"countryCode_lt,omitempty"`
	CountryCodeLte           *string                        `json:"countryCode_lte,omitempty"`
	CountryCodeGt            *string                        `json:"countryCode_gt,omitempty"`
	CountryCodeGte           *string                        `json:"countryCode_gte,omitempty"`
	CountryCodeContains      *string                        `json:"countryCode_contains,omitempty"`
	CountryCodeNotContains   *string                        `json:"countryCode_not_contains,omitempty"`
	CountryCodeStartsWith    *string                        `json:"countryCode_starts_with,omitempty"`
	CountryCodeNotStartsWith *string                        `json:"countryCode_not_starts_with,omitempty"`
	CountryCodeEndsWith      *string                        `json:"countryCode_ends_with,omitempty"`
	CountryCodeNotEndsWith   *string                        `json:"countryCode_not_ends_with,omitempty"`
	Number                   *string                        `json:"number,omitempty"`
	NumberNot                *string                        `json:"number_not,omitempty"`
	NumberIn                 []string                       `json:"number_in,omitempty"`
	NumberNotIn              []string                       `json:"number_not_in,omitempty"`
	NumberLt                 *string                        `json:"number_lt,omitempty"`
	NumberLte                *string                        `json:"number_lte,omitempty"`
	NumberGt                 *string                        `json:"number_gt,omitempty"`
	NumberGte                *string                        `json:"number_gte,omitempty"`
	NumberContains           *string                        `json:"number_contains,omitempty"`
	NumberNotContains        *string                        `json:"number_not_contains,omitempty"`
	NumberStartsWith         *string                        `json:"number_starts_with,omitempty"`
	NumberNotStartsWith      *string                        `json:"number_not_starts_with,omitempty"`
	NumberEndsWith           *string                        `json:"number_ends_with,omitempty"`
	NumberNotEndsWith        *string                        `json:"number_not_ends_with,omitempty"`
	And                      []PhoneChannelScalarWhereInput `json:"AND,omitempty"`
	Or                       []PhoneChannelScalarWhereInput `json:"OR,omitempty"`
	Not                      []PhoneChannelScalarWhereInput `json:"NOT,omitempty"`
}

type CreditCardUpsertWithWhereUniqueWithoutOwnerInput struct {
	Where  CreditCardWhereUniqueInput            `json:"where"`
	Update CreditCardUpdateWithoutOwnerDataInput `json:"update"`
	Create CreditCardCreateWithoutOwnerInput     `json:"create"`
}

type PhoneChannelUpdateManyWithWhereNestedInput struct {
	Where PhoneChannelScalarWhereInput    `json:"where"`
	Data  PhoneChannelUpdateManyDataInput `json:"data"`
}

type CreditCardUpdateWithWhereUniqueWithoutOwnerInput struct {
	Where CreditCardWhereUniqueInput            `json:"where"`
	Data  CreditCardUpdateWithoutOwnerDataInput `json:"data"`
}

type PhoneChannelUpdateManyDataInput struct {
	DisplayName *string `json:"displayName,omitempty"`
	Valid       *bool   `json:"valid,omitempty"`
	CountryCode *string `json:"countryCode,omitempty"`
	Number      *string `json:"number,omitempty"`
}

type TravelerUpdateInput struct {
	Person   *PersonUpdateOneRequiredInput          `json:"person,omitempty"`
	Username *string                                `json:"username,omitempty"`
	Cards    *CreditCardUpdateManyWithoutOwnerInput `json:"cards,omitempty"`
	Tickets  *TicketUpdateManyInput                 `json:"tickets,omitempty"`
}

type EmailChannelUpdateManyInput struct {
	Create     []EmailChannelCreateInput                      `json:"create,omitempty"`
	Update     []EmailChannelUpdateWithWhereUniqueNestedInput `json:"update,omitempty"`
	Upsert     []EmailChannelUpsertWithWhereUniqueNestedInput `json:"upsert,omitempty"`
	Delete     []EmailChannelWhereUniqueInput                 `json:"delete,omitempty"`
	Connect    []EmailChannelWhereUniqueInput                 `json:"connect,omitempty"`
	Set        []EmailChannelWhereUniqueInput                 `json:"set,omitempty"`
	Disconnect []EmailChannelWhereUniqueInput                 `json:"disconnect,omitempty"`
	DeleteMany []EmailChannelScalarWhereInput                 `json:"deleteMany,omitempty"`
	UpdateMany []EmailChannelUpdateManyWithWhereNestedInput   `json:"updateMany,omitempty"`
}

type CreditCardCreateWithoutOwnerInput struct {
	CardNumber string                                      `json:"cardNumber"`
	CardToken  string                                      `json:"cardToken"`
	Type       *CreditCardType                             `json:"type,omitempty"`
	LastUsed   *string                                     `json:"lastUsed,omitempty"`
	Uses       *PaymentEntryCreateManyWithoutWithCardInput `json:"uses,omitempty"`
}

type EmailChannelUpdateWithWhereUniqueNestedInput struct {
	Where EmailChannelWhereUniqueInput `json:"where"`
	Data  EmailChannelUpdateDataInput  `json:"data"`
}

type TravelerCreateInput struct {
	Person   PersonCreateOneInput                   `json:"person"`
	Username string                                 `json:"username"`
	Cards    *CreditCardCreateManyWithoutOwnerInput `json:"cards,omitempty"`
	Tickets  *TicketCreateManyInput                 `json:"tickets,omitempty"`
}

type EmailChannelUpdateDataInput struct {
	DisplayName *string                        `json:"displayName,omitempty"`
	Valid       *bool                          `json:"valid,omitempty"`
	Value       *string                        `json:"value,omitempty"`
	Extras      *EmailChannelUpdateextrasInput `json:"extras,omitempty"`
}

type TicketTypeUpdateInput struct {
	CreatorId   *string                    `json:"creatorID,omitempty"`
	Attractions *AttractionUpdateManyInput `json:"attractions,omitempty"`
	Cost        *float64                   `json:"cost,omitempty"`
}

type EmailChannelUpdateextrasInput struct {
	Set []string `json:"set,omitempty"`
}

type IDentificationDocumentWhereUniqueInput struct {
	ID *string `json:"id,omitempty"`
}

type EmailChannelUpsertWithWhereUniqueNestedInput struct {
	Where  EmailChannelWhereUniqueInput `json:"where"`
	Update EmailChannelUpdateDataInput  `json:"update"`
	Create EmailChannelCreateInput      `json:"create"`
}

type PhoneChannelUpdateManyMutationInput struct {
	DisplayName *string `json:"displayName,omitempty"`
	Valid       *bool   `json:"valid,omitempty"`
	CountryCode *string `json:"countryCode,omitempty"`
	Number      *string `json:"number,omitempty"`
}

type EmailChannelScalarWhereInput struct {
	ID                       *string                        `json:"id,omitempty"`
	IDNot                    *string                        `json:"id_not,omitempty"`
	IDIn                     []string                       `json:"id_in,omitempty"`
	IDNotIn                  []string                       `json:"id_not_in,omitempty"`
	IDLt                     *string                        `json:"id_lt,omitempty"`
	IDLte                    *string                        `json:"id_lte,omitempty"`
	IDGt                     *string                        `json:"id_gt,omitempty"`
	IDGte                    *string                        `json:"id_gte,omitempty"`
	IDContains               *string                        `json:"id_contains,omitempty"`
	IDNotContains            *string                        `json:"id_not_contains,omitempty"`
	IDStartsWith             *string                        `json:"id_starts_with,omitempty"`
	IDNotStartsWith          *string                        `json:"id_not_starts_with,omitempty"`
	IDEndsWith               *string                        `json:"id_ends_with,omitempty"`
	IDNotEndsWith            *string                        `json:"id_not_ends_with,omitempty"`
	CreatedAt                *string                        `json:"createdAt,omitempty"`
	CreatedAtNot             *string                        `json:"createdAt_not,omitempty"`
	CreatedAtIn              []string                       `json:"createdAt_in,omitempty"`
	CreatedAtNotIn           []string                       `json:"createdAt_not_in,omitempty"`
	CreatedAtLt              *string                        `json:"createdAt_lt,omitempty"`
	CreatedAtLte             *string                        `json:"createdAt_lte,omitempty"`
	CreatedAtGt              *string                        `json:"createdAt_gt,omitempty"`
	CreatedAtGte             *string                        `json:"createdAt_gte,omitempty"`
	UpdatedAt                *string                        `json:"updatedAt,omitempty"`
	UpdatedAtNot             *string                        `json:"updatedAt_not,omitempty"`
	UpdatedAtIn              []string                       `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn           []string                       `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt              *string                        `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte             *string                        `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt              *string                        `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte             *string                        `json:"updatedAt_gte,omitempty"`
	DisplayName              *string                        `json:"displayName,omitempty"`
	DisplayNameNot           *string                        `json:"displayName_not,omitempty"`
	DisplayNameIn            []string                       `json:"displayName_in,omitempty"`
	DisplayNameNotIn         []string                       `json:"displayName_not_in,omitempty"`
	DisplayNameLt            *string                        `json:"displayName_lt,omitempty"`
	DisplayNameLte           *string                        `json:"displayName_lte,omitempty"`
	DisplayNameGt            *string                        `json:"displayName_gt,omitempty"`
	DisplayNameGte           *string                        `json:"displayName_gte,omitempty"`
	DisplayNameContains      *string                        `json:"displayName_contains,omitempty"`
	DisplayNameNotContains   *string                        `json:"displayName_not_contains,omitempty"`
	DisplayNameStartsWith    *string                        `json:"displayName_starts_with,omitempty"`
	DisplayNameNotStartsWith *string                        `json:"displayName_not_starts_with,omitempty"`
	DisplayNameEndsWith      *string                        `json:"displayName_ends_with,omitempty"`
	DisplayNameNotEndsWith   *string                        `json:"displayName_not_ends_with,omitempty"`
	Valid                    *bool                          `json:"valid,omitempty"`
	ValidNot                 *bool                          `json:"valid_not,omitempty"`
	Value                    *string                        `json:"value,omitempty"`
	ValueNot                 *string                        `json:"value_not,omitempty"`
	ValueIn                  []string                       `json:"value_in,omitempty"`
	ValueNotIn               []string                       `json:"value_not_in,omitempty"`
	ValueLt                  *string                        `json:"value_lt,omitempty"`
	ValueLte                 *string                        `json:"value_lte,omitempty"`
	ValueGt                  *string                        `json:"value_gt,omitempty"`
	ValueGte                 *string                        `json:"value_gte,omitempty"`
	ValueContains            *string                        `json:"value_contains,omitempty"`
	ValueNotContains         *string                        `json:"value_not_contains,omitempty"`
	ValueStartsWith          *string                        `json:"value_starts_with,omitempty"`
	ValueNotStartsWith       *string                        `json:"value_not_starts_with,omitempty"`
	ValueEndsWith            *string                        `json:"value_ends_with,omitempty"`
	ValueNotEndsWith         *string                        `json:"value_not_ends_with,omitempty"`
	And                      []EmailChannelScalarWhereInput `json:"AND,omitempty"`
	Or                       []EmailChannelScalarWhereInput `json:"OR,omitempty"`
	Not                      []EmailChannelScalarWhereInput `json:"NOT,omitempty"`
}

type PersonReviewsUpdateManyMutationInput struct {
	Title         *string `json:"title,omitempty"`
	Description   *string `json:"description,omitempty"`
	AproveNumber  *int32  `json:"aproveNumber,omitempty"`
	DeclineNumber *int32  `json:"declineNumber,omitempty"`
}

type EmailChannelUpdateManyWithWhereNestedInput struct {
	Where EmailChannelScalarWhereInput    `json:"where"`
	Data  EmailChannelUpdateManyDataInput `json:"data"`
}

type PersonUpdateManyMutationInput struct {
	MId      *string                `json:"mID,omitempty"`
	Name     *string                `json:"name,omitempty"`
	Photo    *string                `json:"photo,omitempty"`
	Birthday *string                `json:"birthday,omitempty"`
	From     *string                `json:"from,omitempty"`
	Tags     *PersonUpdatetagsInput `json:"tags,omitempty"`
}

type EmailChannelUpdateManyDataInput struct {
	DisplayName *string                        `json:"displayName,omitempty"`
	Valid       *bool                          `json:"valid,omitempty"`
	Value       *string                        `json:"value,omitempty"`
	Extras      *EmailChannelUpdateextrasInput `json:"extras,omitempty"`
}

type PaymentEntryUpdateManyMutationInput struct {
	ExternalId      *string `json:"externalID,omitempty"`
	ProductId       *string `json:"productID,omitempty"`
	Product         *string `json:"product,omitempty"`
	GatewayResponse *string `json:"gatewayResponse,omitempty"`
	Amount          *int32  `json:"amount,omitempty"`
	DiscountId      *string `json:"discountID,omitempty"`
	Discount        *int32  `json:"discount,omitempty"`
}

type IDentificationDocumentUpdateOneRequiredWithoutPersonInput struct {
	Create  *IDentificationDocumentCreateWithoutPersonInput     `json:"create,omitempty"`
	Update  *IDentificationDocumentUpdateWithoutPersonDataInput `json:"update,omitempty"`
	Upsert  *IDentificationDocumentUpsertWithoutPersonInput     `json:"upsert,omitempty"`
	Connect *IDentificationDocumentWhereUniqueInput             `json:"connect,omitempty"`
}

type PaymentEntryUpdateInput struct {
	ExternalId      *string                                      `json:"externalID,omitempty"`
	WithCard        *CreditCardUpdateOneRequiredWithoutUsesInput `json:"withCard,omitempty"`
	ProductId       *string                                      `json:"productID,omitempty"`
	Product         *string                                      `json:"product,omitempty"`
	GatewayResponse *string                                      `json:"gatewayResponse,omitempty"`
	Amount          *int32                                       `json:"amount,omitempty"`
	DiscountId      *string                                      `json:"discountID,omitempty"`
	Discount        *int32                                       `json:"discount,omitempty"`
}

type IDentificationDocumentUpdateWithoutPersonDataInput struct {
	Type      *IDentificationType `json:"type,omitempty"`
	Value     *string             `json:"value,omitempty"`
	Validated *bool               `json:"validated,omitempty"`
}

type AttractionUpsertWithWhereUniqueWithoutOwnerInput struct {
	Where  AttractionWhereUniqueInput            `json:"where"`
	Update AttractionUpdateWithoutOwnerDataInput `json:"update"`
	Create AttractionCreateWithoutOwnerInput     `json:"create"`
}

type IDentificationDocumentUpsertWithoutPersonInput struct {
	Update IDentificationDocumentUpdateWithoutPersonDataInput `json:"update"`
	Create IDentificationDocumentCreateWithoutPersonInput     `json:"create"`
}

type AttractionUpdateWithWhereUniqueWithoutOwnerInput struct {
	Where AttractionWhereUniqueInput            `json:"where"`
	Data  AttractionUpdateWithoutOwnerDataInput `json:"data"`
}

type PersonUpdatetagsInput struct {
	Set []string `json:"set,omitempty"`
}

type PartnerUpdateInput struct {
	Person       *PersonUpdateOneRequiredInput          `json:"person,omitempty"`
	Attractions  *AttractionUpdateManyWithoutOwnerInput `json:"attractions,omitempty"`
	BrandName    *string                                `json:"brandName,omitempty"`
	SocialReason *string                                `json:"socialReason,omitempty"`
	Ruc          *string                                `json:"ruc,omitempty"`
	Address      *string                                `json:"address,omitempty"`
	Location     *LocationUpdateOneRequiredInput        `json:"location,omitempty"`
	Features     *FeatureUpdateManyInput                `json:"features,omitempty"`
	OpeningHours *OpeningHoursUpdateOneRequiredInput    `json:"openingHours,omitempty"`
}

type CredentialUpdateManyWithoutOwnerInput struct {
	Create     []CredentialCreateWithoutOwnerInput                `json:"create,omitempty"`
	Delete     []CredentialWhereUniqueInput                       `json:"delete,omitempty"`
	Connect    []CredentialWhereUniqueInput                       `json:"connect,omitempty"`
	Set        []CredentialWhereUniqueInput                       `json:"set,omitempty"`
	Disconnect []CredentialWhereUniqueInput                       `json:"disconnect,omitempty"`
	Update     []CredentialUpdateWithWhereUniqueWithoutOwnerInput `json:"update,omitempty"`
	Upsert     []CredentialUpsertWithWhereUniqueWithoutOwnerInput `json:"upsert,omitempty"`
	DeleteMany []CredentialScalarWhereInput                       `json:"deleteMany,omitempty"`
	UpdateMany []CredentialUpdateManyWithWhereNestedInput         `json:"updateMany,omitempty"`
}

type AttractionCreateWithoutOwnerInput struct {
	Overview   OverviewCreateOneInput        `json:"overview"`
	MaxUses    *int32                        `json:"maxUses,omitempty"`
	Address    string                        `json:"address"`
	Location   LocationCreateOneInput        `json:"location"`
	Popularity *float64                      `json:"popularity,omitempty"`
	LikedBy    *PersonCreateManyInput        `json:"likedBy,omitempty"`
	Types      *AttractionCreatetypesInput   `json:"types,omitempty"`
	Tags       *AttractionCreatetagsInput    `json:"tags,omitempty"`
	Reviews    *PersonReviewsCreateManyInput `json:"reviews,omitempty"`
	Details    *DetailsCreateOneInput        `json:"details,omitempty"`
}

type CredentialUpdateWithWhereUniqueWithoutOwnerInput struct {
	Where CredentialWhereUniqueInput            `json:"where"`
	Data  CredentialUpdateWithoutOwnerDataInput `json:"data"`
}

type PartnerCreateInput struct {
	Person       PersonCreateOneInput                   `json:"person"`
	Attractions  *AttractionCreateManyWithoutOwnerInput `json:"attractions,omitempty"`
	BrandName    string                                 `json:"brandName"`
	SocialReason string                                 `json:"socialReason"`
	Ruc          string                                 `json:"ruc"`
	Address      string                                 `json:"address"`
	Location     LocationCreateOneInput                 `json:"location"`
	Features     *FeatureCreateManyInput                `json:"features,omitempty"`
	OpeningHours OpeningHoursCreateOneInput             `json:"openingHours"`
}

type CredentialUpdateWithoutOwnerDataInput struct {
	DisplayName    *string         `json:"displayName,omitempty"`
	IsMain         *bool           `json:"isMain,omitempty"`
	Type           *CredentialType `json:"type,omitempty"`
	Validated      *bool           `json:"validated,omitempty"`
	ValidationId   *string         `json:"validationID,omitempty"`
	Value          *string         `json:"value,omitempty"`
	RawPassword    *string         `json:"rawPassword,omitempty"`
	HashedPassword *string         `json:"hashedPassword,omitempty"`
}

type PaymentEntryWhereUniqueInput struct {
	ID *string `json:"id,omitempty"`
}

type CredentialUpsertWithWhereUniqueWithoutOwnerInput struct {
	Where  CredentialWhereUniqueInput            `json:"where"`
	Update CredentialUpdateWithoutOwnerDataInput `json:"update"`
	Create CredentialCreateWithoutOwnerInput     `json:"create"`
}

type LocationUpdateManyMutationInput struct {
	Longitude   *float64 `json:"longitude,omitempty"`
	Latitude    *float64 `json:"latitude,omitempty"`
	Description *string  `json:"description,omitempty"`
}

type CredentialScalarWhereInput struct {
	ID                          *string                      `json:"id,omitempty"`
	IDNot                       *string                      `json:"id_not,omitempty"`
	IDIn                        []string                     `json:"id_in,omitempty"`
	IDNotIn                     []string                     `json:"id_not_in,omitempty"`
	IDLt                        *string                      `json:"id_lt,omitempty"`
	IDLte                       *string                      `json:"id_lte,omitempty"`
	IDGt                        *string                      `json:"id_gt,omitempty"`
	IDGte                       *string                      `json:"id_gte,omitempty"`
	IDContains                  *string                      `json:"id_contains,omitempty"`
	IDNotContains               *string                      `json:"id_not_contains,omitempty"`
	IDStartsWith                *string                      `json:"id_starts_with,omitempty"`
	IDNotStartsWith             *string                      `json:"id_not_starts_with,omitempty"`
	IDEndsWith                  *string                      `json:"id_ends_with,omitempty"`
	IDNotEndsWith               *string                      `json:"id_not_ends_with,omitempty"`
	CreatedAt                   *string                      `json:"createdAt,omitempty"`
	CreatedAtNot                *string                      `json:"createdAt_not,omitempty"`
	CreatedAtIn                 []string                     `json:"createdAt_in,omitempty"`
	CreatedAtNotIn              []string                     `json:"createdAt_not_in,omitempty"`
	CreatedAtLt                 *string                      `json:"createdAt_lt,omitempty"`
	CreatedAtLte                *string                      `json:"createdAt_lte,omitempty"`
	CreatedAtGt                 *string                      `json:"createdAt_gt,omitempty"`
	CreatedAtGte                *string                      `json:"createdAt_gte,omitempty"`
	UpdatedAt                   *string                      `json:"updatedAt,omitempty"`
	UpdatedAtNot                *string                      `json:"updatedAt_not,omitempty"`
	UpdatedAtIn                 []string                     `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn              []string                     `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt                 *string                      `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte                *string                      `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt                 *string                      `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte                *string                      `json:"updatedAt_gte,omitempty"`
	DisplayName                 *string                      `json:"displayName,omitempty"`
	DisplayNameNot              *string                      `json:"displayName_not,omitempty"`
	DisplayNameIn               []string                     `json:"displayName_in,omitempty"`
	DisplayNameNotIn            []string                     `json:"displayName_not_in,omitempty"`
	DisplayNameLt               *string                      `json:"displayName_lt,omitempty"`
	DisplayNameLte              *string                      `json:"displayName_lte,omitempty"`
	DisplayNameGt               *string                      `json:"displayName_gt,omitempty"`
	DisplayNameGte              *string                      `json:"displayName_gte,omitempty"`
	DisplayNameContains         *string                      `json:"displayName_contains,omitempty"`
	DisplayNameNotContains      *string                      `json:"displayName_not_contains,omitempty"`
	DisplayNameStartsWith       *string                      `json:"displayName_starts_with,omitempty"`
	DisplayNameNotStartsWith    *string                      `json:"displayName_not_starts_with,omitempty"`
	DisplayNameEndsWith         *string                      `json:"displayName_ends_with,omitempty"`
	DisplayNameNotEndsWith      *string                      `json:"displayName_not_ends_with,omitempty"`
	IsMain                      *bool                        `json:"isMain,omitempty"`
	IsMainNot                   *bool                        `json:"isMain_not,omitempty"`
	Type                        *CredentialType              `json:"type,omitempty"`
	TypeNot                     *CredentialType              `json:"type_not,omitempty"`
	TypeIn                      []CredentialType             `json:"type_in,omitempty"`
	TypeNotIn                   []CredentialType             `json:"type_not_in,omitempty"`
	Validated                   *bool                        `json:"validated,omitempty"`
	ValidatedNot                *bool                        `json:"validated_not,omitempty"`
	ValidationId                *string                      `json:"validationID,omitempty"`
	ValidationIdNot             *string                      `json:"validationID_not,omitempty"`
	ValidationIdIn              []string                     `json:"validationID_in,omitempty"`
	ValidationIdNotIn           []string                     `json:"validationID_not_in,omitempty"`
	ValidationIdLt              *string                      `json:"validationID_lt,omitempty"`
	ValidationIdLte             *string                      `json:"validationID_lte,omitempty"`
	ValidationIdGt              *string                      `json:"validationID_gt,omitempty"`
	ValidationIdGte             *string                      `json:"validationID_gte,omitempty"`
	ValidationIdContains        *string                      `json:"validationID_contains,omitempty"`
	ValidationIdNotContains     *string                      `json:"validationID_not_contains,omitempty"`
	ValidationIdStartsWith      *string                      `json:"validationID_starts_with,omitempty"`
	ValidationIdNotStartsWith   *string                      `json:"validationID_not_starts_with,omitempty"`
	ValidationIdEndsWith        *string                      `json:"validationID_ends_with,omitempty"`
	ValidationIdNotEndsWith     *string                      `json:"validationID_not_ends_with,omitempty"`
	Value                       *string                      `json:"value,omitempty"`
	ValueNot                    *string                      `json:"value_not,omitempty"`
	ValueIn                     []string                     `json:"value_in,omitempty"`
	ValueNotIn                  []string                     `json:"value_not_in,omitempty"`
	ValueLt                     *string                      `json:"value_lt,omitempty"`
	ValueLte                    *string                      `json:"value_lte,omitempty"`
	ValueGt                     *string                      `json:"value_gt,omitempty"`
	ValueGte                    *string                      `json:"value_gte,omitempty"`
	ValueContains               *string                      `json:"value_contains,omitempty"`
	ValueNotContains            *string                      `json:"value_not_contains,omitempty"`
	ValueStartsWith             *string                      `json:"value_starts_with,omitempty"`
	ValueNotStartsWith          *string                      `json:"value_not_starts_with,omitempty"`
	ValueEndsWith               *string                      `json:"value_ends_with,omitempty"`
	ValueNotEndsWith            *string                      `json:"value_not_ends_with,omitempty"`
	RawPassword                 *string                      `json:"rawPassword,omitempty"`
	RawPasswordNot              *string                      `json:"rawPassword_not,omitempty"`
	RawPasswordIn               []string                     `json:"rawPassword_in,omitempty"`
	RawPasswordNotIn            []string                     `json:"rawPassword_not_in,omitempty"`
	RawPasswordLt               *string                      `json:"rawPassword_lt,omitempty"`
	RawPasswordLte              *string                      `json:"rawPassword_lte,omitempty"`
	RawPasswordGt               *string                      `json:"rawPassword_gt,omitempty"`
	RawPasswordGte              *string                      `json:"rawPassword_gte,omitempty"`
	RawPasswordContains         *string                      `json:"rawPassword_contains,omitempty"`
	RawPasswordNotContains      *string                      `json:"rawPassword_not_contains,omitempty"`
	RawPasswordStartsWith       *string                      `json:"rawPassword_starts_with,omitempty"`
	RawPasswordNotStartsWith    *string                      `json:"rawPassword_not_starts_with,omitempty"`
	RawPasswordEndsWith         *string                      `json:"rawPassword_ends_with,omitempty"`
	RawPasswordNotEndsWith      *string                      `json:"rawPassword_not_ends_with,omitempty"`
	HashedPassword              *string                      `json:"hashedPassword,omitempty"`
	HashedPasswordNot           *string                      `json:"hashedPassword_not,omitempty"`
	HashedPasswordIn            []string                     `json:"hashedPassword_in,omitempty"`
	HashedPasswordNotIn         []string                     `json:"hashedPassword_not_in,omitempty"`
	HashedPasswordLt            *string                      `json:"hashedPassword_lt,omitempty"`
	HashedPasswordLte           *string                      `json:"hashedPassword_lte,omitempty"`
	HashedPasswordGt            *string                      `json:"hashedPassword_gt,omitempty"`
	HashedPasswordGte           *string                      `json:"hashedPassword_gte,omitempty"`
	HashedPasswordContains      *string                      `json:"hashedPassword_contains,omitempty"`
	HashedPasswordNotContains   *string                      `json:"hashedPassword_not_contains,omitempty"`
	HashedPasswordStartsWith    *string                      `json:"hashedPassword_starts_with,omitempty"`
	HashedPasswordNotStartsWith *string                      `json:"hashedPassword_not_starts_with,omitempty"`
	HashedPasswordEndsWith      *string                      `json:"hashedPassword_ends_with,omitempty"`
	HashedPasswordNotEndsWith   *string                      `json:"hashedPassword_not_ends_with,omitempty"`
	And                         []CredentialScalarWhereInput `json:"AND,omitempty"`
	Or                          []CredentialScalarWhereInput `json:"OR,omitempty"`
	Not                         []CredentialScalarWhereInput `json:"NOT,omitempty"`
}

type PersonWhereUniqueInput struct {
	ID *string `json:"id,omitempty"`
}

type CredentialUpdateManyWithWhereNestedInput struct {
	Where CredentialScalarWhereInput    `json:"where"`
	Data  CredentialUpdateManyDataInput `json:"data"`
}

type PersonUpdateWithoutIdentificationDataInput struct {
	MId           *string                                `json:"mID,omitempty"`
	Name          *string                                `json:"name,omitempty"`
	Photo         *string                                `json:"photo,omitempty"`
	Birthday      *string                                `json:"birthday,omitempty"`
	From          *string                                `json:"from,omitempty"`
	ChannelsPhone *PhoneChannelUpdateManyInput           `json:"channelsPhone,omitempty"`
	ChannelsEmail *EmailChannelUpdateManyInput           `json:"channelsEmail,omitempty"`
	Tags          *PersonUpdatetagsInput                 `json:"tags,omitempty"`
	Credentials   *CredentialUpdateManyWithoutOwnerInput `json:"credentials,omitempty"`
}

type CredentialUpdateManyDataInput struct {
	DisplayName    *string         `json:"displayName,omitempty"`
	IsMain         *bool           `json:"isMain,omitempty"`
	Type           *CredentialType `json:"type,omitempty"`
	Validated      *bool           `json:"validated,omitempty"`
	ValidationId   *string         `json:"validationID,omitempty"`
	Value          *string         `json:"value,omitempty"`
	RawPassword    *string         `json:"rawPassword,omitempty"`
	HashedPassword *string         `json:"hashedPassword,omitempty"`
}

type PersonReviewsWhereUniqueInput struct {
	ID *string `json:"id,omitempty"`
}

type PersonUpsertNestedInput struct {
	Update PersonUpdateDataInput `json:"update"`
	Create PersonCreateInput     `json:"create"`
}

type PersonCreateWithoutIdentificationInput struct {
	MId           *string                                `json:"mID,omitempty"`
	Name          string                                 `json:"name"`
	Photo         *string                                `json:"photo,omitempty"`
	Birthday      string                                 `json:"birthday"`
	From          *string                                `json:"from,omitempty"`
	ChannelsPhone *PhoneChannelCreateManyInput           `json:"channelsPhone,omitempty"`
	ChannelsEmail *EmailChannelCreateManyInput           `json:"channelsEmail,omitempty"`
	Tags          *PersonCreatetagsInput                 `json:"tags,omitempty"`
	Credentials   *CredentialCreateManyWithoutOwnerInput `json:"credentials,omitempty"`
}

type TicketUpdateManyDataInput struct {
	ExpireAt *string `json:"expireAt,omitempty"`
}

type PhoneChannelWhereUniqueInput struct {
	ID *string `json:"id,omitempty"`
}

type LocationUpdateDataInput struct {
	Longitude   *float64 `json:"longitude,omitempty"`
	Latitude    *float64 `json:"latitude,omitempty"`
	Description *string  `json:"description,omitempty"`
}

type FeatureUpdateManyMutationInput struct {
	Name  *string `json:"name,omitempty"`
	Image *string `json:"image,omitempty"`
}

type LocationUpsertNestedInput struct {
	Update LocationUpdateDataInput `json:"update"`
	Create LocationCreateInput     `json:"create"`
}

type TicketWhereUniqueInput struct {
	ID *string `json:"id,omitempty"`
}

type FeatureUpdateManyInput struct {
	Create     []FeatureCreateInput                    `json:"create,omitempty"`
	DeleteMany []FeatureScalarWhereInput               `json:"deleteMany,omitempty"`
	UpdateMany []FeatureUpdateManyWithWhereNestedInput `json:"updateMany,omitempty"`
}

type DetailsUpdateManyMutationInput struct {
	ProviderName     *string `json:"providerName,omitempty"`
	ProviderWeb      *string `json:"providerWeb,omitempty"`
	ContactPhone     *string `json:"contactPhone,omitempty"`
	ContactEmail     *string `json:"contactEmail,omitempty"`
	AddressReference *string `json:"addressReference,omitempty"`
}

type FeatureScalarWhereInput struct {
	Name               *string                   `json:"name,omitempty"`
	NameNot            *string                   `json:"name_not,omitempty"`
	NameIn             []string                  `json:"name_in,omitempty"`
	NameNotIn          []string                  `json:"name_not_in,omitempty"`
	NameLt             *string                   `json:"name_lt,omitempty"`
	NameLte            *string                   `json:"name_lte,omitempty"`
	NameGt             *string                   `json:"name_gt,omitempty"`
	NameGte            *string                   `json:"name_gte,omitempty"`
	NameContains       *string                   `json:"name_contains,omitempty"`
	NameNotContains    *string                   `json:"name_not_contains,omitempty"`
	NameStartsWith     *string                   `json:"name_starts_with,omitempty"`
	NameNotStartsWith  *string                   `json:"name_not_starts_with,omitempty"`
	NameEndsWith       *string                   `json:"name_ends_with,omitempty"`
	NameNotEndsWith    *string                   `json:"name_not_ends_with,omitempty"`
	Image              *string                   `json:"image,omitempty"`
	ImageNot           *string                   `json:"image_not,omitempty"`
	ImageIn            []string                  `json:"image_in,omitempty"`
	ImageNotIn         []string                  `json:"image_not_in,omitempty"`
	ImageLt            *string                   `json:"image_lt,omitempty"`
	ImageLte           *string                   `json:"image_lte,omitempty"`
	ImageGt            *string                   `json:"image_gt,omitempty"`
	ImageGte           *string                   `json:"image_gte,omitempty"`
	ImageContains      *string                   `json:"image_contains,omitempty"`
	ImageNotContains   *string                   `json:"image_not_contains,omitempty"`
	ImageStartsWith    *string                   `json:"image_starts_with,omitempty"`
	ImageNotStartsWith *string                   `json:"image_not_starts_with,omitempty"`
	ImageEndsWith      *string                   `json:"image_ends_with,omitempty"`
	ImageNotEndsWith   *string                   `json:"image_not_ends_with,omitempty"`
	And                []FeatureScalarWhereInput `json:"AND,omitempty"`
	Or                 []FeatureScalarWhereInput `json:"OR,omitempty"`
	Not                []FeatureScalarWhereInput `json:"NOT,omitempty"`
}

type TicketTypeWhereUniqueInput struct {
	ID *string `json:"id,omitempty"`
}

type FeatureUpdateManyWithWhereNestedInput struct {
	Where FeatureScalarWhereInput    `json:"where"`
	Data  FeatureUpdateManyDataInput `json:"data"`
}

type PaymentEntryUpdateManyWithWhereNestedInput struct {
	Where PaymentEntryScalarWhereInput    `json:"where"`
	Data  PaymentEntryUpdateManyDataInput `json:"data"`
}

type FeatureUpdateManyDataInput struct {
	Name  *string `json:"name,omitempty"`
	Image *string `json:"image,omitempty"`
}

type PaymentEntryUpsertWithWhereUniqueWithoutWithCardInput struct {
	Where  PaymentEntryWhereUniqueInput               `json:"where"`
	Update PaymentEntryUpdateWithoutWithCardDataInput `json:"update"`
	Create PaymentEntryCreateWithoutWithCardInput     `json:"create"`
}

type OpeningHoursUpdateOneRequiredInput struct {
	Create *OpeningHoursCreateInput       `json:"create,omitempty"`
	Update *OpeningHoursUpdateDataInput   `json:"update,omitempty"`
	Upsert *OpeningHoursUpsertNestedInput `json:"upsert,omitempty"`
}

type PaymentEntryUpdateWithoutWithCardDataInput struct {
	ExternalId      *string `json:"externalID,omitempty"`
	ProductId       *string `json:"productID,omitempty"`
	Product         *string `json:"product,omitempty"`
	GatewayResponse *string `json:"gatewayResponse,omitempty"`
	Amount          *int32  `json:"amount,omitempty"`
	DiscountId      *string `json:"discountID,omitempty"`
	Discount        *int32  `json:"discount,omitempty"`
}

type OpeningHoursUpdateDataInput struct {
	From *string `json:"from,omitempty"`
	To   *string `json:"to,omitempty"`
}

type PaymentEntryUpdateManyWithoutWithCardInput struct {
	Create     []PaymentEntryCreateWithoutWithCardInput                `json:"create,omitempty"`
	Delete     []PaymentEntryWhereUniqueInput                          `json:"delete,omitempty"`
	Connect    []PaymentEntryWhereUniqueInput                          `json:"connect,omitempty"`
	Set        []PaymentEntryWhereUniqueInput                          `json:"set,omitempty"`
	Disconnect []PaymentEntryWhereUniqueInput                          `json:"disconnect,omitempty"`
	Update     []PaymentEntryUpdateWithWhereUniqueWithoutWithCardInput `json:"update,omitempty"`
	Upsert     []PaymentEntryUpsertWithWhereUniqueWithoutWithCardInput `json:"upsert,omitempty"`
	DeleteMany []PaymentEntryScalarWhereInput                          `json:"deleteMany,omitempty"`
	UpdateMany []PaymentEntryUpdateManyWithWhereNestedInput            `json:"updateMany,omitempty"`
}

type OpeningHoursUpsertNestedInput struct {
	Update OpeningHoursUpdateDataInput `json:"update"`
	Create OpeningHoursCreateInput     `json:"create"`
}

type PartnerCreateOneWithoutAttractionsInput struct {
	Create  *PartnerCreateWithoutAttractionsInput `json:"create,omitempty"`
	Connect *PartnerWhereUniqueInput              `json:"connect,omitempty"`
}

type PartnerUpsertWithoutAttractionsInput struct {
	Update PartnerUpdateWithoutAttractionsDataInput `json:"update"`
	Create PartnerCreateWithoutAttractionsInput     `json:"create"`
}

type PersonCreateOneInput struct {
	Create  *PersonCreateInput      `json:"create,omitempty"`
	Connect *PersonWhereUniqueInput `json:"connect,omitempty"`
}

type OverviewUpdateOneRequiredInput struct {
	Create *OverviewCreateInput       `json:"create,omitempty"`
	Update *OverviewUpdateDataInput   `json:"update,omitempty"`
	Upsert *OverviewUpsertNestedInput `json:"upsert,omitempty"`
}

type PhoneChannelCreateManyInput struct {
	Create  []PhoneChannelCreateInput      `json:"create,omitempty"`
	Connect []PhoneChannelWhereUniqueInput `json:"connect,omitempty"`
}

type TicketUpdateManyWithWhereNestedInput struct {
	Where TicketScalarWhereInput    `json:"where"`
	Data  TicketUpdateManyDataInput `json:"data"`
}

type EmailChannelCreateManyInput struct {
	Create  []EmailChannelCreateInput      `json:"create,omitempty"`
	Connect []EmailChannelWhereUniqueInput `json:"connect,omitempty"`
}

type OpeningHoursWhereInput struct {
	From      *string                  `json:"from,omitempty"`
	FromNot   *string                  `json:"from_not,omitempty"`
	FromIn    []string                 `json:"from_in,omitempty"`
	FromNotIn []string                 `json:"from_not_in,omitempty"`
	FromLt    *string                  `json:"from_lt,omitempty"`
	FromLte   *string                  `json:"from_lte,omitempty"`
	FromGt    *string                  `json:"from_gt,omitempty"`
	FromGte   *string                  `json:"from_gte,omitempty"`
	To        *string                  `json:"to,omitempty"`
	ToNot     *string                  `json:"to_not,omitempty"`
	ToIn      []string                 `json:"to_in,omitempty"`
	ToNotIn   []string                 `json:"to_not_in,omitempty"`
	ToLt      *string                  `json:"to_lt,omitempty"`
	ToLte     *string                  `json:"to_lte,omitempty"`
	ToGt      *string                  `json:"to_gt,omitempty"`
	ToGte     *string                  `json:"to_gte,omitempty"`
	And       []OpeningHoursWhereInput `json:"AND,omitempty"`
	Or        []OpeningHoursWhereInput `json:"OR,omitempty"`
	Not       []OpeningHoursWhereInput `json:"NOT,omitempty"`
}

type EmailChannelCreateextrasInput struct {
	Set []string `json:"set,omitempty"`
}

type PersonReviewsWhereInput struct {
	ID                       *string                   `json:"id,omitempty"`
	IDNot                    *string                   `json:"id_not,omitempty"`
	IDIn                     []string                  `json:"id_in,omitempty"`
	IDNotIn                  []string                  `json:"id_not_in,omitempty"`
	IDLt                     *string                   `json:"id_lt,omitempty"`
	IDLte                    *string                   `json:"id_lte,omitempty"`
	IDGt                     *string                   `json:"id_gt,omitempty"`
	IDGte                    *string                   `json:"id_gte,omitempty"`
	IDContains               *string                   `json:"id_contains,omitempty"`
	IDNotContains            *string                   `json:"id_not_contains,omitempty"`
	IDStartsWith             *string                   `json:"id_starts_with,omitempty"`
	IDNotStartsWith          *string                   `json:"id_not_starts_with,omitempty"`
	IDEndsWith               *string                   `json:"id_ends_with,omitempty"`
	IDNotEndsWith            *string                   `json:"id_not_ends_with,omitempty"`
	CreatedAt                *string                   `json:"createdAt,omitempty"`
	CreatedAtNot             *string                   `json:"createdAt_not,omitempty"`
	CreatedAtIn              []string                  `json:"createdAt_in,omitempty"`
	CreatedAtNotIn           []string                  `json:"createdAt_not_in,omitempty"`
	CreatedAtLt              *string                   `json:"createdAt_lt,omitempty"`
	CreatedAtLte             *string                   `json:"createdAt_lte,omitempty"`
	CreatedAtGt              *string                   `json:"createdAt_gt,omitempty"`
	CreatedAtGte             *string                   `json:"createdAt_gte,omitempty"`
	UpdatedAt                *string                   `json:"updatedAt,omitempty"`
	UpdatedAtNot             *string                   `json:"updatedAt_not,omitempty"`
	UpdatedAtIn              []string                  `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn           []string                  `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt              *string                   `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte             *string                   `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt              *string                   `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte             *string                   `json:"updatedAt_gte,omitempty"`
	Person                   *PersonWhereInput         `json:"person,omitempty"`
	Title                    *string                   `json:"title,omitempty"`
	TitleNot                 *string                   `json:"title_not,omitempty"`
	TitleIn                  []string                  `json:"title_in,omitempty"`
	TitleNotIn               []string                  `json:"title_not_in,omitempty"`
	TitleLt                  *string                   `json:"title_lt,omitempty"`
	TitleLte                 *string                   `json:"title_lte,omitempty"`
	TitleGt                  *string                   `json:"title_gt,omitempty"`
	TitleGte                 *string                   `json:"title_gte,omitempty"`
	TitleContains            *string                   `json:"title_contains,omitempty"`
	TitleNotContains         *string                   `json:"title_not_contains,omitempty"`
	TitleStartsWith          *string                   `json:"title_starts_with,omitempty"`
	TitleNotStartsWith       *string                   `json:"title_not_starts_with,omitempty"`
	TitleEndsWith            *string                   `json:"title_ends_with,omitempty"`
	TitleNotEndsWith         *string                   `json:"title_not_ends_with,omitempty"`
	Description              *string                   `json:"description,omitempty"`
	DescriptionNot           *string                   `json:"description_not,omitempty"`
	DescriptionIn            []string                  `json:"description_in,omitempty"`
	DescriptionNotIn         []string                  `json:"description_not_in,omitempty"`
	DescriptionLt            *string                   `json:"description_lt,omitempty"`
	DescriptionLte           *string                   `json:"description_lte,omitempty"`
	DescriptionGt            *string                   `json:"description_gt,omitempty"`
	DescriptionGte           *string                   `json:"description_gte,omitempty"`
	DescriptionContains      *string                   `json:"description_contains,omitempty"`
	DescriptionNotContains   *string                   `json:"description_not_contains,omitempty"`
	DescriptionStartsWith    *string                   `json:"description_starts_with,omitempty"`
	DescriptionNotStartsWith *string                   `json:"description_not_starts_with,omitempty"`
	DescriptionEndsWith      *string                   `json:"description_ends_with,omitempty"`
	DescriptionNotEndsWith   *string                   `json:"description_not_ends_with,omitempty"`
	AproveNumber             *int32                    `json:"aproveNumber,omitempty"`
	AproveNumberNot          *int32                    `json:"aproveNumber_not,omitempty"`
	AproveNumberIn           []int32                   `json:"aproveNumber_in,omitempty"`
	AproveNumberNotIn        []int32                   `json:"aproveNumber_not_in,omitempty"`
	AproveNumberLt           *int32                    `json:"aproveNumber_lt,omitempty"`
	AproveNumberLte          *int32                    `json:"aproveNumber_lte,omitempty"`
	AproveNumberGt           *int32                    `json:"aproveNumber_gt,omitempty"`
	AproveNumberGte          *int32                    `json:"aproveNumber_gte,omitempty"`
	DeclineNumber            *int32                    `json:"declineNumber,omitempty"`
	DeclineNumberNot         *int32                    `json:"declineNumber_not,omitempty"`
	DeclineNumberIn          []int32                   `json:"declineNumber_in,omitempty"`
	DeclineNumberNotIn       []int32                   `json:"declineNumber_not_in,omitempty"`
	DeclineNumberLt          *int32                    `json:"declineNumber_lt,omitempty"`
	DeclineNumberLte         *int32                    `json:"declineNumber_lte,omitempty"`
	DeclineNumberGt          *int32                    `json:"declineNumber_gt,omitempty"`
	DeclineNumberGte         *int32                    `json:"declineNumber_gte,omitempty"`
	CommentsEvery            *PersonReviewsWhereInput  `json:"comments_every,omitempty"`
	CommentsSome             *PersonReviewsWhereInput  `json:"comments_some,omitempty"`
	CommentsNone             *PersonReviewsWhereInput  `json:"comments_none,omitempty"`
	And                      []PersonReviewsWhereInput `json:"AND,omitempty"`
	Or                       []PersonReviewsWhereInput `json:"OR,omitempty"`
	Not                      []PersonReviewsWhereInput `json:"NOT,omitempty"`
}

type IDentificationDocumentCreateWithoutPersonInput struct {
	Type      IDentificationType `json:"type"`
	Value     string             `json:"value"`
	Validated *bool              `json:"validated,omitempty"`
}

type PartnerWhereInput struct {
	ID                        *string                 `json:"id,omitempty"`
	IDNot                     *string                 `json:"id_not,omitempty"`
	IDIn                      []string                `json:"id_in,omitempty"`
	IDNotIn                   []string                `json:"id_not_in,omitempty"`
	IDLt                      *string                 `json:"id_lt,omitempty"`
	IDLte                     *string                 `json:"id_lte,omitempty"`
	IDGt                      *string                 `json:"id_gt,omitempty"`
	IDGte                     *string                 `json:"id_gte,omitempty"`
	IDContains                *string                 `json:"id_contains,omitempty"`
	IDNotContains             *string                 `json:"id_not_contains,omitempty"`
	IDStartsWith              *string                 `json:"id_starts_with,omitempty"`
	IDNotStartsWith           *string                 `json:"id_not_starts_with,omitempty"`
	IDEndsWith                *string                 `json:"id_ends_with,omitempty"`
	IDNotEndsWith             *string                 `json:"id_not_ends_with,omitempty"`
	CreatedAt                 *string                 `json:"createdAt,omitempty"`
	CreatedAtNot              *string                 `json:"createdAt_not,omitempty"`
	CreatedAtIn               []string                `json:"createdAt_in,omitempty"`
	CreatedAtNotIn            []string                `json:"createdAt_not_in,omitempty"`
	CreatedAtLt               *string                 `json:"createdAt_lt,omitempty"`
	CreatedAtLte              *string                 `json:"createdAt_lte,omitempty"`
	CreatedAtGt               *string                 `json:"createdAt_gt,omitempty"`
	CreatedAtGte              *string                 `json:"createdAt_gte,omitempty"`
	UpdatedAt                 *string                 `json:"updatedAt,omitempty"`
	UpdatedAtNot              *string                 `json:"updatedAt_not,omitempty"`
	UpdatedAtIn               []string                `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn            []string                `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt               *string                 `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte              *string                 `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt               *string                 `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte              *string                 `json:"updatedAt_gte,omitempty"`
	Person                    *PersonWhereInput       `json:"person,omitempty"`
	AttractionsEvery          *AttractionWhereInput   `json:"attractions_every,omitempty"`
	AttractionsSome           *AttractionWhereInput   `json:"attractions_some,omitempty"`
	AttractionsNone           *AttractionWhereInput   `json:"attractions_none,omitempty"`
	BrandName                 *string                 `json:"brandName,omitempty"`
	BrandNameNot              *string                 `json:"brandName_not,omitempty"`
	BrandNameIn               []string                `json:"brandName_in,omitempty"`
	BrandNameNotIn            []string                `json:"brandName_not_in,omitempty"`
	BrandNameLt               *string                 `json:"brandName_lt,omitempty"`
	BrandNameLte              *string                 `json:"brandName_lte,omitempty"`
	BrandNameGt               *string                 `json:"brandName_gt,omitempty"`
	BrandNameGte              *string                 `json:"brandName_gte,omitempty"`
	BrandNameContains         *string                 `json:"brandName_contains,omitempty"`
	BrandNameNotContains      *string                 `json:"brandName_not_contains,omitempty"`
	BrandNameStartsWith       *string                 `json:"brandName_starts_with,omitempty"`
	BrandNameNotStartsWith    *string                 `json:"brandName_not_starts_with,omitempty"`
	BrandNameEndsWith         *string                 `json:"brandName_ends_with,omitempty"`
	BrandNameNotEndsWith      *string                 `json:"brandName_not_ends_with,omitempty"`
	SocialReason              *string                 `json:"socialReason,omitempty"`
	SocialReasonNot           *string                 `json:"socialReason_not,omitempty"`
	SocialReasonIn            []string                `json:"socialReason_in,omitempty"`
	SocialReasonNotIn         []string                `json:"socialReason_not_in,omitempty"`
	SocialReasonLt            *string                 `json:"socialReason_lt,omitempty"`
	SocialReasonLte           *string                 `json:"socialReason_lte,omitempty"`
	SocialReasonGt            *string                 `json:"socialReason_gt,omitempty"`
	SocialReasonGte           *string                 `json:"socialReason_gte,omitempty"`
	SocialReasonContains      *string                 `json:"socialReason_contains,omitempty"`
	SocialReasonNotContains   *string                 `json:"socialReason_not_contains,omitempty"`
	SocialReasonStartsWith    *string                 `json:"socialReason_starts_with,omitempty"`
	SocialReasonNotStartsWith *string                 `json:"socialReason_not_starts_with,omitempty"`
	SocialReasonEndsWith      *string                 `json:"socialReason_ends_with,omitempty"`
	SocialReasonNotEndsWith   *string                 `json:"socialReason_not_ends_with,omitempty"`
	Ruc                       *string                 `json:"ruc,omitempty"`
	RucNot                    *string                 `json:"ruc_not,omitempty"`
	RucIn                     []string                `json:"ruc_in,omitempty"`
	RucNotIn                  []string                `json:"ruc_not_in,omitempty"`
	RucLt                     *string                 `json:"ruc_lt,omitempty"`
	RucLte                    *string                 `json:"ruc_lte,omitempty"`
	RucGt                     *string                 `json:"ruc_gt,omitempty"`
	RucGte                    *string                 `json:"ruc_gte,omitempty"`
	RucContains               *string                 `json:"ruc_contains,omitempty"`
	RucNotContains            *string                 `json:"ruc_not_contains,omitempty"`
	RucStartsWith             *string                 `json:"ruc_starts_with,omitempty"`
	RucNotStartsWith          *string                 `json:"ruc_not_starts_with,omitempty"`
	RucEndsWith               *string                 `json:"ruc_ends_with,omitempty"`
	RucNotEndsWith            *string                 `json:"ruc_not_ends_with,omitempty"`
	Address                   *string                 `json:"address,omitempty"`
	AddressNot                *string                 `json:"address_not,omitempty"`
	AddressIn                 []string                `json:"address_in,omitempty"`
	AddressNotIn              []string                `json:"address_not_in,omitempty"`
	AddressLt                 *string                 `json:"address_lt,omitempty"`
	AddressLte                *string                 `json:"address_lte,omitempty"`
	AddressGt                 *string                 `json:"address_gt,omitempty"`
	AddressGte                *string                 `json:"address_gte,omitempty"`
	AddressContains           *string                 `json:"address_contains,omitempty"`
	AddressNotContains        *string                 `json:"address_not_contains,omitempty"`
	AddressStartsWith         *string                 `json:"address_starts_with,omitempty"`
	AddressNotStartsWith      *string                 `json:"address_not_starts_with,omitempty"`
	AddressEndsWith           *string                 `json:"address_ends_with,omitempty"`
	AddressNotEndsWith        *string                 `json:"address_not_ends_with,omitempty"`
	Location                  *LocationWhereInput     `json:"location,omitempty"`
	FeaturesEvery             *FeatureWhereInput      `json:"features_every,omitempty"`
	FeaturesSome              *FeatureWhereInput      `json:"features_some,omitempty"`
	FeaturesNone              *FeatureWhereInput      `json:"features_none,omitempty"`
	OpeningHours              *OpeningHoursWhereInput `json:"openingHours,omitempty"`
	And                       []PartnerWhereInput     `json:"AND,omitempty"`
	Or                        []PartnerWhereInput     `json:"OR,omitempty"`
	Not                       []PartnerWhereInput     `json:"NOT,omitempty"`
}

type CredentialCreateManyWithoutOwnerInput struct {
	Create  []CredentialCreateWithoutOwnerInput `json:"create,omitempty"`
	Connect []CredentialWhereUniqueInput        `json:"connect,omitempty"`
}

type AttractionWhereInput struct {
	ID                   *string                  `json:"id,omitempty"`
	IDNot                *string                  `json:"id_not,omitempty"`
	IDIn                 []string                 `json:"id_in,omitempty"`
	IDNotIn              []string                 `json:"id_not_in,omitempty"`
	IDLt                 *string                  `json:"id_lt,omitempty"`
	IDLte                *string                  `json:"id_lte,omitempty"`
	IDGt                 *string                  `json:"id_gt,omitempty"`
	IDGte                *string                  `json:"id_gte,omitempty"`
	IDContains           *string                  `json:"id_contains,omitempty"`
	IDNotContains        *string                  `json:"id_not_contains,omitempty"`
	IDStartsWith         *string                  `json:"id_starts_with,omitempty"`
	IDNotStartsWith      *string                  `json:"id_not_starts_with,omitempty"`
	IDEndsWith           *string                  `json:"id_ends_with,omitempty"`
	IDNotEndsWith        *string                  `json:"id_not_ends_with,omitempty"`
	CreatedAt            *string                  `json:"createdAt,omitempty"`
	CreatedAtNot         *string                  `json:"createdAt_not,omitempty"`
	CreatedAtIn          []string                 `json:"createdAt_in,omitempty"`
	CreatedAtNotIn       []string                 `json:"createdAt_not_in,omitempty"`
	CreatedAtLt          *string                  `json:"createdAt_lt,omitempty"`
	CreatedAtLte         *string                  `json:"createdAt_lte,omitempty"`
	CreatedAtGt          *string                  `json:"createdAt_gt,omitempty"`
	CreatedAtGte         *string                  `json:"createdAt_gte,omitempty"`
	UpdatedAt            *string                  `json:"updatedAt,omitempty"`
	UpdatedAtNot         *string                  `json:"updatedAt_not,omitempty"`
	UpdatedAtIn          []string                 `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn       []string                 `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt          *string                  `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte         *string                  `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt          *string                  `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte         *string                  `json:"updatedAt_gte,omitempty"`
	Owner                *PartnerWhereInput       `json:"owner,omitempty"`
	Overview             *OverviewWhereInput      `json:"overview,omitempty"`
	MaxUses              *int32                   `json:"maxUses,omitempty"`
	MaxUsesNot           *int32                   `json:"maxUses_not,omitempty"`
	MaxUsesIn            []int32                  `json:"maxUses_in,omitempty"`
	MaxUsesNotIn         []int32                  `json:"maxUses_not_in,omitempty"`
	MaxUsesLt            *int32                   `json:"maxUses_lt,omitempty"`
	MaxUsesLte           *int32                   `json:"maxUses_lte,omitempty"`
	MaxUsesGt            *int32                   `json:"maxUses_gt,omitempty"`
	MaxUsesGte           *int32                   `json:"maxUses_gte,omitempty"`
	Address              *string                  `json:"address,omitempty"`
	AddressNot           *string                  `json:"address_not,omitempty"`
	AddressIn            []string                 `json:"address_in,omitempty"`
	AddressNotIn         []string                 `json:"address_not_in,omitempty"`
	AddressLt            *string                  `json:"address_lt,omitempty"`
	AddressLte           *string                  `json:"address_lte,omitempty"`
	AddressGt            *string                  `json:"address_gt,omitempty"`
	AddressGte           *string                  `json:"address_gte,omitempty"`
	AddressContains      *string                  `json:"address_contains,omitempty"`
	AddressNotContains   *string                  `json:"address_not_contains,omitempty"`
	AddressStartsWith    *string                  `json:"address_starts_with,omitempty"`
	AddressNotStartsWith *string                  `json:"address_not_starts_with,omitempty"`
	AddressEndsWith      *string                  `json:"address_ends_with,omitempty"`
	AddressNotEndsWith   *string                  `json:"address_not_ends_with,omitempty"`
	Location             *LocationWhereInput      `json:"location,omitempty"`
	Popularity           *float64                 `json:"popularity,omitempty"`
	PopularityNot        *float64                 `json:"popularity_not,omitempty"`
	PopularityIn         []float64                `json:"popularity_in,omitempty"`
	PopularityNotIn      []float64                `json:"popularity_not_in,omitempty"`
	PopularityLt         *float64                 `json:"popularity_lt,omitempty"`
	PopularityLte        *float64                 `json:"popularity_lte,omitempty"`
	PopularityGt         *float64                 `json:"popularity_gt,omitempty"`
	PopularityGte        *float64                 `json:"popularity_gte,omitempty"`
	LikedByEvery         *PersonWhereInput        `json:"likedBy_every,omitempty"`
	LikedBySome          *PersonWhereInput        `json:"likedBy_some,omitempty"`
	LikedByNone          *PersonWhereInput        `json:"likedBy_none,omitempty"`
	ReviewsEvery         *PersonReviewsWhereInput `json:"reviews_every,omitempty"`
	ReviewsSome          *PersonReviewsWhereInput `json:"reviews_some,omitempty"`
	ReviewsNone          *PersonReviewsWhereInput `json:"reviews_none,omitempty"`
	Details              *DetailsWhereInput       `json:"details,omitempty"`
	And                  []AttractionWhereInput   `json:"AND,omitempty"`
	Or                   []AttractionWhereInput   `json:"OR,omitempty"`
	Not                  []AttractionWhereInput   `json:"NOT,omitempty"`
}

type LocationCreateOneInput struct {
	Create *LocationCreateInput `json:"create,omitempty"`
}

type PersonScalarWhereInput struct {
	ID                 *string                  `json:"id,omitempty"`
	IDNot              *string                  `json:"id_not,omitempty"`
	IDIn               []string                 `json:"id_in,omitempty"`
	IDNotIn            []string                 `json:"id_not_in,omitempty"`
	IDLt               *string                  `json:"id_lt,omitempty"`
	IDLte              *string                  `json:"id_lte,omitempty"`
	IDGt               *string                  `json:"id_gt,omitempty"`
	IDGte              *string                  `json:"id_gte,omitempty"`
	IDContains         *string                  `json:"id_contains,omitempty"`
	IDNotContains      *string                  `json:"id_not_contains,omitempty"`
	IDStartsWith       *string                  `json:"id_starts_with,omitempty"`
	IDNotStartsWith    *string                  `json:"id_not_starts_with,omitempty"`
	IDEndsWith         *string                  `json:"id_ends_with,omitempty"`
	IDNotEndsWith      *string                  `json:"id_not_ends_with,omitempty"`
	CreatedAt          *string                  `json:"createdAt,omitempty"`
	CreatedAtNot       *string                  `json:"createdAt_not,omitempty"`
	CreatedAtIn        []string                 `json:"createdAt_in,omitempty"`
	CreatedAtNotIn     []string                 `json:"createdAt_not_in,omitempty"`
	CreatedAtLt        *string                  `json:"createdAt_lt,omitempty"`
	CreatedAtLte       *string                  `json:"createdAt_lte,omitempty"`
	CreatedAtGt        *string                  `json:"createdAt_gt,omitempty"`
	CreatedAtGte       *string                  `json:"createdAt_gte,omitempty"`
	UpdatedAt          *string                  `json:"updatedAt,omitempty"`
	UpdatedAtNot       *string                  `json:"updatedAt_not,omitempty"`
	UpdatedAtIn        []string                 `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn     []string                 `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt        *string                  `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte       *string                  `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt        *string                  `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte       *string                  `json:"updatedAt_gte,omitempty"`
	MId                *string                  `json:"mID,omitempty"`
	MIdNot             *string                  `json:"mID_not,omitempty"`
	MIdIn              []string                 `json:"mID_in,omitempty"`
	MIdNotIn           []string                 `json:"mID_not_in,omitempty"`
	MIdLt              *string                  `json:"mID_lt,omitempty"`
	MIdLte             *string                  `json:"mID_lte,omitempty"`
	MIdGt              *string                  `json:"mID_gt,omitempty"`
	MIdGte             *string                  `json:"mID_gte,omitempty"`
	MIdContains        *string                  `json:"mID_contains,omitempty"`
	MIdNotContains     *string                  `json:"mID_not_contains,omitempty"`
	MIdStartsWith      *string                  `json:"mID_starts_with,omitempty"`
	MIdNotStartsWith   *string                  `json:"mID_not_starts_with,omitempty"`
	MIdEndsWith        *string                  `json:"mID_ends_with,omitempty"`
	MIdNotEndsWith     *string                  `json:"mID_not_ends_with,omitempty"`
	Name               *string                  `json:"name,omitempty"`
	NameNot            *string                  `json:"name_not,omitempty"`
	NameIn             []string                 `json:"name_in,omitempty"`
	NameNotIn          []string                 `json:"name_not_in,omitempty"`
	NameLt             *string                  `json:"name_lt,omitempty"`
	NameLte            *string                  `json:"name_lte,omitempty"`
	NameGt             *string                  `json:"name_gt,omitempty"`
	NameGte            *string                  `json:"name_gte,omitempty"`
	NameContains       *string                  `json:"name_contains,omitempty"`
	NameNotContains    *string                  `json:"name_not_contains,omitempty"`
	NameStartsWith     *string                  `json:"name_starts_with,omitempty"`
	NameNotStartsWith  *string                  `json:"name_not_starts_with,omitempty"`
	NameEndsWith       *string                  `json:"name_ends_with,omitempty"`
	NameNotEndsWith    *string                  `json:"name_not_ends_with,omitempty"`
	Photo              *string                  `json:"photo,omitempty"`
	PhotoNot           *string                  `json:"photo_not,omitempty"`
	PhotoIn            []string                 `json:"photo_in,omitempty"`
	PhotoNotIn         []string                 `json:"photo_not_in,omitempty"`
	PhotoLt            *string                  `json:"photo_lt,omitempty"`
	PhotoLte           *string                  `json:"photo_lte,omitempty"`
	PhotoGt            *string                  `json:"photo_gt,omitempty"`
	PhotoGte           *string                  `json:"photo_gte,omitempty"`
	PhotoContains      *string                  `json:"photo_contains,omitempty"`
	PhotoNotContains   *string                  `json:"photo_not_contains,omitempty"`
	PhotoStartsWith    *string                  `json:"photo_starts_with,omitempty"`
	PhotoNotStartsWith *string                  `json:"photo_not_starts_with,omitempty"`
	PhotoEndsWith      *string                  `json:"photo_ends_with,omitempty"`
	PhotoNotEndsWith   *string                  `json:"photo_not_ends_with,omitempty"`
	Birthday           *string                  `json:"birthday,omitempty"`
	BirthdayNot        *string                  `json:"birthday_not,omitempty"`
	BirthdayIn         []string                 `json:"birthday_in,omitempty"`
	BirthdayNotIn      []string                 `json:"birthday_not_in,omitempty"`
	BirthdayLt         *string                  `json:"birthday_lt,omitempty"`
	BirthdayLte        *string                  `json:"birthday_lte,omitempty"`
	BirthdayGt         *string                  `json:"birthday_gt,omitempty"`
	BirthdayGte        *string                  `json:"birthday_gte,omitempty"`
	From               *string                  `json:"from,omitempty"`
	FromNot            *string                  `json:"from_not,omitempty"`
	FromIn             []string                 `json:"from_in,omitempty"`
	FromNotIn          []string                 `json:"from_not_in,omitempty"`
	FromLt             *string                  `json:"from_lt,omitempty"`
	FromLte            *string                  `json:"from_lte,omitempty"`
	FromGt             *string                  `json:"from_gt,omitempty"`
	FromGte            *string                  `json:"from_gte,omitempty"`
	FromContains       *string                  `json:"from_contains,omitempty"`
	FromNotContains    *string                  `json:"from_not_contains,omitempty"`
	FromStartsWith     *string                  `json:"from_starts_with,omitempty"`
	FromNotStartsWith  *string                  `json:"from_not_starts_with,omitempty"`
	FromEndsWith       *string                  `json:"from_ends_with,omitempty"`
	FromNotEndsWith    *string                  `json:"from_not_ends_with,omitempty"`
	And                []PersonScalarWhereInput `json:"AND,omitempty"`
	Or                 []PersonScalarWhereInput `json:"OR,omitempty"`
	Not                []PersonScalarWhereInput `json:"NOT,omitempty"`
}

type FeatureCreateManyInput struct {
	Create []FeatureCreateInput `json:"create,omitempty"`
}

type PersonUpdateManyWithWhereNestedInput struct {
	Where PersonScalarWhereInput    `json:"where"`
	Data  PersonUpdateManyDataInput `json:"data"`
}

type OpeningHoursCreateOneInput struct {
	Create *OpeningHoursCreateInput `json:"create,omitempty"`
}

type PersonUpdateManyDataInput struct {
	MId      *string                `json:"mID,omitempty"`
	Name     *string                `json:"name,omitempty"`
	Photo    *string                `json:"photo,omitempty"`
	Birthday *string                `json:"birthday,omitempty"`
	From     *string                `json:"from,omitempty"`
	Tags     *PersonUpdatetagsInput `json:"tags,omitempty"`
}

type TravelerSubscriptionWhereInput struct {
	MutationIn                 []MutationType                   `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                          `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                         `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                         `json:"updatedFields_contains_some,omitempty"`
	Node                       *TravelerWhereInput              `json:"node,omitempty"`
	And                        []TravelerSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []TravelerSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []TravelerSubscriptionWhereInput `json:"NOT,omitempty"`
}

type AttractionUpdatetypesInput struct {
	Set []AttractionType `json:"set,omitempty"`
}

type IDentificationDocumentWhereInput struct {
	ID                 *string                            `json:"id,omitempty"`
	IDNot              *string                            `json:"id_not,omitempty"`
	IDIn               []string                           `json:"id_in,omitempty"`
	IDNotIn            []string                           `json:"id_not_in,omitempty"`
	IDLt               *string                            `json:"id_lt,omitempty"`
	IDLte              *string                            `json:"id_lte,omitempty"`
	IDGt               *string                            `json:"id_gt,omitempty"`
	IDGte              *string                            `json:"id_gte,omitempty"`
	IDContains         *string                            `json:"id_contains,omitempty"`
	IDNotContains      *string                            `json:"id_not_contains,omitempty"`
	IDStartsWith       *string                            `json:"id_starts_with,omitempty"`
	IDNotStartsWith    *string                            `json:"id_not_starts_with,omitempty"`
	IDEndsWith         *string                            `json:"id_ends_with,omitempty"`
	IDNotEndsWith      *string                            `json:"id_not_ends_with,omitempty"`
	CreatedAt          *string                            `json:"createdAt,omitempty"`
	CreatedAtNot       *string                            `json:"createdAt_not,omitempty"`
	CreatedAtIn        []string                           `json:"createdAt_in,omitempty"`
	CreatedAtNotIn     []string                           `json:"createdAt_not_in,omitempty"`
	CreatedAtLt        *string                            `json:"createdAt_lt,omitempty"`
	CreatedAtLte       *string                            `json:"createdAt_lte,omitempty"`
	CreatedAtGt        *string                            `json:"createdAt_gt,omitempty"`
	CreatedAtGte       *string                            `json:"createdAt_gte,omitempty"`
	UpdatedAt          *string                            `json:"updatedAt,omitempty"`
	UpdatedAtNot       *string                            `json:"updatedAt_not,omitempty"`
	UpdatedAtIn        []string                           `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn     []string                           `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt        *string                            `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte       *string                            `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt        *string                            `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte       *string                            `json:"updatedAt_gte,omitempty"`
	Person             *PersonWhereInput                  `json:"person,omitempty"`
	Type               *IDentificationType                `json:"type,omitempty"`
	TypeNot            *IDentificationType                `json:"type_not,omitempty"`
	TypeIn             []IDentificationType               `json:"type_in,omitempty"`
	TypeNotIn          []IDentificationType               `json:"type_not_in,omitempty"`
	Value              *string                            `json:"value,omitempty"`
	ValueNot           *string                            `json:"value_not,omitempty"`
	ValueIn            []string                           `json:"value_in,omitempty"`
	ValueNotIn         []string                           `json:"value_not_in,omitempty"`
	ValueLt            *string                            `json:"value_lt,omitempty"`
	ValueLte           *string                            `json:"value_lte,omitempty"`
	ValueGt            *string                            `json:"value_gt,omitempty"`
	ValueGte           *string                            `json:"value_gte,omitempty"`
	ValueContains      *string                            `json:"value_contains,omitempty"`
	ValueNotContains   *string                            `json:"value_not_contains,omitempty"`
	ValueStartsWith    *string                            `json:"value_starts_with,omitempty"`
	ValueNotStartsWith *string                            `json:"value_not_starts_with,omitempty"`
	ValueEndsWith      *string                            `json:"value_ends_with,omitempty"`
	ValueNotEndsWith   *string                            `json:"value_not_ends_with,omitempty"`
	Validated          *bool                              `json:"validated,omitempty"`
	ValidatedNot       *bool                              `json:"validated_not,omitempty"`
	And                []IDentificationDocumentWhereInput `json:"AND,omitempty"`
	Or                 []IDentificationDocumentWhereInput `json:"OR,omitempty"`
	Not                []IDentificationDocumentWhereInput `json:"NOT,omitempty"`
}

type AttractionUpdatetagsInput struct {
	Set []string `json:"set,omitempty"`
}

type PaymentEntrySubscriptionWhereInput struct {
	MutationIn                 []MutationType                       `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                              `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                             `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                             `json:"updatedFields_contains_some,omitempty"`
	Node                       *PaymentEntryWhereInput              `json:"node,omitempty"`
	And                        []PaymentEntrySubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []PaymentEntrySubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []PaymentEntrySubscriptionWhereInput `json:"NOT,omitempty"`
}

type PersonReviewsUpdateManyInput struct {
	Create     []PersonReviewsCreateInput                      `json:"create,omitempty"`
	Update     []PersonReviewsUpdateWithWhereUniqueNestedInput `json:"update,omitempty"`
	Upsert     []PersonReviewsUpsertWithWhereUniqueNestedInput `json:"upsert,omitempty"`
	Delete     []PersonReviewsWhereUniqueInput                 `json:"delete,omitempty"`
	Connect    []PersonReviewsWhereUniqueInput                 `json:"connect,omitempty"`
	Set        []PersonReviewsWhereUniqueInput                 `json:"set,omitempty"`
	Disconnect []PersonReviewsWhereUniqueInput                 `json:"disconnect,omitempty"`
	DeleteMany []PersonReviewsScalarWhereInput                 `json:"deleteMany,omitempty"`
	UpdateMany []PersonReviewsUpdateManyWithWhereNestedInput   `json:"updateMany,omitempty"`
}

type CredentialWhereUniqueInput struct {
	ID    *string `json:"id,omitempty"`
	Value *string `json:"value,omitempty"`
}

type PersonReviewsUpdateWithWhereUniqueNestedInput struct {
	Where PersonReviewsWhereUniqueInput `json:"where"`
	Data  PersonReviewsUpdateDataInput  `json:"data"`
}

type CreditCardWhereUniqueInput struct {
	ID *string `json:"id,omitempty"`
}

type PersonReviewsUpdateDataInput struct {
	Person        *PersonUpdateOneRequiredInput `json:"person,omitempty"`
	Title         *string                       `json:"title,omitempty"`
	Description   *string                       `json:"description,omitempty"`
	AproveNumber  *int32                        `json:"aproveNumber,omitempty"`
	DeclineNumber *int32                        `json:"declineNumber,omitempty"`
	Comments      *PersonReviewsUpdateManyInput `json:"comments,omitempty"`
}

type TravelerWhereInput struct {
	ID                    *string               `json:"id,omitempty"`
	IDNot                 *string               `json:"id_not,omitempty"`
	IDIn                  []string              `json:"id_in,omitempty"`
	IDNotIn               []string              `json:"id_not_in,omitempty"`
	IDLt                  *string               `json:"id_lt,omitempty"`
	IDLte                 *string               `json:"id_lte,omitempty"`
	IDGt                  *string               `json:"id_gt,omitempty"`
	IDGte                 *string               `json:"id_gte,omitempty"`
	IDContains            *string               `json:"id_contains,omitempty"`
	IDNotContains         *string               `json:"id_not_contains,omitempty"`
	IDStartsWith          *string               `json:"id_starts_with,omitempty"`
	IDNotStartsWith       *string               `json:"id_not_starts_with,omitempty"`
	IDEndsWith            *string               `json:"id_ends_with,omitempty"`
	IDNotEndsWith         *string               `json:"id_not_ends_with,omitempty"`
	CreatedAt             *string               `json:"createdAt,omitempty"`
	CreatedAtNot          *string               `json:"createdAt_not,omitempty"`
	CreatedAtIn           []string              `json:"createdAt_in,omitempty"`
	CreatedAtNotIn        []string              `json:"createdAt_not_in,omitempty"`
	CreatedAtLt           *string               `json:"createdAt_lt,omitempty"`
	CreatedAtLte          *string               `json:"createdAt_lte,omitempty"`
	CreatedAtGt           *string               `json:"createdAt_gt,omitempty"`
	CreatedAtGte          *string               `json:"createdAt_gte,omitempty"`
	UpdatedAt             *string               `json:"updatedAt,omitempty"`
	UpdatedAtNot          *string               `json:"updatedAt_not,omitempty"`
	UpdatedAtIn           []string              `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn        []string              `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt           *string               `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte          *string               `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt           *string               `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte          *string               `json:"updatedAt_gte,omitempty"`
	Person                *PersonWhereInput     `json:"person,omitempty"`
	Username              *string               `json:"username,omitempty"`
	UsernameNot           *string               `json:"username_not,omitempty"`
	UsernameIn            []string              `json:"username_in,omitempty"`
	UsernameNotIn         []string              `json:"username_not_in,omitempty"`
	UsernameLt            *string               `json:"username_lt,omitempty"`
	UsernameLte           *string               `json:"username_lte,omitempty"`
	UsernameGt            *string               `json:"username_gt,omitempty"`
	UsernameGte           *string               `json:"username_gte,omitempty"`
	UsernameContains      *string               `json:"username_contains,omitempty"`
	UsernameNotContains   *string               `json:"username_not_contains,omitempty"`
	UsernameStartsWith    *string               `json:"username_starts_with,omitempty"`
	UsernameNotStartsWith *string               `json:"username_not_starts_with,omitempty"`
	UsernameEndsWith      *string               `json:"username_ends_with,omitempty"`
	UsernameNotEndsWith   *string               `json:"username_not_ends_with,omitempty"`
	CardsEvery            *CreditCardWhereInput `json:"cards_every,omitempty"`
	CardsSome             *CreditCardWhereInput `json:"cards_some,omitempty"`
	CardsNone             *CreditCardWhereInput `json:"cards_none,omitempty"`
	TicketsEvery          *TicketWhereInput     `json:"tickets_every,omitempty"`
	TicketsSome           *TicketWhereInput     `json:"tickets_some,omitempty"`
	TicketsNone           *TicketWhereInput     `json:"tickets_none,omitempty"`
	And                   []TravelerWhereInput  `json:"AND,omitempty"`
	Or                    []TravelerWhereInput  `json:"OR,omitempty"`
	Not                   []TravelerWhereInput  `json:"NOT,omitempty"`
}

type PersonReviewsUpsertWithWhereUniqueNestedInput struct {
	Where  PersonReviewsWhereUniqueInput `json:"where"`
	Update PersonReviewsUpdateDataInput  `json:"update"`
	Create PersonReviewsCreateInput      `json:"create"`
}

type CredentialWhereInput struct {
	ID                          *string                `json:"id,omitempty"`
	IDNot                       *string                `json:"id_not,omitempty"`
	IDIn                        []string               `json:"id_in,omitempty"`
	IDNotIn                     []string               `json:"id_not_in,omitempty"`
	IDLt                        *string                `json:"id_lt,omitempty"`
	IDLte                       *string                `json:"id_lte,omitempty"`
	IDGt                        *string                `json:"id_gt,omitempty"`
	IDGte                       *string                `json:"id_gte,omitempty"`
	IDContains                  *string                `json:"id_contains,omitempty"`
	IDNotContains               *string                `json:"id_not_contains,omitempty"`
	IDStartsWith                *string                `json:"id_starts_with,omitempty"`
	IDNotStartsWith             *string                `json:"id_not_starts_with,omitempty"`
	IDEndsWith                  *string                `json:"id_ends_with,omitempty"`
	IDNotEndsWith               *string                `json:"id_not_ends_with,omitempty"`
	CreatedAt                   *string                `json:"createdAt,omitempty"`
	CreatedAtNot                *string                `json:"createdAt_not,omitempty"`
	CreatedAtIn                 []string               `json:"createdAt_in,omitempty"`
	CreatedAtNotIn              []string               `json:"createdAt_not_in,omitempty"`
	CreatedAtLt                 *string                `json:"createdAt_lt,omitempty"`
	CreatedAtLte                *string                `json:"createdAt_lte,omitempty"`
	CreatedAtGt                 *string                `json:"createdAt_gt,omitempty"`
	CreatedAtGte                *string                `json:"createdAt_gte,omitempty"`
	UpdatedAt                   *string                `json:"updatedAt,omitempty"`
	UpdatedAtNot                *string                `json:"updatedAt_not,omitempty"`
	UpdatedAtIn                 []string               `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn              []string               `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt                 *string                `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte                *string                `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt                 *string                `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte                *string                `json:"updatedAt_gte,omitempty"`
	DisplayName                 *string                `json:"displayName,omitempty"`
	DisplayNameNot              *string                `json:"displayName_not,omitempty"`
	DisplayNameIn               []string               `json:"displayName_in,omitempty"`
	DisplayNameNotIn            []string               `json:"displayName_not_in,omitempty"`
	DisplayNameLt               *string                `json:"displayName_lt,omitempty"`
	DisplayNameLte              *string                `json:"displayName_lte,omitempty"`
	DisplayNameGt               *string                `json:"displayName_gt,omitempty"`
	DisplayNameGte              *string                `json:"displayName_gte,omitempty"`
	DisplayNameContains         *string                `json:"displayName_contains,omitempty"`
	DisplayNameNotContains      *string                `json:"displayName_not_contains,omitempty"`
	DisplayNameStartsWith       *string                `json:"displayName_starts_with,omitempty"`
	DisplayNameNotStartsWith    *string                `json:"displayName_not_starts_with,omitempty"`
	DisplayNameEndsWith         *string                `json:"displayName_ends_with,omitempty"`
	DisplayNameNotEndsWith      *string                `json:"displayName_not_ends_with,omitempty"`
	Owner                       *PersonWhereInput      `json:"owner,omitempty"`
	IsMain                      *bool                  `json:"isMain,omitempty"`
	IsMainNot                   *bool                  `json:"isMain_not,omitempty"`
	Type                        *CredentialType        `json:"type,omitempty"`
	TypeNot                     *CredentialType        `json:"type_not,omitempty"`
	TypeIn                      []CredentialType       `json:"type_in,omitempty"`
	TypeNotIn                   []CredentialType       `json:"type_not_in,omitempty"`
	Validated                   *bool                  `json:"validated,omitempty"`
	ValidatedNot                *bool                  `json:"validated_not,omitempty"`
	ValidationId                *string                `json:"validationID,omitempty"`
	ValidationIdNot             *string                `json:"validationID_not,omitempty"`
	ValidationIdIn              []string               `json:"validationID_in,omitempty"`
	ValidationIdNotIn           []string               `json:"validationID_not_in,omitempty"`
	ValidationIdLt              *string                `json:"validationID_lt,omitempty"`
	ValidationIdLte             *string                `json:"validationID_lte,omitempty"`
	ValidationIdGt              *string                `json:"validationID_gt,omitempty"`
	ValidationIdGte             *string                `json:"validationID_gte,omitempty"`
	ValidationIdContains        *string                `json:"validationID_contains,omitempty"`
	ValidationIdNotContains     *string                `json:"validationID_not_contains,omitempty"`
	ValidationIdStartsWith      *string                `json:"validationID_starts_with,omitempty"`
	ValidationIdNotStartsWith   *string                `json:"validationID_not_starts_with,omitempty"`
	ValidationIdEndsWith        *string                `json:"validationID_ends_with,omitempty"`
	ValidationIdNotEndsWith     *string                `json:"validationID_not_ends_with,omitempty"`
	Value                       *string                `json:"value,omitempty"`
	ValueNot                    *string                `json:"value_not,omitempty"`
	ValueIn                     []string               `json:"value_in,omitempty"`
	ValueNotIn                  []string               `json:"value_not_in,omitempty"`
	ValueLt                     *string                `json:"value_lt,omitempty"`
	ValueLte                    *string                `json:"value_lte,omitempty"`
	ValueGt                     *string                `json:"value_gt,omitempty"`
	ValueGte                    *string                `json:"value_gte,omitempty"`
	ValueContains               *string                `json:"value_contains,omitempty"`
	ValueNotContains            *string                `json:"value_not_contains,omitempty"`
	ValueStartsWith             *string                `json:"value_starts_with,omitempty"`
	ValueNotStartsWith          *string                `json:"value_not_starts_with,omitempty"`
	ValueEndsWith               *string                `json:"value_ends_with,omitempty"`
	ValueNotEndsWith            *string                `json:"value_not_ends_with,omitempty"`
	RawPassword                 *string                `json:"rawPassword,omitempty"`
	RawPasswordNot              *string                `json:"rawPassword_not,omitempty"`
	RawPasswordIn               []string               `json:"rawPassword_in,omitempty"`
	RawPasswordNotIn            []string               `json:"rawPassword_not_in,omitempty"`
	RawPasswordLt               *string                `json:"rawPassword_lt,omitempty"`
	RawPasswordLte              *string                `json:"rawPassword_lte,omitempty"`
	RawPasswordGt               *string                `json:"rawPassword_gt,omitempty"`
	RawPasswordGte              *string                `json:"rawPassword_gte,omitempty"`
	RawPasswordContains         *string                `json:"rawPassword_contains,omitempty"`
	RawPasswordNotContains      *string                `json:"rawPassword_not_contains,omitempty"`
	RawPasswordStartsWith       *string                `json:"rawPassword_starts_with,omitempty"`
	RawPasswordNotStartsWith    *string                `json:"rawPassword_not_starts_with,omitempty"`
	RawPasswordEndsWith         *string                `json:"rawPassword_ends_with,omitempty"`
	RawPasswordNotEndsWith      *string                `json:"rawPassword_not_ends_with,omitempty"`
	HashedPassword              *string                `json:"hashedPassword,omitempty"`
	HashedPasswordNot           *string                `json:"hashedPassword_not,omitempty"`
	HashedPasswordIn            []string               `json:"hashedPassword_in,omitempty"`
	HashedPasswordNotIn         []string               `json:"hashedPassword_not_in,omitempty"`
	HashedPasswordLt            *string                `json:"hashedPassword_lt,omitempty"`
	HashedPasswordLte           *string                `json:"hashedPassword_lte,omitempty"`
	HashedPasswordGt            *string                `json:"hashedPassword_gt,omitempty"`
	HashedPasswordGte           *string                `json:"hashedPassword_gte,omitempty"`
	HashedPasswordContains      *string                `json:"hashedPassword_contains,omitempty"`
	HashedPasswordNotContains   *string                `json:"hashedPassword_not_contains,omitempty"`
	HashedPasswordStartsWith    *string                `json:"hashedPassword_starts_with,omitempty"`
	HashedPasswordNotStartsWith *string                `json:"hashedPassword_not_starts_with,omitempty"`
	HashedPasswordEndsWith      *string                `json:"hashedPassword_ends_with,omitempty"`
	HashedPasswordNotEndsWith   *string                `json:"hashedPassword_not_ends_with,omitempty"`
	And                         []CredentialWhereInput `json:"AND,omitempty"`
	Or                          []CredentialWhereInput `json:"OR,omitempty"`
	Not                         []CredentialWhereInput `json:"NOT,omitempty"`
}

type PersonReviewsScalarWhereInput struct {
	ID                       *string                         `json:"id,omitempty"`
	IDNot                    *string                         `json:"id_not,omitempty"`
	IDIn                     []string                        `json:"id_in,omitempty"`
	IDNotIn                  []string                        `json:"id_not_in,omitempty"`
	IDLt                     *string                         `json:"id_lt,omitempty"`
	IDLte                    *string                         `json:"id_lte,omitempty"`
	IDGt                     *string                         `json:"id_gt,omitempty"`
	IDGte                    *string                         `json:"id_gte,omitempty"`
	IDContains               *string                         `json:"id_contains,omitempty"`
	IDNotContains            *string                         `json:"id_not_contains,omitempty"`
	IDStartsWith             *string                         `json:"id_starts_with,omitempty"`
	IDNotStartsWith          *string                         `json:"id_not_starts_with,omitempty"`
	IDEndsWith               *string                         `json:"id_ends_with,omitempty"`
	IDNotEndsWith            *string                         `json:"id_not_ends_with,omitempty"`
	CreatedAt                *string                         `json:"createdAt,omitempty"`
	CreatedAtNot             *string                         `json:"createdAt_not,omitempty"`
	CreatedAtIn              []string                        `json:"createdAt_in,omitempty"`
	CreatedAtNotIn           []string                        `json:"createdAt_not_in,omitempty"`
	CreatedAtLt              *string                         `json:"createdAt_lt,omitempty"`
	CreatedAtLte             *string                         `json:"createdAt_lte,omitempty"`
	CreatedAtGt              *string                         `json:"createdAt_gt,omitempty"`
	CreatedAtGte             *string                         `json:"createdAt_gte,omitempty"`
	UpdatedAt                *string                         `json:"updatedAt,omitempty"`
	UpdatedAtNot             *string                         `json:"updatedAt_not,omitempty"`
	UpdatedAtIn              []string                        `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn           []string                        `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt              *string                         `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte             *string                         `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt              *string                         `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte             *string                         `json:"updatedAt_gte,omitempty"`
	Title                    *string                         `json:"title,omitempty"`
	TitleNot                 *string                         `json:"title_not,omitempty"`
	TitleIn                  []string                        `json:"title_in,omitempty"`
	TitleNotIn               []string                        `json:"title_not_in,omitempty"`
	TitleLt                  *string                         `json:"title_lt,omitempty"`
	TitleLte                 *string                         `json:"title_lte,omitempty"`
	TitleGt                  *string                         `json:"title_gt,omitempty"`
	TitleGte                 *string                         `json:"title_gte,omitempty"`
	TitleContains            *string                         `json:"title_contains,omitempty"`
	TitleNotContains         *string                         `json:"title_not_contains,omitempty"`
	TitleStartsWith          *string                         `json:"title_starts_with,omitempty"`
	TitleNotStartsWith       *string                         `json:"title_not_starts_with,omitempty"`
	TitleEndsWith            *string                         `json:"title_ends_with,omitempty"`
	TitleNotEndsWith         *string                         `json:"title_not_ends_with,omitempty"`
	Description              *string                         `json:"description,omitempty"`
	DescriptionNot           *string                         `json:"description_not,omitempty"`
	DescriptionIn            []string                        `json:"description_in,omitempty"`
	DescriptionNotIn         []string                        `json:"description_not_in,omitempty"`
	DescriptionLt            *string                         `json:"description_lt,omitempty"`
	DescriptionLte           *string                         `json:"description_lte,omitempty"`
	DescriptionGt            *string                         `json:"description_gt,omitempty"`
	DescriptionGte           *string                         `json:"description_gte,omitempty"`
	DescriptionContains      *string                         `json:"description_contains,omitempty"`
	DescriptionNotContains   *string                         `json:"description_not_contains,omitempty"`
	DescriptionStartsWith    *string                         `json:"description_starts_with,omitempty"`
	DescriptionNotStartsWith *string                         `json:"description_not_starts_with,omitempty"`
	DescriptionEndsWith      *string                         `json:"description_ends_with,omitempty"`
	DescriptionNotEndsWith   *string                         `json:"description_not_ends_with,omitempty"`
	AproveNumber             *int32                          `json:"aproveNumber,omitempty"`
	AproveNumberNot          *int32                          `json:"aproveNumber_not,omitempty"`
	AproveNumberIn           []int32                         `json:"aproveNumber_in,omitempty"`
	AproveNumberNotIn        []int32                         `json:"aproveNumber_not_in,omitempty"`
	AproveNumberLt           *int32                          `json:"aproveNumber_lt,omitempty"`
	AproveNumberLte          *int32                          `json:"aproveNumber_lte,omitempty"`
	AproveNumberGt           *int32                          `json:"aproveNumber_gt,omitempty"`
	AproveNumberGte          *int32                          `json:"aproveNumber_gte,omitempty"`
	DeclineNumber            *int32                          `json:"declineNumber,omitempty"`
	DeclineNumberNot         *int32                          `json:"declineNumber_not,omitempty"`
	DeclineNumberIn          []int32                         `json:"declineNumber_in,omitempty"`
	DeclineNumberNotIn       []int32                         `json:"declineNumber_not_in,omitempty"`
	DeclineNumberLt          *int32                          `json:"declineNumber_lt,omitempty"`
	DeclineNumberLte         *int32                          `json:"declineNumber_lte,omitempty"`
	DeclineNumberGt          *int32                          `json:"declineNumber_gt,omitempty"`
	DeclineNumberGte         *int32                          `json:"declineNumber_gte,omitempty"`
	And                      []PersonReviewsScalarWhereInput `json:"AND,omitempty"`
	Or                       []PersonReviewsScalarWhereInput `json:"OR,omitempty"`
	Not                      []PersonReviewsScalarWhereInput `json:"NOT,omitempty"`
}

type TravelerUpdateManyMutationInput struct {
	Username *string `json:"username,omitempty"`
}

type PersonReviewsUpdateManyWithWhereNestedInput struct {
	Where PersonReviewsScalarWhereInput    `json:"where"`
	Data  PersonReviewsUpdateManyDataInput `json:"data"`
}

type CreditCardScalarWhereInput struct {
	ID                      *string                      `json:"id,omitempty"`
	IDNot                   *string                      `json:"id_not,omitempty"`
	IDIn                    []string                     `json:"id_in,omitempty"`
	IDNotIn                 []string                     `json:"id_not_in,omitempty"`
	IDLt                    *string                      `json:"id_lt,omitempty"`
	IDLte                   *string                      `json:"id_lte,omitempty"`
	IDGt                    *string                      `json:"id_gt,omitempty"`
	IDGte                   *string                      `json:"id_gte,omitempty"`
	IDContains              *string                      `json:"id_contains,omitempty"`
	IDNotContains           *string                      `json:"id_not_contains,omitempty"`
	IDStartsWith            *string                      `json:"id_starts_with,omitempty"`
	IDNotStartsWith         *string                      `json:"id_not_starts_with,omitempty"`
	IDEndsWith              *string                      `json:"id_ends_with,omitempty"`
	IDNotEndsWith           *string                      `json:"id_not_ends_with,omitempty"`
	CreatedAt               *string                      `json:"createdAt,omitempty"`
	CreatedAtNot            *string                      `json:"createdAt_not,omitempty"`
	CreatedAtIn             []string                     `json:"createdAt_in,omitempty"`
	CreatedAtNotIn          []string                     `json:"createdAt_not_in,omitempty"`
	CreatedAtLt             *string                      `json:"createdAt_lt,omitempty"`
	CreatedAtLte            *string                      `json:"createdAt_lte,omitempty"`
	CreatedAtGt             *string                      `json:"createdAt_gt,omitempty"`
	CreatedAtGte            *string                      `json:"createdAt_gte,omitempty"`
	UpdatedAt               *string                      `json:"updatedAt,omitempty"`
	UpdatedAtNot            *string                      `json:"updatedAt_not,omitempty"`
	UpdatedAtIn             []string                     `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn          []string                     `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt             *string                      `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte            *string                      `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt             *string                      `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte            *string                      `json:"updatedAt_gte,omitempty"`
	CardNumber              *string                      `json:"cardNumber,omitempty"`
	CardNumberNot           *string                      `json:"cardNumber_not,omitempty"`
	CardNumberIn            []string                     `json:"cardNumber_in,omitempty"`
	CardNumberNotIn         []string                     `json:"cardNumber_not_in,omitempty"`
	CardNumberLt            *string                      `json:"cardNumber_lt,omitempty"`
	CardNumberLte           *string                      `json:"cardNumber_lte,omitempty"`
	CardNumberGt            *string                      `json:"cardNumber_gt,omitempty"`
	CardNumberGte           *string                      `json:"cardNumber_gte,omitempty"`
	CardNumberContains      *string                      `json:"cardNumber_contains,omitempty"`
	CardNumberNotContains   *string                      `json:"cardNumber_not_contains,omitempty"`
	CardNumberStartsWith    *string                      `json:"cardNumber_starts_with,omitempty"`
	CardNumberNotStartsWith *string                      `json:"cardNumber_not_starts_with,omitempty"`
	CardNumberEndsWith      *string                      `json:"cardNumber_ends_with,omitempty"`
	CardNumberNotEndsWith   *string                      `json:"cardNumber_not_ends_with,omitempty"`
	CardToken               *string                      `json:"cardToken,omitempty"`
	CardTokenNot            *string                      `json:"cardToken_not,omitempty"`
	CardTokenIn             []string                     `json:"cardToken_in,omitempty"`
	CardTokenNotIn          []string                     `json:"cardToken_not_in,omitempty"`
	CardTokenLt             *string                      `json:"cardToken_lt,omitempty"`
	CardTokenLte            *string                      `json:"cardToken_lte,omitempty"`
	CardTokenGt             *string                      `json:"cardToken_gt,omitempty"`
	CardTokenGte            *string                      `json:"cardToken_gte,omitempty"`
	CardTokenContains       *string                      `json:"cardToken_contains,omitempty"`
	CardTokenNotContains    *string                      `json:"cardToken_not_contains,omitempty"`
	CardTokenStartsWith     *string                      `json:"cardToken_starts_with,omitempty"`
	CardTokenNotStartsWith  *string                      `json:"cardToken_not_starts_with,omitempty"`
	CardTokenEndsWith       *string                      `json:"cardToken_ends_with,omitempty"`
	CardTokenNotEndsWith    *string                      `json:"cardToken_not_ends_with,omitempty"`
	Type                    *CreditCardType              `json:"type,omitempty"`
	TypeNot                 *CreditCardType              `json:"type_not,omitempty"`
	TypeIn                  []CreditCardType             `json:"type_in,omitempty"`
	TypeNotIn               []CreditCardType             `json:"type_not_in,omitempty"`
	LastUsed                *string                      `json:"lastUsed,omitempty"`
	LastUsedNot             *string                      `json:"lastUsed_not,omitempty"`
	LastUsedIn              []string                     `json:"lastUsed_in,omitempty"`
	LastUsedNotIn           []string                     `json:"lastUsed_not_in,omitempty"`
	LastUsedLt              *string                      `json:"lastUsed_lt,omitempty"`
	LastUsedLte             *string                      `json:"lastUsed_lte,omitempty"`
	LastUsedGt              *string                      `json:"lastUsed_gt,omitempty"`
	LastUsedGte             *string                      `json:"lastUsed_gte,omitempty"`
	And                     []CreditCardScalarWhereInput `json:"AND,omitempty"`
	Or                      []CreditCardScalarWhereInput `json:"OR,omitempty"`
	Not                     []CreditCardScalarWhereInput `json:"NOT,omitempty"`
}

type PersonReviewsUpdateManyDataInput struct {
	Title         *string `json:"title,omitempty"`
	Description   *string `json:"description,omitempty"`
	AproveNumber  *int32  `json:"aproveNumber,omitempty"`
	DeclineNumber *int32  `json:"declineNumber,omitempty"`
}

type CreditCardUpdateManyWithoutOwnerInput struct {
	Create     []CreditCardCreateWithoutOwnerInput                `json:"create,omitempty"`
	Delete     []CreditCardWhereUniqueInput                       `json:"delete,omitempty"`
	Connect    []CreditCardWhereUniqueInput                       `json:"connect,omitempty"`
	Set        []CreditCardWhereUniqueInput                       `json:"set,omitempty"`
	Disconnect []CreditCardWhereUniqueInput                       `json:"disconnect,omitempty"`
	Update     []CreditCardUpdateWithWhereUniqueWithoutOwnerInput `json:"update,omitempty"`
	Upsert     []CreditCardUpsertWithWhereUniqueWithoutOwnerInput `json:"upsert,omitempty"`
	DeleteMany []CreditCardScalarWhereInput                       `json:"deleteMany,omitempty"`
	UpdateMany []CreditCardUpdateManyWithWhereNestedInput         `json:"updateMany,omitempty"`
}

type DetailsUpdateOneInput struct {
	Create     *DetailsCreateInput       `json:"create,omitempty"`
	Update     *DetailsUpdateDataInput   `json:"update,omitempty"`
	Upsert     *DetailsUpsertNestedInput `json:"upsert,omitempty"`
	Delete     *bool                     `json:"delete,omitempty"`
	Disconnect *bool                     `json:"disconnect,omitempty"`
}

type CreditCardCreateManyWithoutOwnerInput struct {
	Create  []CreditCardCreateWithoutOwnerInput `json:"create,omitempty"`
	Connect []CreditCardWhereUniqueInput        `json:"connect,omitempty"`
}

type DetailsUpdateDataInput struct {
	ProviderName     *string `json:"providerName,omitempty"`
	ProviderWeb      *string `json:"providerWeb,omitempty"`
	ContactPhone     *string `json:"contactPhone,omitempty"`
	ContactEmail     *string `json:"contactEmail,omitempty"`
	AddressReference *string `json:"addressReference,omitempty"`
}

type TicketUpdateManyMutationInput struct {
	ExpireAt *string `json:"expireAt,omitempty"`
}

type DetailsUpsertNestedInput struct {
	Update DetailsUpdateDataInput `json:"update"`
	Create DetailsCreateInput     `json:"create"`
}

type PhoneChannelUpdateInput struct {
	DisplayName *string `json:"displayName,omitempty"`
	Valid       *bool   `json:"valid,omitempty"`
	CountryCode *string `json:"countryCode,omitempty"`
	Number      *string `json:"number,omitempty"`
}

type AttractionUpdateManyMutationInput struct {
	MaxUses    *int32                      `json:"maxUses,omitempty"`
	Address    *string                     `json:"address,omitempty"`
	Popularity *float64                    `json:"popularity,omitempty"`
	Types      *AttractionUpdatetypesInput `json:"types,omitempty"`
	Tags       *AttractionUpdatetagsInput  `json:"tags,omitempty"`
}

type PersonUpdateInput struct {
	MId            *string                                                    `json:"mID,omitempty"`
	Name           *string                                                    `json:"name,omitempty"`
	Photo          *string                                                    `json:"photo,omitempty"`
	Birthday       *string                                                    `json:"birthday,omitempty"`
	From           *string                                                    `json:"from,omitempty"`
	ChannelsPhone  *PhoneChannelUpdateManyInput                               `json:"channelsPhone,omitempty"`
	ChannelsEmail  *EmailChannelUpdateManyInput                               `json:"channelsEmail,omitempty"`
	IDentification *IDentificationDocumentUpdateOneRequiredWithoutPersonInput `json:"identification,omitempty"`
	Tags           *PersonUpdatetagsInput                                     `json:"tags,omitempty"`
	Credentials    *CredentialUpdateManyWithoutOwnerInput                     `json:"credentials,omitempty"`
}

type TicketScalarWhereInput struct {
	ID              *string                  `json:"id,omitempty"`
	IDNot           *string                  `json:"id_not,omitempty"`
	IDIn            []string                 `json:"id_in,omitempty"`
	IDNotIn         []string                 `json:"id_not_in,omitempty"`
	IDLt            *string                  `json:"id_lt,omitempty"`
	IDLte           *string                  `json:"id_lte,omitempty"`
	IDGt            *string                  `json:"id_gt,omitempty"`
	IDGte           *string                  `json:"id_gte,omitempty"`
	IDContains      *string                  `json:"id_contains,omitempty"`
	IDNotContains   *string                  `json:"id_not_contains,omitempty"`
	IDStartsWith    *string                  `json:"id_starts_with,omitempty"`
	IDNotStartsWith *string                  `json:"id_not_starts_with,omitempty"`
	IDEndsWith      *string                  `json:"id_ends_with,omitempty"`
	IDNotEndsWith   *string                  `json:"id_not_ends_with,omitempty"`
	CreatedAt       *string                  `json:"createdAt,omitempty"`
	CreatedAtNot    *string                  `json:"createdAt_not,omitempty"`
	CreatedAtIn     []string                 `json:"createdAt_in,omitempty"`
	CreatedAtNotIn  []string                 `json:"createdAt_not_in,omitempty"`
	CreatedAtLt     *string                  `json:"createdAt_lt,omitempty"`
	CreatedAtLte    *string                  `json:"createdAt_lte,omitempty"`
	CreatedAtGt     *string                  `json:"createdAt_gt,omitempty"`
	CreatedAtGte    *string                  `json:"createdAt_gte,omitempty"`
	UpdatedAt       *string                  `json:"updatedAt,omitempty"`
	UpdatedAtNot    *string                  `json:"updatedAt_not,omitempty"`
	UpdatedAtIn     []string                 `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn  []string                 `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt     *string                  `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte    *string                  `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt     *string                  `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte    *string                  `json:"updatedAt_gte,omitempty"`
	ExpireAt        *string                  `json:"expireAt,omitempty"`
	ExpireAtNot     *string                  `json:"expireAt_not,omitempty"`
	ExpireAtIn      []string                 `json:"expireAt_in,omitempty"`
	ExpireAtNotIn   []string                 `json:"expireAt_not_in,omitempty"`
	ExpireAtLt      *string                  `json:"expireAt_lt,omitempty"`
	ExpireAtLte     *string                  `json:"expireAt_lte,omitempty"`
	ExpireAtGt      *string                  `json:"expireAt_gt,omitempty"`
	ExpireAtGte     *string                  `json:"expireAt_gte,omitempty"`
	And             []TicketScalarWhereInput `json:"AND,omitempty"`
	Or              []TicketScalarWhereInput `json:"OR,omitempty"`
	Not             []TicketScalarWhereInput `json:"NOT,omitempty"`
}

type PartnerUpdateManyMutationInput struct {
	BrandName    *string `json:"brandName,omitempty"`
	SocialReason *string `json:"socialReason,omitempty"`
	Ruc          *string `json:"ruc,omitempty"`
	Address      *string `json:"address,omitempty"`
}

type TicketUpsertWithWhereUniqueNestedInput struct {
	Where  TicketWhereUniqueInput `json:"where"`
	Update TicketUpdateDataInput  `json:"update"`
	Create TicketCreateInput      `json:"create"`
}

type AttractionUpdateManyWithoutOwnerInput struct {
	Create     []AttractionCreateWithoutOwnerInput                `json:"create,omitempty"`
	Delete     []AttractionWhereUniqueInput                       `json:"delete,omitempty"`
	Connect    []AttractionWhereUniqueInput                       `json:"connect,omitempty"`
	Set        []AttractionWhereUniqueInput                       `json:"set,omitempty"`
	Disconnect []AttractionWhereUniqueInput                       `json:"disconnect,omitempty"`
	Update     []AttractionUpdateWithWhereUniqueWithoutOwnerInput `json:"update,omitempty"`
	Upsert     []AttractionUpsertWithWhereUniqueWithoutOwnerInput `json:"upsert,omitempty"`
	DeleteMany []AttractionScalarWhereInput                       `json:"deleteMany,omitempty"`
	UpdateMany []AttractionUpdateManyWithWhereNestedInput         `json:"updateMany,omitempty"`
}

type CredentialCreateInput struct {
	DisplayName    *string                                `json:"displayName,omitempty"`
	Owner          PersonCreateOneWithoutCredentialsInput `json:"owner"`
	IsMain         bool                                   `json:"isMain"`
	Type           *CredentialType                        `json:"type,omitempty"`
	Validated      *bool                                  `json:"validated,omitempty"`
	ValidationId   *string                                `json:"validationID,omitempty"`
	Value          string                                 `json:"value"`
	RawPassword    *string                                `json:"rawPassword,omitempty"`
	HashedPassword string                                 `json:"hashedPassword"`
}

type AttractionCreateManyWithoutOwnerInput struct {
	Create  []AttractionCreateWithoutOwnerInput `json:"create,omitempty"`
	Connect []AttractionWhereUniqueInput        `json:"connect,omitempty"`
}

type PersonCreateOneWithoutCredentialsInput struct {
	Create  *PersonCreateWithoutCredentialsInput `json:"create,omitempty"`
	Connect *PersonWhereUniqueInput              `json:"connect,omitempty"`
}

type OpeningHoursUpdateManyMutationInput struct {
	From *string `json:"from,omitempty"`
	To   *string `json:"to,omitempty"`
}

type PersonCreateWithoutCredentialsInput struct {
	MId            *string                                           `json:"mID,omitempty"`
	Name           string                                            `json:"name"`
	Photo          *string                                           `json:"photo,omitempty"`
	Birthday       string                                            `json:"birthday"`
	From           *string                                           `json:"from,omitempty"`
	ChannelsPhone  *PhoneChannelCreateManyInput                      `json:"channelsPhone,omitempty"`
	ChannelsEmail  *EmailChannelCreateManyInput                      `json:"channelsEmail,omitempty"`
	IDentification IDentificationDocumentCreateOneWithoutPersonInput `json:"identification"`
	Tags           *PersonCreatetagsInput                            `json:"tags,omitempty"`
}

type PersonUpsertWithoutIdentificationInput struct {
	Update PersonUpdateWithoutIdentificationDataInput `json:"update"`
	Create PersonCreateWithoutIdentificationInput     `json:"create"`
}

type CredentialUpdateInput struct {
	DisplayName    *string                                         `json:"displayName,omitempty"`
	Owner          *PersonUpdateOneRequiredWithoutCredentialsInput `json:"owner,omitempty"`
	IsMain         *bool                                           `json:"isMain,omitempty"`
	Type           *CredentialType                                 `json:"type,omitempty"`
	Validated      *bool                                           `json:"validated,omitempty"`
	ValidationId   *string                                         `json:"validationID,omitempty"`
	Value          *string                                         `json:"value,omitempty"`
	RawPassword    *string                                         `json:"rawPassword,omitempty"`
	HashedPassword *string                                         `json:"hashedPassword,omitempty"`
}

type IDentificationDocumentUpdateInput struct {
	Person    *PersonUpdateOneRequiredWithoutIdentificationInput `json:"person,omitempty"`
	Type      *IDentificationType                                `json:"type,omitempty"`
	Value     *string                                            `json:"value,omitempty"`
	Validated *bool                                              `json:"validated,omitempty"`
}

type PersonUpdateOneRequiredWithoutCredentialsInput struct {
	Create  *PersonCreateWithoutCredentialsInput     `json:"create,omitempty"`
	Update  *PersonUpdateWithoutCredentialsDataInput `json:"update,omitempty"`
	Upsert  *PersonUpsertWithoutCredentialsInput     `json:"upsert,omitempty"`
	Connect *PersonWhereUniqueInput                  `json:"connect,omitempty"`
}

type IDentificationDocumentCreateInput struct {
	Person    PersonCreateOneWithoutIdentificationInput `json:"person"`
	Type      IDentificationType                        `json:"type"`
	Value     string                                    `json:"value"`
	Validated *bool                                     `json:"validated,omitempty"`
}

type PersonUpdateWithoutCredentialsDataInput struct {
	MId            *string                                                    `json:"mID,omitempty"`
	Name           *string                                                    `json:"name,omitempty"`
	Photo          *string                                                    `json:"photo,omitempty"`
	Birthday       *string                                                    `json:"birthday,omitempty"`
	From           *string                                                    `json:"from,omitempty"`
	ChannelsPhone  *PhoneChannelUpdateManyInput                               `json:"channelsPhone,omitempty"`
	ChannelsEmail  *EmailChannelUpdateManyInput                               `json:"channelsEmail,omitempty"`
	IDentification *IDentificationDocumentUpdateOneRequiredWithoutPersonInput `json:"identification,omitempty"`
	Tags           *PersonUpdatetagsInput                                     `json:"tags,omitempty"`
}

type EmailChannelUpdateInput struct {
	DisplayName *string                        `json:"displayName,omitempty"`
	Valid       *bool                          `json:"valid,omitempty"`
	Value       *string                        `json:"value,omitempty"`
	Extras      *EmailChannelUpdateextrasInput `json:"extras,omitempty"`
}

type PersonUpsertWithoutCredentialsInput struct {
	Update PersonUpdateWithoutCredentialsDataInput `json:"update"`
	Create PersonCreateWithoutCredentialsInput     `json:"create"`
}

type PaymentEntryUpdateManyDataInput struct {
	ExternalId      *string `json:"externalID,omitempty"`
	ProductId       *string `json:"productID,omitempty"`
	Product         *string `json:"product,omitempty"`
	GatewayResponse *string `json:"gatewayResponse,omitempty"`
	Amount          *int32  `json:"amount,omitempty"`
	DiscountId      *string `json:"discountID,omitempty"`
	Discount        *int32  `json:"discount,omitempty"`
}

type CredentialUpdateManyMutationInput struct {
	DisplayName    *string         `json:"displayName,omitempty"`
	IsMain         *bool           `json:"isMain,omitempty"`
	Type           *CredentialType `json:"type,omitempty"`
	Validated      *bool           `json:"validated,omitempty"`
	ValidationId   *string         `json:"validationID,omitempty"`
	Value          *string         `json:"value,omitempty"`
	RawPassword    *string         `json:"rawPassword,omitempty"`
	HashedPassword *string         `json:"hashedPassword,omitempty"`
}

type TravelerWhereUniqueInput struct {
	ID       *string `json:"id,omitempty"`
	Username *string `json:"username,omitempty"`
}

type CreditCardCreateInput struct {
	Owner      TravelerCreateOneWithoutCardsInput          `json:"owner"`
	CardNumber string                                      `json:"cardNumber"`
	CardToken  string                                      `json:"cardToken"`
	Type       *CreditCardType                             `json:"type,omitempty"`
	LastUsed   *string                                     `json:"lastUsed,omitempty"`
	Uses       *PaymentEntryCreateManyWithoutWithCardInput `json:"uses,omitempty"`
}

type TravelerUpsertWithoutCardsInput struct {
	Update TravelerUpdateWithoutCardsDataInput `json:"update"`
	Create TravelerCreateWithoutCardsInput     `json:"create"`
}

type TravelerCreateOneWithoutCardsInput struct {
	Create  *TravelerCreateWithoutCardsInput `json:"create,omitempty"`
	Connect *TravelerWhereUniqueInput        `json:"connect,omitempty"`
}

type PartnerCreateWithoutAttractionsInput struct {
	Person       PersonCreateOneInput       `json:"person"`
	BrandName    string                     `json:"brandName"`
	SocialReason string                     `json:"socialReason"`
	Ruc          string                     `json:"ruc"`
	Address      string                     `json:"address"`
	Location     LocationCreateOneInput     `json:"location"`
	Features     *FeatureCreateManyInput    `json:"features,omitempty"`
	OpeningHours OpeningHoursCreateOneInput `json:"openingHours"`
}

type TravelerCreateWithoutCardsInput struct {
	Person   PersonCreateOneInput   `json:"person"`
	Username string                 `json:"username"`
	Tickets  *TicketCreateManyInput `json:"tickets,omitempty"`
}

type PhoneChannelCreateInput struct {
	DisplayName string  `json:"displayName"`
	Valid       *bool   `json:"valid,omitempty"`
	CountryCode string  `json:"countryCode"`
	Number      *string `json:"number,omitempty"`
}

type TicketCreateManyInput struct {
	Create  []TicketCreateInput      `json:"create,omitempty"`
	Connect []TicketWhereUniqueInput `json:"connect,omitempty"`
}

type IDentificationDocumentCreateOneWithoutPersonInput struct {
	Create  *IDentificationDocumentCreateWithoutPersonInput `json:"create,omitempty"`
	Connect *IDentificationDocumentWhereUniqueInput         `json:"connect,omitempty"`
}

type TicketCreateInput struct {
	Type     TicketTypeCreateOneInput   `json:"type"`
	Owner    PersonCreateOneInput       `json:"owner"`
	Receive  PaymentEntryCreateOneInput `json:"receive"`
	ExpireAt string                     `json:"expireAt"`
	Visited  *AttractionCreateManyInput `json:"visited,omitempty"`
}

type CredentialCreateWithoutOwnerInput struct {
	DisplayName    *string         `json:"displayName,omitempty"`
	IsMain         bool            `json:"isMain"`
	Type           *CredentialType `json:"type,omitempty"`
	Validated      *bool           `json:"validated,omitempty"`
	ValidationId   *string         `json:"validationID,omitempty"`
	Value          string          `json:"value"`
	RawPassword    *string         `json:"rawPassword,omitempty"`
	HashedPassword string          `json:"hashedPassword"`
}

type TicketTypeCreateOneInput struct {
	Create  *TicketTypeCreateInput      `json:"create,omitempty"`
	Connect *TicketTypeWhereUniqueInput `json:"connect,omitempty"`
}

type FeatureCreateInput struct {
	Name  *string `json:"name,omitempty"`
	Image *string `json:"image,omitempty"`
}

type TicketTypeCreateInput struct {
	CreatorId   string                     `json:"creatorID"`
	Attractions *AttractionCreateManyInput `json:"attractions,omitempty"`
	Cost        float64                    `json:"cost"`
}

type TicketSubscriptionWhereInput struct {
	MutationIn                 []MutationType                 `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                        `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                       `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                       `json:"updatedFields_contains_some,omitempty"`
	Node                       *TicketWhereInput              `json:"node,omitempty"`
	And                        []TicketSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []TicketSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []TicketSubscriptionWhereInput `json:"NOT,omitempty"`
}

type AttractionCreateManyInput struct {
	Create  []AttractionCreateInput      `json:"create,omitempty"`
	Connect []AttractionWhereUniqueInput `json:"connect,omitempty"`
}

type OverviewSubscriptionWhereInput struct {
	MutationIn                 []MutationType                   `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                          `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                         `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                         `json:"updatedFields_contains_some,omitempty"`
	Node                       *OverviewWhereInput              `json:"node,omitempty"`
	And                        []OverviewSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []OverviewSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []OverviewSubscriptionWhereInput `json:"NOT,omitempty"`
}

type PaymentEntryCreateOneInput struct {
	Create  *PaymentEntryCreateInput      `json:"create,omitempty"`
	Connect *PaymentEntryWhereUniqueInput `json:"connect,omitempty"`
}

type DetailsSubscriptionWhereInput struct {
	MutationIn                 []MutationType                  `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                         `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                        `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                        `json:"updatedFields_contains_some,omitempty"`
	Node                       *DetailsWhereInput              `json:"node,omitempty"`
	And                        []DetailsSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []DetailsSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []DetailsSubscriptionWhereInput `json:"NOT,omitempty"`
}

type PaymentEntryCreateInput struct {
	ExternalId      string                              `json:"externalID"`
	WithCard        CreditCardCreateOneWithoutUsesInput `json:"withCard"`
	ProductId       string                              `json:"productID"`
	Product         string                              `json:"product"`
	GatewayResponse *string                             `json:"gatewayResponse,omitempty"`
	Amount          int32                               `json:"amount"`
	DiscountId      *string                             `json:"discountID,omitempty"`
	Discount        *int32                              `json:"discount,omitempty"`
}

type CredentialSubscriptionWhereInput struct {
	MutationIn                 []MutationType                     `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                            `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                           `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                           `json:"updatedFields_contains_some,omitempty"`
	Node                       *CredentialWhereInput              `json:"node,omitempty"`
	And                        []CredentialSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []CredentialSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []CredentialSubscriptionWhereInput `json:"NOT,omitempty"`
}

type CreditCardCreateOneWithoutUsesInput struct {
	Create  *CreditCardCreateWithoutUsesInput `json:"create,omitempty"`
	Connect *CreditCardWhereUniqueInput       `json:"connect,omitempty"`
}

type CreditCardUpdateWithoutOwnerDataInput struct {
	CardNumber *string                                     `json:"cardNumber,omitempty"`
	CardToken  *string                                     `json:"cardToken,omitempty"`
	Type       *CreditCardType                             `json:"type,omitempty"`
	LastUsed   *string                                     `json:"lastUsed,omitempty"`
	Uses       *PaymentEntryUpdateManyWithoutWithCardInput `json:"uses,omitempty"`
}

type CreditCardCreateWithoutUsesInput struct {
	Owner      TravelerCreateOneWithoutCardsInput `json:"owner"`
	CardNumber string                             `json:"cardNumber"`
	CardToken  string                             `json:"cardToken"`
	Type       *CreditCardType                    `json:"type,omitempty"`
	LastUsed   *string                            `json:"lastUsed,omitempty"`
}

type TicketTypeUpdateManyMutationInput struct {
	CreatorId *string  `json:"creatorID,omitempty"`
	Cost      *float64 `json:"cost,omitempty"`
}

type PaymentEntryCreateManyWithoutWithCardInput struct {
	Create  []PaymentEntryCreateWithoutWithCardInput `json:"create,omitempty"`
	Connect []PaymentEntryWhereUniqueInput           `json:"connect,omitempty"`
}

type PersonReviewsUpdateInput struct {
	Person        *PersonUpdateOneRequiredInput `json:"person,omitempty"`
	Title         *string                       `json:"title,omitempty"`
	Description   *string                       `json:"description,omitempty"`
	AproveNumber  *int32                        `json:"aproveNumber,omitempty"`
	DeclineNumber *int32                        `json:"declineNumber,omitempty"`
	Comments      *PersonReviewsUpdateManyInput `json:"comments,omitempty"`
}

type PaymentEntryCreateWithoutWithCardInput struct {
	ExternalId      string  `json:"externalID"`
	ProductId       string  `json:"productID"`
	Product         string  `json:"product"`
	GatewayResponse *string `json:"gatewayResponse,omitempty"`
	Amount          int32   `json:"amount"`
	DiscountId      *string `json:"discountID,omitempty"`
	Discount        *int32  `json:"discount,omitempty"`
}

type AttractionUpdateWithoutOwnerDataInput struct {
	Overview   *OverviewUpdateOneRequiredInput `json:"overview,omitempty"`
	MaxUses    *int32                          `json:"maxUses,omitempty"`
	Address    *string                         `json:"address,omitempty"`
	Location   *LocationUpdateOneRequiredInput `json:"location,omitempty"`
	Popularity *float64                        `json:"popularity,omitempty"`
	LikedBy    *PersonUpdateManyInput          `json:"likedBy,omitempty"`
	Types      *AttractionUpdatetypesInput     `json:"types,omitempty"`
	Tags       *AttractionUpdatetagsInput      `json:"tags,omitempty"`
	Reviews    *PersonReviewsUpdateManyInput   `json:"reviews,omitempty"`
	Details    *DetailsUpdateOneInput          `json:"details,omitempty"`
}

type CreditCardUpdateInput struct {
	Owner      *TravelerUpdateOneRequiredWithoutCardsInput `json:"owner,omitempty"`
	CardNumber *string                                     `json:"cardNumber,omitempty"`
	CardToken  *string                                     `json:"cardToken,omitempty"`
	Type       *CreditCardType                             `json:"type,omitempty"`
	LastUsed   *string                                     `json:"lastUsed,omitempty"`
	Uses       *PaymentEntryUpdateManyWithoutWithCardInput `json:"uses,omitempty"`
}

type OverviewUpdateManyMutationInput struct {
	Name        *string `json:"name,omitempty"`
	Description *string `json:"description,omitempty"`
}

type TravelerUpdateOneRequiredWithoutCardsInput struct {
	Create  *TravelerCreateWithoutCardsInput     `json:"create,omitempty"`
	Update  *TravelerUpdateWithoutCardsDataInput `json:"update,omitempty"`
	Upsert  *TravelerUpsertWithoutCardsInput     `json:"upsert,omitempty"`
	Connect *TravelerWhereUniqueInput            `json:"connect,omitempty"`
}

type PersonUpdateOneRequiredWithoutIdentificationInput struct {
	Create  *PersonCreateWithoutIdentificationInput     `json:"create,omitempty"`
	Update  *PersonUpdateWithoutIdentificationDataInput `json:"update,omitempty"`
	Upsert  *PersonUpsertWithoutIdentificationInput     `json:"upsert,omitempty"`
	Connect *PersonWhereUniqueInput                     `json:"connect,omitempty"`
}

type TravelerUpdateWithoutCardsDataInput struct {
	Person   *PersonUpdateOneRequiredInput `json:"person,omitempty"`
	Username *string                       `json:"username,omitempty"`
	Tickets  *TicketUpdateManyInput        `json:"tickets,omitempty"`
}

type EmailChannelUpdateManyMutationInput struct {
	DisplayName *string                        `json:"displayName,omitempty"`
	Valid       *bool                          `json:"valid,omitempty"`
	Value       *string                        `json:"value,omitempty"`
	Extras      *EmailChannelUpdateextrasInput `json:"extras,omitempty"`
}

type TicketUpdateManyInput struct {
	Create     []TicketCreateInput                      `json:"create,omitempty"`
	Update     []TicketUpdateWithWhereUniqueNestedInput `json:"update,omitempty"`
	Upsert     []TicketUpsertWithWhereUniqueNestedInput `json:"upsert,omitempty"`
	Delete     []TicketWhereUniqueInput                 `json:"delete,omitempty"`
	Connect    []TicketWhereUniqueInput                 `json:"connect,omitempty"`
	Set        []TicketWhereUniqueInput                 `json:"set,omitempty"`
	Disconnect []TicketWhereUniqueInput                 `json:"disconnect,omitempty"`
	DeleteMany []TicketScalarWhereInput                 `json:"deleteMany,omitempty"`
	UpdateMany []TicketUpdateManyWithWhereNestedInput   `json:"updateMany,omitempty"`
}

type PaymentEntryScalarWhereInput struct {
	ID                           *string                        `json:"id,omitempty"`
	IDNot                        *string                        `json:"id_not,omitempty"`
	IDIn                         []string                       `json:"id_in,omitempty"`
	IDNotIn                      []string                       `json:"id_not_in,omitempty"`
	IDLt                         *string                        `json:"id_lt,omitempty"`
	IDLte                        *string                        `json:"id_lte,omitempty"`
	IDGt                         *string                        `json:"id_gt,omitempty"`
	IDGte                        *string                        `json:"id_gte,omitempty"`
	IDContains                   *string                        `json:"id_contains,omitempty"`
	IDNotContains                *string                        `json:"id_not_contains,omitempty"`
	IDStartsWith                 *string                        `json:"id_starts_with,omitempty"`
	IDNotStartsWith              *string                        `json:"id_not_starts_with,omitempty"`
	IDEndsWith                   *string                        `json:"id_ends_with,omitempty"`
	IDNotEndsWith                *string                        `json:"id_not_ends_with,omitempty"`
	CreatedAt                    *string                        `json:"createdAt,omitempty"`
	CreatedAtNot                 *string                        `json:"createdAt_not,omitempty"`
	CreatedAtIn                  []string                       `json:"createdAt_in,omitempty"`
	CreatedAtNotIn               []string                       `json:"createdAt_not_in,omitempty"`
	CreatedAtLt                  *string                        `json:"createdAt_lt,omitempty"`
	CreatedAtLte                 *string                        `json:"createdAt_lte,omitempty"`
	CreatedAtGt                  *string                        `json:"createdAt_gt,omitempty"`
	CreatedAtGte                 *string                        `json:"createdAt_gte,omitempty"`
	UpdatedAt                    *string                        `json:"updatedAt,omitempty"`
	UpdatedAtNot                 *string                        `json:"updatedAt_not,omitempty"`
	UpdatedAtIn                  []string                       `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn               []string                       `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt                  *string                        `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte                 *string                        `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt                  *string                        `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte                 *string                        `json:"updatedAt_gte,omitempty"`
	ExternalId                   *string                        `json:"externalID,omitempty"`
	ExternalIdNot                *string                        `json:"externalID_not,omitempty"`
	ExternalIdIn                 []string                       `json:"externalID_in,omitempty"`
	ExternalIdNotIn              []string                       `json:"externalID_not_in,omitempty"`
	ExternalIdLt                 *string                        `json:"externalID_lt,omitempty"`
	ExternalIdLte                *string                        `json:"externalID_lte,omitempty"`
	ExternalIdGt                 *string                        `json:"externalID_gt,omitempty"`
	ExternalIdGte                *string                        `json:"externalID_gte,omitempty"`
	ExternalIdContains           *string                        `json:"externalID_contains,omitempty"`
	ExternalIdNotContains        *string                        `json:"externalID_not_contains,omitempty"`
	ExternalIdStartsWith         *string                        `json:"externalID_starts_with,omitempty"`
	ExternalIdNotStartsWith      *string                        `json:"externalID_not_starts_with,omitempty"`
	ExternalIdEndsWith           *string                        `json:"externalID_ends_with,omitempty"`
	ExternalIdNotEndsWith        *string                        `json:"externalID_not_ends_with,omitempty"`
	ProductId                    *string                        `json:"productID,omitempty"`
	ProductIdNot                 *string                        `json:"productID_not,omitempty"`
	ProductIdIn                  []string                       `json:"productID_in,omitempty"`
	ProductIdNotIn               []string                       `json:"productID_not_in,omitempty"`
	ProductIdLt                  *string                        `json:"productID_lt,omitempty"`
	ProductIdLte                 *string                        `json:"productID_lte,omitempty"`
	ProductIdGt                  *string                        `json:"productID_gt,omitempty"`
	ProductIdGte                 *string                        `json:"productID_gte,omitempty"`
	ProductIdContains            *string                        `json:"productID_contains,omitempty"`
	ProductIdNotContains         *string                        `json:"productID_not_contains,omitempty"`
	ProductIdStartsWith          *string                        `json:"productID_starts_with,omitempty"`
	ProductIdNotStartsWith       *string                        `json:"productID_not_starts_with,omitempty"`
	ProductIdEndsWith            *string                        `json:"productID_ends_with,omitempty"`
	ProductIdNotEndsWith         *string                        `json:"productID_not_ends_with,omitempty"`
	Product                      *string                        `json:"product,omitempty"`
	ProductNot                   *string                        `json:"product_not,omitempty"`
	ProductIn                    []string                       `json:"product_in,omitempty"`
	ProductNotIn                 []string                       `json:"product_not_in,omitempty"`
	ProductLt                    *string                        `json:"product_lt,omitempty"`
	ProductLte                   *string                        `json:"product_lte,omitempty"`
	ProductGt                    *string                        `json:"product_gt,omitempty"`
	ProductGte                   *string                        `json:"product_gte,omitempty"`
	ProductContains              *string                        `json:"product_contains,omitempty"`
	ProductNotContains           *string                        `json:"product_not_contains,omitempty"`
	ProductStartsWith            *string                        `json:"product_starts_with,omitempty"`
	ProductNotStartsWith         *string                        `json:"product_not_starts_with,omitempty"`
	ProductEndsWith              *string                        `json:"product_ends_with,omitempty"`
	ProductNotEndsWith           *string                        `json:"product_not_ends_with,omitempty"`
	GatewayResponse              *string                        `json:"gatewayResponse,omitempty"`
	GatewayResponseNot           *string                        `json:"gatewayResponse_not,omitempty"`
	GatewayResponseIn            []string                       `json:"gatewayResponse_in,omitempty"`
	GatewayResponseNotIn         []string                       `json:"gatewayResponse_not_in,omitempty"`
	GatewayResponseLt            *string                        `json:"gatewayResponse_lt,omitempty"`
	GatewayResponseLte           *string                        `json:"gatewayResponse_lte,omitempty"`
	GatewayResponseGt            *string                        `json:"gatewayResponse_gt,omitempty"`
	GatewayResponseGte           *string                        `json:"gatewayResponse_gte,omitempty"`
	GatewayResponseContains      *string                        `json:"gatewayResponse_contains,omitempty"`
	GatewayResponseNotContains   *string                        `json:"gatewayResponse_not_contains,omitempty"`
	GatewayResponseStartsWith    *string                        `json:"gatewayResponse_starts_with,omitempty"`
	GatewayResponseNotStartsWith *string                        `json:"gatewayResponse_not_starts_with,omitempty"`
	GatewayResponseEndsWith      *string                        `json:"gatewayResponse_ends_with,omitempty"`
	GatewayResponseNotEndsWith   *string                        `json:"gatewayResponse_not_ends_with,omitempty"`
	Amount                       *int32                         `json:"amount,omitempty"`
	AmountNot                    *int32                         `json:"amount_not,omitempty"`
	AmountIn                     []int32                        `json:"amount_in,omitempty"`
	AmountNotIn                  []int32                        `json:"amount_not_in,omitempty"`
	AmountLt                     *int32                         `json:"amount_lt,omitempty"`
	AmountLte                    *int32                         `json:"amount_lte,omitempty"`
	AmountGt                     *int32                         `json:"amount_gt,omitempty"`
	AmountGte                    *int32                         `json:"amount_gte,omitempty"`
	DiscountId                   *string                        `json:"discountID,omitempty"`
	DiscountIdNot                *string                        `json:"discountID_not,omitempty"`
	DiscountIdIn                 []string                       `json:"discountID_in,omitempty"`
	DiscountIdNotIn              []string                       `json:"discountID_not_in,omitempty"`
	DiscountIdLt                 *string                        `json:"discountID_lt,omitempty"`
	DiscountIdLte                *string                        `json:"discountID_lte,omitempty"`
	DiscountIdGt                 *string                        `json:"discountID_gt,omitempty"`
	DiscountIdGte                *string                        `json:"discountID_gte,omitempty"`
	DiscountIdContains           *string                        `json:"discountID_contains,omitempty"`
	DiscountIdNotContains        *string                        `json:"discountID_not_contains,omitempty"`
	DiscountIdStartsWith         *string                        `json:"discountID_starts_with,omitempty"`
	DiscountIdNotStartsWith      *string                        `json:"discountID_not_starts_with,omitempty"`
	DiscountIdEndsWith           *string                        `json:"discountID_ends_with,omitempty"`
	DiscountIdNotEndsWith        *string                        `json:"discountID_not_ends_with,omitempty"`
	Discount                     *int32                         `json:"discount,omitempty"`
	DiscountNot                  *int32                         `json:"discount_not,omitempty"`
	DiscountIn                   []int32                        `json:"discount_in,omitempty"`
	DiscountNotIn                []int32                        `json:"discount_not_in,omitempty"`
	DiscountLt                   *int32                         `json:"discount_lt,omitempty"`
	DiscountLte                  *int32                         `json:"discount_lte,omitempty"`
	DiscountGt                   *int32                         `json:"discount_gt,omitempty"`
	DiscountGte                  *int32                         `json:"discount_gte,omitempty"`
	And                          []PaymentEntryScalarWhereInput `json:"AND,omitempty"`
	Or                           []PaymentEntryScalarWhereInput `json:"OR,omitempty"`
	Not                          []PaymentEntryScalarWhereInput `json:"NOT,omitempty"`
}

type TicketUpdateWithWhereUniqueNestedInput struct {
	Where TicketWhereUniqueInput `json:"where"`
	Data  TicketUpdateDataInput  `json:"data"`
}

type AttractionCreateInput struct {
	Owner      PartnerCreateOneWithoutAttractionsInput `json:"owner"`
	Overview   OverviewCreateOneInput                  `json:"overview"`
	MaxUses    *int32                                  `json:"maxUses,omitempty"`
	Address    string                                  `json:"address"`
	Location   LocationCreateOneInput                  `json:"location"`
	Popularity *float64                                `json:"popularity,omitempty"`
	LikedBy    *PersonCreateManyInput                  `json:"likedBy,omitempty"`
	Types      *AttractionCreatetypesInput             `json:"types,omitempty"`
	Tags       *AttractionCreatetagsInput              `json:"tags,omitempty"`
	Reviews    *PersonReviewsCreateManyInput           `json:"reviews,omitempty"`
	Details    *DetailsCreateOneInput                  `json:"details,omitempty"`
}

type TicketUpdateDataInput struct {
	Type     *TicketTypeUpdateOneRequiredInput   `json:"type,omitempty"`
	Owner    *PersonUpdateOneRequiredInput       `json:"owner,omitempty"`
	Receive  *PaymentEntryUpdateOneRequiredInput `json:"receive,omitempty"`
	ExpireAt *string                             `json:"expireAt,omitempty"`
	Visited  *AttractionUpdateManyInput          `json:"visited,omitempty"`
}

type EmailChannelCreateInput struct {
	DisplayName string                         `json:"displayName"`
	Valid       *bool                          `json:"valid,omitempty"`
	Value       string                         `json:"value"`
	Extras      *EmailChannelCreateextrasInput `json:"extras,omitempty"`
}

type TicketTypeUpdateOneRequiredInput struct {
	Create  *TicketTypeCreateInput       `json:"create,omitempty"`
	Update  *TicketTypeUpdateDataInput   `json:"update,omitempty"`
	Upsert  *TicketTypeUpsertNestedInput `json:"upsert,omitempty"`
	Connect *TicketTypeWhereUniqueInput  `json:"connect,omitempty"`
}

type LocationCreateInput struct {
	Longitude   float64 `json:"longitude"`
	Latitude    float64 `json:"latitude"`
	Description *string `json:"description,omitempty"`
}

type TicketTypeUpdateDataInput struct {
	CreatorId   *string                    `json:"creatorID,omitempty"`
	Attractions *AttractionUpdateManyInput `json:"attractions,omitempty"`
	Cost        *float64                   `json:"cost,omitempty"`
}

type PersonReviewsSubscriptionWhereInput struct {
	MutationIn                 []MutationType                        `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                               `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                              `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                              `json:"updatedFields_contains_some,omitempty"`
	Node                       *PersonReviewsWhereInput              `json:"node,omitempty"`
	And                        []PersonReviewsSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []PersonReviewsSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []PersonReviewsSubscriptionWhereInput `json:"NOT,omitempty"`
}

type AttractionUpdateManyInput struct {
	Create     []AttractionCreateInput                      `json:"create,omitempty"`
	Update     []AttractionUpdateWithWhereUniqueNestedInput `json:"update,omitempty"`
	Upsert     []AttractionUpsertWithWhereUniqueNestedInput `json:"upsert,omitempty"`
	Delete     []AttractionWhereUniqueInput                 `json:"delete,omitempty"`
	Connect    []AttractionWhereUniqueInput                 `json:"connect,omitempty"`
	Set        []AttractionWhereUniqueInput                 `json:"set,omitempty"`
	Disconnect []AttractionWhereUniqueInput                 `json:"disconnect,omitempty"`
	DeleteMany []AttractionScalarWhereInput                 `json:"deleteMany,omitempty"`
	UpdateMany []AttractionUpdateManyWithWhereNestedInput   `json:"updateMany,omitempty"`
}

type TicketTypeWhereInput struct {
	ID                     *string                `json:"id,omitempty"`
	IDNot                  *string                `json:"id_not,omitempty"`
	IDIn                   []string               `json:"id_in,omitempty"`
	IDNotIn                []string               `json:"id_not_in,omitempty"`
	IDLt                   *string                `json:"id_lt,omitempty"`
	IDLte                  *string                `json:"id_lte,omitempty"`
	IDGt                   *string                `json:"id_gt,omitempty"`
	IDGte                  *string                `json:"id_gte,omitempty"`
	IDContains             *string                `json:"id_contains,omitempty"`
	IDNotContains          *string                `json:"id_not_contains,omitempty"`
	IDStartsWith           *string                `json:"id_starts_with,omitempty"`
	IDNotStartsWith        *string                `json:"id_not_starts_with,omitempty"`
	IDEndsWith             *string                `json:"id_ends_with,omitempty"`
	IDNotEndsWith          *string                `json:"id_not_ends_with,omitempty"`
	CreatedAt              *string                `json:"createdAt,omitempty"`
	CreatedAtNot           *string                `json:"createdAt_not,omitempty"`
	CreatedAtIn            []string               `json:"createdAt_in,omitempty"`
	CreatedAtNotIn         []string               `json:"createdAt_not_in,omitempty"`
	CreatedAtLt            *string                `json:"createdAt_lt,omitempty"`
	CreatedAtLte           *string                `json:"createdAt_lte,omitempty"`
	CreatedAtGt            *string                `json:"createdAt_gt,omitempty"`
	CreatedAtGte           *string                `json:"createdAt_gte,omitempty"`
	UpdatedAt              *string                `json:"updatedAt,omitempty"`
	UpdatedAtNot           *string                `json:"updatedAt_not,omitempty"`
	UpdatedAtIn            []string               `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn         []string               `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt            *string                `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte           *string                `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt            *string                `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte           *string                `json:"updatedAt_gte,omitempty"`
	CreatorId              *string                `json:"creatorID,omitempty"`
	CreatorIdNot           *string                `json:"creatorID_not,omitempty"`
	CreatorIdIn            []string               `json:"creatorID_in,omitempty"`
	CreatorIdNotIn         []string               `json:"creatorID_not_in,omitempty"`
	CreatorIdLt            *string                `json:"creatorID_lt,omitempty"`
	CreatorIdLte           *string                `json:"creatorID_lte,omitempty"`
	CreatorIdGt            *string                `json:"creatorID_gt,omitempty"`
	CreatorIdGte           *string                `json:"creatorID_gte,omitempty"`
	CreatorIdContains      *string                `json:"creatorID_contains,omitempty"`
	CreatorIdNotContains   *string                `json:"creatorID_not_contains,omitempty"`
	CreatorIdStartsWith    *string                `json:"creatorID_starts_with,omitempty"`
	CreatorIdNotStartsWith *string                `json:"creatorID_not_starts_with,omitempty"`
	CreatorIdEndsWith      *string                `json:"creatorID_ends_with,omitempty"`
	CreatorIdNotEndsWith   *string                `json:"creatorID_not_ends_with,omitempty"`
	AttractionsEvery       *AttractionWhereInput  `json:"attractions_every,omitempty"`
	AttractionsSome        *AttractionWhereInput  `json:"attractions_some,omitempty"`
	AttractionsNone        *AttractionWhereInput  `json:"attractions_none,omitempty"`
	Cost                   *float64               `json:"cost,omitempty"`
	CostNot                *float64               `json:"cost_not,omitempty"`
	CostIn                 []float64              `json:"cost_in,omitempty"`
	CostNotIn              []float64              `json:"cost_not_in,omitempty"`
	CostLt                 *float64               `json:"cost_lt,omitempty"`
	CostLte                *float64               `json:"cost_lte,omitempty"`
	CostGt                 *float64               `json:"cost_gt,omitempty"`
	CostGte                *float64               `json:"cost_gte,omitempty"`
	And                    []TicketTypeWhereInput `json:"AND,omitempty"`
	Or                     []TicketTypeWhereInput `json:"OR,omitempty"`
	Not                    []TicketTypeWhereInput `json:"NOT,omitempty"`
}

type AttractionUpdateWithWhereUniqueNestedInput struct {
	Where AttractionWhereUniqueInput `json:"where"`
	Data  AttractionUpdateDataInput  `json:"data"`
}

type EmailChannelWhereUniqueInput struct {
	ID *string `json:"id,omitempty"`
}

type AttractionUpdateDataInput struct {
	Owner      *PartnerUpdateOneRequiredWithoutAttractionsInput `json:"owner,omitempty"`
	Overview   *OverviewUpdateOneRequiredInput                  `json:"overview,omitempty"`
	MaxUses    *int32                                           `json:"maxUses,omitempty"`
	Address    *string                                          `json:"address,omitempty"`
	Location   *LocationUpdateOneRequiredInput                  `json:"location,omitempty"`
	Popularity *float64                                         `json:"popularity,omitempty"`
	LikedBy    *PersonUpdateManyInput                           `json:"likedBy,omitempty"`
	Types      *AttractionUpdatetypesInput                      `json:"types,omitempty"`
	Tags       *AttractionUpdatetagsInput                       `json:"tags,omitempty"`
	Reviews    *PersonReviewsUpdateManyInput                    `json:"reviews,omitempty"`
	Details    *DetailsUpdateOneInput                           `json:"details,omitempty"`
}

type PhoneChannelWhereInput struct {
	ID                       *string                  `json:"id,omitempty"`
	IDNot                    *string                  `json:"id_not,omitempty"`
	IDIn                     []string                 `json:"id_in,omitempty"`
	IDNotIn                  []string                 `json:"id_not_in,omitempty"`
	IDLt                     *string                  `json:"id_lt,omitempty"`
	IDLte                    *string                  `json:"id_lte,omitempty"`
	IDGt                     *string                  `json:"id_gt,omitempty"`
	IDGte                    *string                  `json:"id_gte,omitempty"`
	IDContains               *string                  `json:"id_contains,omitempty"`
	IDNotContains            *string                  `json:"id_not_contains,omitempty"`
	IDStartsWith             *string                  `json:"id_starts_with,omitempty"`
	IDNotStartsWith          *string                  `json:"id_not_starts_with,omitempty"`
	IDEndsWith               *string                  `json:"id_ends_with,omitempty"`
	IDNotEndsWith            *string                  `json:"id_not_ends_with,omitempty"`
	CreatedAt                *string                  `json:"createdAt,omitempty"`
	CreatedAtNot             *string                  `json:"createdAt_not,omitempty"`
	CreatedAtIn              []string                 `json:"createdAt_in,omitempty"`
	CreatedAtNotIn           []string                 `json:"createdAt_not_in,omitempty"`
	CreatedAtLt              *string                  `json:"createdAt_lt,omitempty"`
	CreatedAtLte             *string                  `json:"createdAt_lte,omitempty"`
	CreatedAtGt              *string                  `json:"createdAt_gt,omitempty"`
	CreatedAtGte             *string                  `json:"createdAt_gte,omitempty"`
	UpdatedAt                *string                  `json:"updatedAt,omitempty"`
	UpdatedAtNot             *string                  `json:"updatedAt_not,omitempty"`
	UpdatedAtIn              []string                 `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn           []string                 `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt              *string                  `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte             *string                  `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt              *string                  `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte             *string                  `json:"updatedAt_gte,omitempty"`
	DisplayName              *string                  `json:"displayName,omitempty"`
	DisplayNameNot           *string                  `json:"displayName_not,omitempty"`
	DisplayNameIn            []string                 `json:"displayName_in,omitempty"`
	DisplayNameNotIn         []string                 `json:"displayName_not_in,omitempty"`
	DisplayNameLt            *string                  `json:"displayName_lt,omitempty"`
	DisplayNameLte           *string                  `json:"displayName_lte,omitempty"`
	DisplayNameGt            *string                  `json:"displayName_gt,omitempty"`
	DisplayNameGte           *string                  `json:"displayName_gte,omitempty"`
	DisplayNameContains      *string                  `json:"displayName_contains,omitempty"`
	DisplayNameNotContains   *string                  `json:"displayName_not_contains,omitempty"`
	DisplayNameStartsWith    *string                  `json:"displayName_starts_with,omitempty"`
	DisplayNameNotStartsWith *string                  `json:"displayName_not_starts_with,omitempty"`
	DisplayNameEndsWith      *string                  `json:"displayName_ends_with,omitempty"`
	DisplayNameNotEndsWith   *string                  `json:"displayName_not_ends_with,omitempty"`
	Valid                    *bool                    `json:"valid,omitempty"`
	ValidNot                 *bool                    `json:"valid_not,omitempty"`
	CountryCode              *string                  `json:"countryCode,omitempty"`
	CountryCodeNot           *string                  `json:"countryCode_not,omitempty"`
	CountryCodeIn            []string                 `json:"countryCode_in,omitempty"`
	CountryCodeNotIn         []string                 `json:"countryCode_not_in,omitempty"`
	CountryCodeLt            *string                  `json:"countryCode_lt,omitempty"`
	CountryCodeLte           *string                  `json:"countryCode_lte,omitempty"`
	CountryCodeGt            *string                  `json:"countryCode_gt,omitempty"`
	CountryCodeGte           *string                  `json:"countryCode_gte,omitempty"`
	CountryCodeContains      *string                  `json:"countryCode_contains,omitempty"`
	CountryCodeNotContains   *string                  `json:"countryCode_not_contains,omitempty"`
	CountryCodeStartsWith    *string                  `json:"countryCode_starts_with,omitempty"`
	CountryCodeNotStartsWith *string                  `json:"countryCode_not_starts_with,omitempty"`
	CountryCodeEndsWith      *string                  `json:"countryCode_ends_with,omitempty"`
	CountryCodeNotEndsWith   *string                  `json:"countryCode_not_ends_with,omitempty"`
	Number                   *string                  `json:"number,omitempty"`
	NumberNot                *string                  `json:"number_not,omitempty"`
	NumberIn                 []string                 `json:"number_in,omitempty"`
	NumberNotIn              []string                 `json:"number_not_in,omitempty"`
	NumberLt                 *string                  `json:"number_lt,omitempty"`
	NumberLte                *string                  `json:"number_lte,omitempty"`
	NumberGt                 *string                  `json:"number_gt,omitempty"`
	NumberGte                *string                  `json:"number_gte,omitempty"`
	NumberContains           *string                  `json:"number_contains,omitempty"`
	NumberNotContains        *string                  `json:"number_not_contains,omitempty"`
	NumberStartsWith         *string                  `json:"number_starts_with,omitempty"`
	NumberNotStartsWith      *string                  `json:"number_not_starts_with,omitempty"`
	NumberEndsWith           *string                  `json:"number_ends_with,omitempty"`
	NumberNotEndsWith        *string                  `json:"number_not_ends_with,omitempty"`
	And                      []PhoneChannelWhereInput `json:"AND,omitempty"`
	Or                       []PhoneChannelWhereInput `json:"OR,omitempty"`
	Not                      []PhoneChannelWhereInput `json:"NOT,omitempty"`
}

type AttractionUpsertWithWhereUniqueNestedInput struct {
	Where  AttractionWhereUniqueInput `json:"where"`
	Update AttractionUpdateDataInput  `json:"update"`
	Create AttractionCreateInput      `json:"create"`
}

type IDentificationDocumentUpdateManyMutationInput struct {
	Type      *IDentificationType `json:"type,omitempty"`
	Value     *string             `json:"value,omitempty"`
	Validated *bool               `json:"validated,omitempty"`
}

type AttractionScalarWhereInput struct {
	ID                   *string                      `json:"id,omitempty"`
	IDNot                *string                      `json:"id_not,omitempty"`
	IDIn                 []string                     `json:"id_in,omitempty"`
	IDNotIn              []string                     `json:"id_not_in,omitempty"`
	IDLt                 *string                      `json:"id_lt,omitempty"`
	IDLte                *string                      `json:"id_lte,omitempty"`
	IDGt                 *string                      `json:"id_gt,omitempty"`
	IDGte                *string                      `json:"id_gte,omitempty"`
	IDContains           *string                      `json:"id_contains,omitempty"`
	IDNotContains        *string                      `json:"id_not_contains,omitempty"`
	IDStartsWith         *string                      `json:"id_starts_with,omitempty"`
	IDNotStartsWith      *string                      `json:"id_not_starts_with,omitempty"`
	IDEndsWith           *string                      `json:"id_ends_with,omitempty"`
	IDNotEndsWith        *string                      `json:"id_not_ends_with,omitempty"`
	CreatedAt            *string                      `json:"createdAt,omitempty"`
	CreatedAtNot         *string                      `json:"createdAt_not,omitempty"`
	CreatedAtIn          []string                     `json:"createdAt_in,omitempty"`
	CreatedAtNotIn       []string                     `json:"createdAt_not_in,omitempty"`
	CreatedAtLt          *string                      `json:"createdAt_lt,omitempty"`
	CreatedAtLte         *string                      `json:"createdAt_lte,omitempty"`
	CreatedAtGt          *string                      `json:"createdAt_gt,omitempty"`
	CreatedAtGte         *string                      `json:"createdAt_gte,omitempty"`
	UpdatedAt            *string                      `json:"updatedAt,omitempty"`
	UpdatedAtNot         *string                      `json:"updatedAt_not,omitempty"`
	UpdatedAtIn          []string                     `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn       []string                     `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt          *string                      `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte         *string                      `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt          *string                      `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte         *string                      `json:"updatedAt_gte,omitempty"`
	MaxUses              *int32                       `json:"maxUses,omitempty"`
	MaxUsesNot           *int32                       `json:"maxUses_not,omitempty"`
	MaxUsesIn            []int32                      `json:"maxUses_in,omitempty"`
	MaxUsesNotIn         []int32                      `json:"maxUses_not_in,omitempty"`
	MaxUsesLt            *int32                       `json:"maxUses_lt,omitempty"`
	MaxUsesLte           *int32                       `json:"maxUses_lte,omitempty"`
	MaxUsesGt            *int32                       `json:"maxUses_gt,omitempty"`
	MaxUsesGte           *int32                       `json:"maxUses_gte,omitempty"`
	Address              *string                      `json:"address,omitempty"`
	AddressNot           *string                      `json:"address_not,omitempty"`
	AddressIn            []string                     `json:"address_in,omitempty"`
	AddressNotIn         []string                     `json:"address_not_in,omitempty"`
	AddressLt            *string                      `json:"address_lt,omitempty"`
	AddressLte           *string                      `json:"address_lte,omitempty"`
	AddressGt            *string                      `json:"address_gt,omitempty"`
	AddressGte           *string                      `json:"address_gte,omitempty"`
	AddressContains      *string                      `json:"address_contains,omitempty"`
	AddressNotContains   *string                      `json:"address_not_contains,omitempty"`
	AddressStartsWith    *string                      `json:"address_starts_with,omitempty"`
	AddressNotStartsWith *string                      `json:"address_not_starts_with,omitempty"`
	AddressEndsWith      *string                      `json:"address_ends_with,omitempty"`
	AddressNotEndsWith   *string                      `json:"address_not_ends_with,omitempty"`
	Popularity           *float64                     `json:"popularity,omitempty"`
	PopularityNot        *float64                     `json:"popularity_not,omitempty"`
	PopularityIn         []float64                    `json:"popularity_in,omitempty"`
	PopularityNotIn      []float64                    `json:"popularity_not_in,omitempty"`
	PopularityLt         *float64                     `json:"popularity_lt,omitempty"`
	PopularityLte        *float64                     `json:"popularity_lte,omitempty"`
	PopularityGt         *float64                     `json:"popularity_gt,omitempty"`
	PopularityGte        *float64                     `json:"popularity_gte,omitempty"`
	And                  []AttractionScalarWhereInput `json:"AND,omitempty"`
	Or                   []AttractionScalarWhereInput `json:"OR,omitempty"`
	Not                  []AttractionScalarWhereInput `json:"NOT,omitempty"`
}

type CreditCardUpdateManyMutationInput struct {
	CardNumber *string         `json:"cardNumber,omitempty"`
	CardToken  *string         `json:"cardToken,omitempty"`
	Type       *CreditCardType `json:"type,omitempty"`
	LastUsed   *string         `json:"lastUsed,omitempty"`
}

type AttractionUpdateManyWithWhereNestedInput struct {
	Where AttractionScalarWhereInput    `json:"where"`
	Data  AttractionUpdateManyDataInput `json:"data"`
}

type PersonCreateInput struct {
	MId            *string                                           `json:"mID,omitempty"`
	Name           string                                            `json:"name"`
	Photo          *string                                           `json:"photo,omitempty"`
	Birthday       string                                            `json:"birthday"`
	From           *string                                           `json:"from,omitempty"`
	ChannelsPhone  *PhoneChannelCreateManyInput                      `json:"channelsPhone,omitempty"`
	ChannelsEmail  *EmailChannelCreateManyInput                      `json:"channelsEmail,omitempty"`
	IDentification IDentificationDocumentCreateOneWithoutPersonInput `json:"identification"`
	Tags           *PersonCreatetagsInput                            `json:"tags,omitempty"`
	Credentials    *CredentialCreateManyWithoutOwnerInput            `json:"credentials,omitempty"`
}

type AttractionUpdateManyDataInput struct {
	MaxUses    *int32                      `json:"maxUses,omitempty"`
	Address    *string                     `json:"address,omitempty"`
	Popularity *float64                    `json:"popularity,omitempty"`
	Types      *AttractionUpdatetypesInput `json:"types,omitempty"`
	Tags       *AttractionUpdatetagsInput  `json:"tags,omitempty"`
}

type OpeningHoursCreateInput struct {
	From string `json:"from"`
	To   string `json:"to"`
}

type TicketTypeUpsertNestedInput struct {
	Update TicketTypeUpdateDataInput `json:"update"`
	Create TicketTypeCreateInput     `json:"create"`
}

type EmailChannelWhereInput struct {
	ID                       *string                  `json:"id,omitempty"`
	IDNot                    *string                  `json:"id_not,omitempty"`
	IDIn                     []string                 `json:"id_in,omitempty"`
	IDNotIn                  []string                 `json:"id_not_in,omitempty"`
	IDLt                     *string                  `json:"id_lt,omitempty"`
	IDLte                    *string                  `json:"id_lte,omitempty"`
	IDGt                     *string                  `json:"id_gt,omitempty"`
	IDGte                    *string                  `json:"id_gte,omitempty"`
	IDContains               *string                  `json:"id_contains,omitempty"`
	IDNotContains            *string                  `json:"id_not_contains,omitempty"`
	IDStartsWith             *string                  `json:"id_starts_with,omitempty"`
	IDNotStartsWith          *string                  `json:"id_not_starts_with,omitempty"`
	IDEndsWith               *string                  `json:"id_ends_with,omitempty"`
	IDNotEndsWith            *string                  `json:"id_not_ends_with,omitempty"`
	CreatedAt                *string                  `json:"createdAt,omitempty"`
	CreatedAtNot             *string                  `json:"createdAt_not,omitempty"`
	CreatedAtIn              []string                 `json:"createdAt_in,omitempty"`
	CreatedAtNotIn           []string                 `json:"createdAt_not_in,omitempty"`
	CreatedAtLt              *string                  `json:"createdAt_lt,omitempty"`
	CreatedAtLte             *string                  `json:"createdAt_lte,omitempty"`
	CreatedAtGt              *string                  `json:"createdAt_gt,omitempty"`
	CreatedAtGte             *string                  `json:"createdAt_gte,omitempty"`
	UpdatedAt                *string                  `json:"updatedAt,omitempty"`
	UpdatedAtNot             *string                  `json:"updatedAt_not,omitempty"`
	UpdatedAtIn              []string                 `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn           []string                 `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt              *string                  `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte             *string                  `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt              *string                  `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte             *string                  `json:"updatedAt_gte,omitempty"`
	DisplayName              *string                  `json:"displayName,omitempty"`
	DisplayNameNot           *string                  `json:"displayName_not,omitempty"`
	DisplayNameIn            []string                 `json:"displayName_in,omitempty"`
	DisplayNameNotIn         []string                 `json:"displayName_not_in,omitempty"`
	DisplayNameLt            *string                  `json:"displayName_lt,omitempty"`
	DisplayNameLte           *string                  `json:"displayName_lte,omitempty"`
	DisplayNameGt            *string                  `json:"displayName_gt,omitempty"`
	DisplayNameGte           *string                  `json:"displayName_gte,omitempty"`
	DisplayNameContains      *string                  `json:"displayName_contains,omitempty"`
	DisplayNameNotContains   *string                  `json:"displayName_not_contains,omitempty"`
	DisplayNameStartsWith    *string                  `json:"displayName_starts_with,omitempty"`
	DisplayNameNotStartsWith *string                  `json:"displayName_not_starts_with,omitempty"`
	DisplayNameEndsWith      *string                  `json:"displayName_ends_with,omitempty"`
	DisplayNameNotEndsWith   *string                  `json:"displayName_not_ends_with,omitempty"`
	Valid                    *bool                    `json:"valid,omitempty"`
	ValidNot                 *bool                    `json:"valid_not,omitempty"`
	Value                    *string                  `json:"value,omitempty"`
	ValueNot                 *string                  `json:"value_not,omitempty"`
	ValueIn                  []string                 `json:"value_in,omitempty"`
	ValueNotIn               []string                 `json:"value_not_in,omitempty"`
	ValueLt                  *string                  `json:"value_lt,omitempty"`
	ValueLte                 *string                  `json:"value_lte,omitempty"`
	ValueGt                  *string                  `json:"value_gt,omitempty"`
	ValueGte                 *string                  `json:"value_gte,omitempty"`
	ValueContains            *string                  `json:"value_contains,omitempty"`
	ValueNotContains         *string                  `json:"value_not_contains,omitempty"`
	ValueStartsWith          *string                  `json:"value_starts_with,omitempty"`
	ValueNotStartsWith       *string                  `json:"value_not_starts_with,omitempty"`
	ValueEndsWith            *string                  `json:"value_ends_with,omitempty"`
	ValueNotEndsWith         *string                  `json:"value_not_ends_with,omitempty"`
	And                      []EmailChannelWhereInput `json:"AND,omitempty"`
	Or                       []EmailChannelWhereInput `json:"OR,omitempty"`
	Not                      []EmailChannelWhereInput `json:"NOT,omitempty"`
}

type PaymentEntryUpdateOneRequiredInput struct {
	Create  *PaymentEntryCreateInput       `json:"create,omitempty"`
	Update  *PaymentEntryUpdateDataInput   `json:"update,omitempty"`
	Upsert  *PaymentEntryUpsertNestedInput `json:"upsert,omitempty"`
	Connect *PaymentEntryWhereUniqueInput  `json:"connect,omitempty"`
}

type PartnerWhereUniqueInput struct {
	ID *string `json:"id,omitempty"`
}

type CreditCardUpsertWithoutUsesInput struct {
	Update CreditCardUpdateWithoutUsesDataInput `json:"update"`
	Create CreditCardCreateWithoutUsesInput     `json:"create"`
}

type CreditCardUpdateWithoutUsesDataInput struct {
	Owner      *TravelerUpdateOneRequiredWithoutCardsInput `json:"owner,omitempty"`
	CardNumber *string                                     `json:"cardNumber,omitempty"`
	CardToken  *string                                     `json:"cardToken,omitempty"`
	Type       *CreditCardType                             `json:"type,omitempty"`
	LastUsed   *string                                     `json:"lastUsed,omitempty"`
}

type CreditCardUpdateOneRequiredWithoutUsesInput struct {
	Create  *CreditCardCreateWithoutUsesInput     `json:"create,omitempty"`
	Update  *CreditCardUpdateWithoutUsesDataInput `json:"update,omitempty"`
	Upsert  *CreditCardUpsertWithoutUsesInput     `json:"upsert,omitempty"`
	Connect *CreditCardWhereUniqueInput           `json:"connect,omitempty"`
}

type PaymentEntryUpdateDataInput struct {
	ExternalId      *string                                      `json:"externalID,omitempty"`
	WithCard        *CreditCardUpdateOneRequiredWithoutUsesInput `json:"withCard,omitempty"`
	ProductId       *string                                      `json:"productID,omitempty"`
	Product         *string                                      `json:"product,omitempty"`
	GatewayResponse *string                                      `json:"gatewayResponse,omitempty"`
	Amount          *int32                                       `json:"amount,omitempty"`
	DiscountId      *string                                      `json:"discountID,omitempty"`
	Discount        *int32                                       `json:"discount,omitempty"`
}

type PersonCreateOneWithoutIdentificationInput struct {
	Create  *PersonCreateWithoutIdentificationInput `json:"create,omitempty"`
	Connect *PersonWhereUniqueInput                 `json:"connect,omitempty"`
}

type TicketUpdateInput struct {
	Type     *TicketTypeUpdateOneRequiredInput   `json:"type,omitempty"`
	Owner    *PersonUpdateOneRequiredInput       `json:"owner,omitempty"`
	Receive  *PaymentEntryUpdateOneRequiredInput `json:"receive,omitempty"`
	ExpireAt *string                             `json:"expireAt,omitempty"`
	Visited  *AttractionUpdateManyInput          `json:"visited,omitempty"`
}

type IDentificationDocumentSubscriptionWhereInput struct {
	MutationIn                 []MutationType                                 `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                                        `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                                       `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                                       `json:"updatedFields_contains_some,omitempty"`
	Node                       *IDentificationDocumentWhereInput              `json:"node,omitempty"`
	And                        []IDentificationDocumentSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []IDentificationDocumentSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []IDentificationDocumentSubscriptionWhereInput `json:"NOT,omitempty"`
}

type PersonCreatetagsInput struct {
	Set []string `json:"set,omitempty"`
}

type PaymentEntryUpdateWithWhereUniqueWithoutWithCardInput struct {
	Where PaymentEntryWhereUniqueInput               `json:"where"`
	Data  PaymentEntryUpdateWithoutWithCardDataInput `json:"data"`
}

type TravelerPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance TravelerPreviousValuesExec) Exec(ctx context.Context) (*TravelerPreviousValues, error) {
	var v TravelerPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance TravelerPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type TravelerPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance TravelerPreviousValuesExecArray) Exec(ctx context.Context) ([]TravelerPreviousValues, error) {
	var v []TravelerPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type TravelerPreviousValues struct {
	ID        string `json:"id"`
	CreatedAt string `json:"createdAt"`
	UpdatedAt string `json:"updatedAt"`
	Username  string `json:"username"`
}

type CreditCardConnectionExec struct {
	exec *prisma.Exec
}

func (instance *CreditCardConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *CreditCardConnectionExec) Edges() *CreditCardEdgeExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "CreditCardEdge"},
		"edges",
		[]string{"cursor"})

	return &CreditCardEdgeExec{ret}
}

func (instance *CreditCardConnectionExec) Aggregate(ctx context.Context) (Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateCreditCard"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return v, err
}

func (instance CreditCardConnectionExec) Exec(ctx context.Context) (*CreditCardConnection, error) {
	var v CreditCardConnection
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance CreditCardConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type CreditCardConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance CreditCardConnectionExecArray) Exec(ctx context.Context) ([]CreditCardConnection, error) {
	var v []CreditCardConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type CreditCardConnection struct {
}

type LocationExec struct {
	exec *prisma.Exec
}

func (instance LocationExec) Exec(ctx context.Context) (*Location, error) {
	var v Location
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance LocationExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type LocationExecArray struct {
	exec *prisma.Exec
}

func (instance LocationExecArray) Exec(ctx context.Context) ([]Location, error) {
	var v []Location
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type Location struct {
	Longitude   float64 `json:"longitude"`
	Latitude    float64 `json:"latitude"`
	Description *string `json:"description,omitempty"`
}

type TicketPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance TicketPreviousValuesExec) Exec(ctx context.Context) (*TicketPreviousValues, error) {
	var v TicketPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance TicketPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type TicketPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance TicketPreviousValuesExecArray) Exec(ctx context.Context) ([]TicketPreviousValues, error) {
	var v []TicketPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type TicketPreviousValues struct {
	ID        string `json:"id"`
	CreatedAt string `json:"createdAt"`
	UpdatedAt string `json:"updatedAt"`
	ExpireAt  string `json:"expireAt"`
}

type CreditCardEdgeExec struct {
	exec *prisma.Exec
}

func (instance *CreditCardEdgeExec) Node() *CreditCardExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "CreditCard"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "cardNumber", "cardToken", "type", "lastUsed"})

	return &CreditCardExec{ret}
}

func (instance CreditCardEdgeExec) Exec(ctx context.Context) (*CreditCardEdge, error) {
	var v CreditCardEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance CreditCardEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type CreditCardEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance CreditCardEdgeExecArray) Exec(ctx context.Context) ([]CreditCardEdge, error) {
	var v []CreditCardEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type CreditCardEdge struct {
	Cursor string `json:"cursor"`
}

type PaymentEntryExec struct {
	exec *prisma.Exec
}

func (instance *PaymentEntryExec) WithCard() *CreditCardExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "CreditCard"},
		"withCard",
		[]string{"id", "createdAt", "updatedAt", "cardNumber", "cardToken", "type", "lastUsed"})

	return &CreditCardExec{ret}
}

func (instance PaymentEntryExec) Exec(ctx context.Context) (*PaymentEntry, error) {
	var v PaymentEntry
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance PaymentEntryExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type PaymentEntryExecArray struct {
	exec *prisma.Exec
}

func (instance PaymentEntryExecArray) Exec(ctx context.Context) ([]PaymentEntry, error) {
	var v []PaymentEntry
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type PaymentEntry struct {
	ID              string  `json:"id"`
	CreatedAt       string  `json:"createdAt"`
	UpdatedAt       string  `json:"updatedAt"`
	ExternalId      string  `json:"externalID"`
	ProductId       string  `json:"productID"`
	Product         string  `json:"product"`
	GatewayResponse *string `json:"gatewayResponse,omitempty"`
	Amount          int32   `json:"amount"`
	DiscountId      *string `json:"discountID,omitempty"`
	Discount        *int32  `json:"discount,omitempty"`
}

type TravelerEdgeExec struct {
	exec *prisma.Exec
}

func (instance *TravelerEdgeExec) Node() *TravelerExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Traveler"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "username"})

	return &TravelerExec{ret}
}

func (instance TravelerEdgeExec) Exec(ctx context.Context) (*TravelerEdge, error) {
	var v TravelerEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance TravelerEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type TravelerEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance TravelerEdgeExecArray) Exec(ctx context.Context) ([]TravelerEdge, error) {
	var v []TravelerEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type TravelerEdge struct {
	Cursor string `json:"cursor"`
}

type OpeningHoursExec struct {
	exec *prisma.Exec
}

func (instance OpeningHoursExec) Exec(ctx context.Context) (*OpeningHours, error) {
	var v OpeningHours
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance OpeningHoursExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type OpeningHoursExecArray struct {
	exec *prisma.Exec
}

func (instance OpeningHoursExecArray) Exec(ctx context.Context) ([]OpeningHours, error) {
	var v []OpeningHours
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type OpeningHours struct {
	From string `json:"from"`
	To   string `json:"to"`
}

type TravelerSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *TravelerSubscriptionPayloadExec) Node() *TravelerExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Traveler"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "username"})

	return &TravelerExec{ret}
}

func (instance *TravelerSubscriptionPayloadExec) PreviousValues() *TravelerPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "TravelerPreviousValues"},
		"previousValues",
		[]string{"id", "createdAt", "updatedAt", "username"})

	return &TravelerPreviousValuesExec{ret}
}

func (instance TravelerSubscriptionPayloadExec) Exec(ctx context.Context) (*TravelerSubscriptionPayload, error) {
	var v TravelerSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance TravelerSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type TravelerSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance TravelerSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]TravelerSubscriptionPayload, error) {
	var v []TravelerSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type TravelerSubscriptionPayload struct {
	Mutation      MutationType `json:"mutation"`
	UpdatedFields []string     `json:"updatedFields,omitempty"`
}

type TicketTypeExec struct {
	exec *prisma.Exec
}

type AttractionsParamsExec struct {
	Where   *AttractionWhereInput
	OrderBy *AttractionOrderByInput
	Skip    *int32
	After   *string
	Before  *string
	First   *int32
	Last    *int32
}

func (instance *TicketTypeExec) Attractions(params *AttractionsParamsExec) *AttractionExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := instance.exec.Client.GetMany(
		instance.exec,
		wparams,
		[3]string{"AttractionWhereInput", "AttractionOrderByInput", "Attraction"},
		"attractions",
		[]string{"id", "createdAt", "updatedAt", "maxUses", "address", "popularity", "types", "tags"})

	return &AttractionExecArray{ret}
}

func (instance TicketTypeExec) Exec(ctx context.Context) (*TicketType, error) {
	var v TicketType
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance TicketTypeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type TicketTypeExecArray struct {
	exec *prisma.Exec
}

func (instance TicketTypeExecArray) Exec(ctx context.Context) ([]TicketType, error) {
	var v []TicketType
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type TicketType struct {
	ID        string  `json:"id"`
	CreatedAt string  `json:"createdAt"`
	UpdatedAt string  `json:"updatedAt"`
	CreatorId string  `json:"creatorID"`
	Cost      float64 `json:"cost"`
}

type TicketTypeEdgeExec struct {
	exec *prisma.Exec
}

func (instance *TicketTypeEdgeExec) Node() *TicketTypeExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "TicketType"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "creatorID", "cost"})

	return &TicketTypeExec{ret}
}

func (instance TicketTypeEdgeExec) Exec(ctx context.Context) (*TicketTypeEdge, error) {
	var v TicketTypeEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance TicketTypeEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type TicketTypeEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance TicketTypeEdgeExecArray) Exec(ctx context.Context) ([]TicketTypeEdge, error) {
	var v []TicketTypeEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type TicketTypeEdge struct {
	Cursor string `json:"cursor"`
}

type TicketExec struct {
	exec *prisma.Exec
}

func (instance *TicketExec) Type() *TicketTypeExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "TicketType"},
		"type",
		[]string{"id", "createdAt", "updatedAt", "creatorID", "cost"})

	return &TicketTypeExec{ret}
}

func (instance *TicketExec) Owner() *PersonExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Person"},
		"owner",
		[]string{"id", "createdAt", "updatedAt", "mID", "name", "photo", "birthday", "from", "tags"})

	return &PersonExec{ret}
}

func (instance *TicketExec) Receive() *PaymentEntryExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PaymentEntry"},
		"receive",
		[]string{"id", "createdAt", "updatedAt", "externalID", "productID", "product", "gatewayResponse", "amount", "discountID", "discount"})

	return &PaymentEntryExec{ret}
}

type VisitedParamsExec struct {
	Where   *AttractionWhereInput
	OrderBy *AttractionOrderByInput
	Skip    *int32
	After   *string
	Before  *string
	First   *int32
	Last    *int32
}

func (instance *TicketExec) Visited(params *VisitedParamsExec) *AttractionExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := instance.exec.Client.GetMany(
		instance.exec,
		wparams,
		[3]string{"AttractionWhereInput", "AttractionOrderByInput", "Attraction"},
		"visited",
		[]string{"id", "createdAt", "updatedAt", "maxUses", "address", "popularity", "types", "tags"})

	return &AttractionExecArray{ret}
}

func (instance TicketExec) Exec(ctx context.Context) (*Ticket, error) {
	var v Ticket
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance TicketExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type TicketExecArray struct {
	exec *prisma.Exec
}

func (instance TicketExecArray) Exec(ctx context.Context) ([]Ticket, error) {
	var v []Ticket
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type Ticket struct {
	ID        string `json:"id"`
	CreatedAt string `json:"createdAt"`
	UpdatedAt string `json:"updatedAt"`
	ExpireAt  string `json:"expireAt"`
}

type PartnerExec struct {
	exec *prisma.Exec
}

func (instance *PartnerExec) Person() *PersonExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Person"},
		"person",
		[]string{"id", "createdAt", "updatedAt", "mID", "name", "photo", "birthday", "from", "tags"})

	return &PersonExec{ret}
}

func (instance *PartnerExec) Attractions(params *AttractionsParamsExec) *AttractionExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := instance.exec.Client.GetMany(
		instance.exec,
		wparams,
		[3]string{"AttractionWhereInput", "AttractionOrderByInput", "Attraction"},
		"attractions",
		[]string{"id", "createdAt", "updatedAt", "maxUses", "address", "popularity", "types", "tags"})

	return &AttractionExecArray{ret}
}

func (instance *PartnerExec) Location() *LocationExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Location"},
		"location",
		[]string{"longitude", "latitude", "description"})

	return &LocationExec{ret}
}

type FeaturesParamsExec struct {
	Where   *FeatureWhereInput
	OrderBy *FeatureOrderByInput
	Skip    *int32
	After   *string
	Before  *string
	First   *int32
	Last    *int32
}

func (instance *PartnerExec) Features(params *FeaturesParamsExec) *FeatureExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := instance.exec.Client.GetMany(
		instance.exec,
		wparams,
		[3]string{"FeatureWhereInput", "FeatureOrderByInput", "Feature"},
		"features",
		[]string{"name", "image"})

	return &FeatureExecArray{ret}
}

func (instance *PartnerExec) OpeningHours() *OpeningHoursExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "OpeningHours"},
		"openingHours",
		[]string{"from", "to"})

	return &OpeningHoursExec{ret}
}

func (instance PartnerExec) Exec(ctx context.Context) (*Partner, error) {
	var v Partner
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance PartnerExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type PartnerExecArray struct {
	exec *prisma.Exec
}

func (instance PartnerExecArray) Exec(ctx context.Context) ([]Partner, error) {
	var v []Partner
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type Partner struct {
	ID           string `json:"id"`
	CreatedAt    string `json:"createdAt"`
	UpdatedAt    string `json:"updatedAt"`
	BrandName    string `json:"brandName"`
	SocialReason string `json:"socialReason"`
	Ruc          string `json:"ruc"`
	Address      string `json:"address"`
}

type AttractionExec struct {
	exec *prisma.Exec
}

func (instance *AttractionExec) Owner() *PartnerExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Partner"},
		"owner",
		[]string{"id", "createdAt", "updatedAt", "brandName", "socialReason", "ruc", "address"})

	return &PartnerExec{ret}
}

func (instance *AttractionExec) Overview() *OverviewExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Overview"},
		"overview",
		[]string{"name", "description"})

	return &OverviewExec{ret}
}

func (instance *AttractionExec) Location() *LocationExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Location"},
		"location",
		[]string{"longitude", "latitude", "description"})

	return &LocationExec{ret}
}

type LikedByParamsExec struct {
	Where   *PersonWhereInput
	OrderBy *PersonOrderByInput
	Skip    *int32
	After   *string
	Before  *string
	First   *int32
	Last    *int32
}

func (instance *AttractionExec) LikedBy(params *LikedByParamsExec) *PersonExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := instance.exec.Client.GetMany(
		instance.exec,
		wparams,
		[3]string{"PersonWhereInput", "PersonOrderByInput", "Person"},
		"likedBy",
		[]string{"id", "createdAt", "updatedAt", "mID", "name", "photo", "birthday", "from", "tags"})

	return &PersonExecArray{ret}
}

type ReviewsParamsExec struct {
	Where   *PersonReviewsWhereInput
	OrderBy *PersonReviewsOrderByInput
	Skip    *int32
	After   *string
	Before  *string
	First   *int32
	Last    *int32
}

func (instance *AttractionExec) Reviews(params *ReviewsParamsExec) *PersonReviewsExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := instance.exec.Client.GetMany(
		instance.exec,
		wparams,
		[3]string{"PersonReviewsWhereInput", "PersonReviewsOrderByInput", "PersonReviews"},
		"reviews",
		[]string{"id", "createdAt", "updatedAt", "title", "description", "aproveNumber", "declineNumber"})

	return &PersonReviewsExecArray{ret}
}

func (instance *AttractionExec) Details() *DetailsExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Details"},
		"details",
		[]string{"providerName", "providerWeb", "contactPhone", "contactEmail", "addressReference"})

	return &DetailsExec{ret}
}

func (instance AttractionExec) Exec(ctx context.Context) (*Attraction, error) {
	var v Attraction
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance AttractionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type AttractionExecArray struct {
	exec *prisma.Exec
}

func (instance AttractionExecArray) Exec(ctx context.Context) ([]Attraction, error) {
	var v []Attraction
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type Attraction struct {
	ID         string           `json:"id"`
	CreatedAt  string           `json:"createdAt"`
	UpdatedAt  string           `json:"updatedAt"`
	MaxUses    int32            `json:"maxUses"`
	Address    string           `json:"address"`
	Popularity float64          `json:"popularity"`
	Types      []AttractionType `json:"types,omitempty"`
	Tags       []string         `json:"tags,omitempty"`
}

type TicketEdgeExec struct {
	exec *prisma.Exec
}

func (instance *TicketEdgeExec) Node() *TicketExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Ticket"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "expireAt"})

	return &TicketExec{ret}
}

func (instance TicketEdgeExec) Exec(ctx context.Context) (*TicketEdge, error) {
	var v TicketEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance TicketEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type TicketEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance TicketEdgeExecArray) Exec(ctx context.Context) ([]TicketEdge, error) {
	var v []TicketEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type TicketEdge struct {
	Cursor string `json:"cursor"`
}

type AttractionSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *AttractionSubscriptionPayloadExec) Node() *AttractionExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Attraction"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "maxUses", "address", "popularity", "types", "tags"})

	return &AttractionExec{ret}
}

func (instance *AttractionSubscriptionPayloadExec) PreviousValues() *AttractionPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AttractionPreviousValues"},
		"previousValues",
		[]string{"id", "createdAt", "updatedAt", "maxUses", "address", "popularity", "types", "tags"})

	return &AttractionPreviousValuesExec{ret}
}

func (instance AttractionSubscriptionPayloadExec) Exec(ctx context.Context) (*AttractionSubscriptionPayload, error) {
	var v AttractionSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance AttractionSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type AttractionSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance AttractionSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]AttractionSubscriptionPayload, error) {
	var v []AttractionSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type AttractionSubscriptionPayload struct {
	Mutation      MutationType `json:"mutation"`
	UpdatedFields []string     `json:"updatedFields,omitempty"`
}

type AttractionPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance AttractionPreviousValuesExec) Exec(ctx context.Context) (*AttractionPreviousValues, error) {
	var v AttractionPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance AttractionPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type AttractionPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance AttractionPreviousValuesExecArray) Exec(ctx context.Context) ([]AttractionPreviousValues, error) {
	var v []AttractionPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type AttractionPreviousValues struct {
	ID         string           `json:"id"`
	CreatedAt  string           `json:"createdAt"`
	UpdatedAt  string           `json:"updatedAt"`
	MaxUses    int32            `json:"maxUses"`
	Address    string           `json:"address"`
	Popularity float64          `json:"popularity"`
	Types      []AttractionType `json:"types,omitempty"`
	Tags       []string         `json:"tags,omitempty"`
}

type PhoneChannelConnectionExec struct {
	exec *prisma.Exec
}

func (instance *PhoneChannelConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *PhoneChannelConnectionExec) Edges() *PhoneChannelEdgeExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PhoneChannelEdge"},
		"edges",
		[]string{"cursor"})

	return &PhoneChannelEdgeExec{ret}
}

func (instance *PhoneChannelConnectionExec) Aggregate(ctx context.Context) (Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregatePhoneChannel"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return v, err
}

func (instance PhoneChannelConnectionExec) Exec(ctx context.Context) (*PhoneChannelConnection, error) {
	var v PhoneChannelConnection
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance PhoneChannelConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type PhoneChannelConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance PhoneChannelConnectionExecArray) Exec(ctx context.Context) ([]PhoneChannelConnection, error) {
	var v []PhoneChannelConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type PhoneChannelConnection struct {
}

type EmailChannelExec struct {
	exec *prisma.Exec
}

func (instance EmailChannelExec) Exec(ctx context.Context) (*EmailChannel, error) {
	var v EmailChannel
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance EmailChannelExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type EmailChannelExecArray struct {
	exec *prisma.Exec
}

func (instance EmailChannelExecArray) Exec(ctx context.Context) ([]EmailChannel, error) {
	var v []EmailChannel
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type EmailChannel struct {
	ID          string   `json:"id"`
	CreatedAt   string   `json:"createdAt"`
	UpdatedAt   string   `json:"updatedAt"`
	DisplayName string   `json:"displayName"`
	Valid       bool     `json:"valid"`
	Value       string   `json:"value"`
	Extras      []string `json:"extras,omitempty"`
}

type PersonReviewsEdgeExec struct {
	exec *prisma.Exec
}

func (instance *PersonReviewsEdgeExec) Node() *PersonReviewsExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PersonReviews"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "title", "description", "aproveNumber", "declineNumber"})

	return &PersonReviewsExec{ret}
}

func (instance PersonReviewsEdgeExec) Exec(ctx context.Context) (*PersonReviewsEdge, error) {
	var v PersonReviewsEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance PersonReviewsEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type PersonReviewsEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance PersonReviewsEdgeExecArray) Exec(ctx context.Context) ([]PersonReviewsEdge, error) {
	var v []PersonReviewsEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type PersonReviewsEdge struct {
	Cursor string `json:"cursor"`
}

type CredentialSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *CredentialSubscriptionPayloadExec) Node() *CredentialExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Credential"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "displayName", "isMain", "type", "validated", "validationID", "value", "rawPassword", "hashedPassword"})

	return &CredentialExec{ret}
}

func (instance *CredentialSubscriptionPayloadExec) PreviousValues() *CredentialPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "CredentialPreviousValues"},
		"previousValues",
		[]string{"id", "createdAt", "updatedAt", "displayName", "isMain", "type", "validated", "validationID", "value", "rawPassword", "hashedPassword"})

	return &CredentialPreviousValuesExec{ret}
}

func (instance CredentialSubscriptionPayloadExec) Exec(ctx context.Context) (*CredentialSubscriptionPayload, error) {
	var v CredentialSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance CredentialSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type CredentialSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance CredentialSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]CredentialSubscriptionPayload, error) {
	var v []CredentialSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type CredentialSubscriptionPayload struct {
	Mutation      MutationType `json:"mutation"`
	UpdatedFields []string     `json:"updatedFields,omitempty"`
}

type CredentialPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance CredentialPreviousValuesExec) Exec(ctx context.Context) (*CredentialPreviousValues, error) {
	var v CredentialPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance CredentialPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type CredentialPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance CredentialPreviousValuesExecArray) Exec(ctx context.Context) ([]CredentialPreviousValues, error) {
	var v []CredentialPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type CredentialPreviousValues struct {
	ID             string         `json:"id"`
	CreatedAt      string         `json:"createdAt"`
	UpdatedAt      string         `json:"updatedAt"`
	DisplayName    *string        `json:"displayName,omitempty"`
	IsMain         bool           `json:"isMain"`
	Type           CredentialType `json:"type"`
	Validated      *bool          `json:"validated,omitempty"`
	ValidationId   *string        `json:"validationID,omitempty"`
	Value          string         `json:"value"`
	RawPassword    *string        `json:"rawPassword,omitempty"`
	HashedPassword string         `json:"hashedPassword"`
}

type PersonConnectionExec struct {
	exec *prisma.Exec
}

func (instance *PersonConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *PersonConnectionExec) Edges() *PersonEdgeExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PersonEdge"},
		"edges",
		[]string{"cursor"})

	return &PersonEdgeExec{ret}
}

func (instance *PersonConnectionExec) Aggregate(ctx context.Context) (Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregatePerson"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return v, err
}

func (instance PersonConnectionExec) Exec(ctx context.Context) (*PersonConnection, error) {
	var v PersonConnection
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance PersonConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type PersonConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance PersonConnectionExecArray) Exec(ctx context.Context) ([]PersonConnection, error) {
	var v []PersonConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type PersonConnection struct {
}

type IDentificationDocumentExec struct {
	exec *prisma.Exec
}

func (instance *IDentificationDocumentExec) Person() *PersonExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Person"},
		"person",
		[]string{"id", "createdAt", "updatedAt", "mID", "name", "photo", "birthday", "from", "tags"})

	return &PersonExec{ret}
}

func (instance IDentificationDocumentExec) Exec(ctx context.Context) (*IDentificationDocument, error) {
	var v IDentificationDocument
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance IDentificationDocumentExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type IDentificationDocumentExecArray struct {
	exec *prisma.Exec
}

func (instance IDentificationDocumentExecArray) Exec(ctx context.Context) ([]IDentificationDocument, error) {
	var v []IDentificationDocument
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type IDentificationDocument struct {
	ID        string             `json:"id"`
	CreatedAt string             `json:"createdAt"`
	UpdatedAt string             `json:"updatedAt"`
	Type      IDentificationType `json:"type"`
	Value     string             `json:"value"`
	Validated *bool              `json:"validated,omitempty"`
}

type PaymentEntryEdgeExec struct {
	exec *prisma.Exec
}

func (instance *PaymentEntryEdgeExec) Node() *PaymentEntryExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PaymentEntry"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "externalID", "productID", "product", "gatewayResponse", "amount", "discountID", "discount"})

	return &PaymentEntryExec{ret}
}

func (instance PaymentEntryEdgeExec) Exec(ctx context.Context) (*PaymentEntryEdge, error) {
	var v PaymentEntryEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance PaymentEntryEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type PaymentEntryEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance PaymentEntryEdgeExecArray) Exec(ctx context.Context) ([]PaymentEntryEdge, error) {
	var v []PaymentEntryEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type PaymentEntryEdge struct {
	Cursor string `json:"cursor"`
}

type CreditCardSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *CreditCardSubscriptionPayloadExec) Node() *CreditCardExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "CreditCard"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "cardNumber", "cardToken", "type", "lastUsed"})

	return &CreditCardExec{ret}
}

func (instance *CreditCardSubscriptionPayloadExec) PreviousValues() *CreditCardPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "CreditCardPreviousValues"},
		"previousValues",
		[]string{"id", "createdAt", "updatedAt", "cardNumber", "cardToken", "type", "lastUsed"})

	return &CreditCardPreviousValuesExec{ret}
}

func (instance CreditCardSubscriptionPayloadExec) Exec(ctx context.Context) (*CreditCardSubscriptionPayload, error) {
	var v CreditCardSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance CreditCardSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type CreditCardSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance CreditCardSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]CreditCardSubscriptionPayload, error) {
	var v []CreditCardSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type CreditCardSubscriptionPayload struct {
	Mutation      MutationType `json:"mutation"`
	UpdatedFields []string     `json:"updatedFields,omitempty"`
}

type CreditCardPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance CreditCardPreviousValuesExec) Exec(ctx context.Context) (*CreditCardPreviousValues, error) {
	var v CreditCardPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance CreditCardPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type CreditCardPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance CreditCardPreviousValuesExecArray) Exec(ctx context.Context) ([]CreditCardPreviousValues, error) {
	var v []CreditCardPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type CreditCardPreviousValues struct {
	ID         string         `json:"id"`
	CreatedAt  string         `json:"createdAt"`
	UpdatedAt  string         `json:"updatedAt"`
	CardNumber string         `json:"cardNumber"`
	CardToken  string         `json:"cardToken"`
	Type       CreditCardType `json:"type"`
	LastUsed   *string        `json:"lastUsed,omitempty"`
}

type PartnerConnectionExec struct {
	exec *prisma.Exec
}

func (instance *PartnerConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *PartnerConnectionExec) Edges() *PartnerEdgeExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PartnerEdge"},
		"edges",
		[]string{"cursor"})

	return &PartnerEdgeExec{ret}
}

func (instance *PartnerConnectionExec) Aggregate(ctx context.Context) (Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregatePartner"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return v, err
}

func (instance PartnerConnectionExec) Exec(ctx context.Context) (*PartnerConnection, error) {
	var v PartnerConnection
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance PartnerConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type PartnerConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance PartnerConnectionExecArray) Exec(ctx context.Context) ([]PartnerConnection, error) {
	var v []PartnerConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type PartnerConnection struct {
}

type TravelerExec struct {
	exec *prisma.Exec
}

func (instance *TravelerExec) Person() *PersonExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Person"},
		"person",
		[]string{"id", "createdAt", "updatedAt", "mID", "name", "photo", "birthday", "from", "tags"})

	return &PersonExec{ret}
}

type CardsParamsExec struct {
	Where   *CreditCardWhereInput
	OrderBy *CreditCardOrderByInput
	Skip    *int32
	After   *string
	Before  *string
	First   *int32
	Last    *int32
}

func (instance *TravelerExec) Cards(params *CardsParamsExec) *CreditCardExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := instance.exec.Client.GetMany(
		instance.exec,
		wparams,
		[3]string{"CreditCardWhereInput", "CreditCardOrderByInput", "CreditCard"},
		"cards",
		[]string{"id", "createdAt", "updatedAt", "cardNumber", "cardToken", "type", "lastUsed"})

	return &CreditCardExecArray{ret}
}

type TicketsParamsExec struct {
	Where   *TicketWhereInput
	OrderBy *TicketOrderByInput
	Skip    *int32
	After   *string
	Before  *string
	First   *int32
	Last    *int32
}

func (instance *TravelerExec) Tickets(params *TicketsParamsExec) *TicketExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := instance.exec.Client.GetMany(
		instance.exec,
		wparams,
		[3]string{"TicketWhereInput", "TicketOrderByInput", "Ticket"},
		"tickets",
		[]string{"id", "createdAt", "updatedAt", "expireAt"})

	return &TicketExecArray{ret}
}

func (instance TravelerExec) Exec(ctx context.Context) (*Traveler, error) {
	var v Traveler
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance TravelerExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type TravelerExecArray struct {
	exec *prisma.Exec
}

func (instance TravelerExecArray) Exec(ctx context.Context) ([]Traveler, error) {
	var v []Traveler
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type Traveler struct {
	ID        string `json:"id"`
	CreatedAt string `json:"createdAt"`
	UpdatedAt string `json:"updatedAt"`
	Username  string `json:"username"`
}

type DetailsSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *DetailsSubscriptionPayloadExec) Node() *DetailsExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Details"},
		"node",
		[]string{"providerName", "providerWeb", "contactPhone", "contactEmail", "addressReference"})

	return &DetailsExec{ret}
}

func (instance *DetailsSubscriptionPayloadExec) PreviousValues() *DetailsPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "DetailsPreviousValues"},
		"previousValues",
		[]string{"providerName", "providerWeb", "contactPhone", "contactEmail", "addressReference"})

	return &DetailsPreviousValuesExec{ret}
}

func (instance DetailsSubscriptionPayloadExec) Exec(ctx context.Context) (*DetailsSubscriptionPayload, error) {
	var v DetailsSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance DetailsSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type DetailsSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance DetailsSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]DetailsSubscriptionPayload, error) {
	var v []DetailsSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type DetailsSubscriptionPayload struct {
	Mutation      MutationType `json:"mutation"`
	UpdatedFields []string     `json:"updatedFields,omitempty"`
}

type OverviewConnectionExec struct {
	exec *prisma.Exec
}

func (instance *OverviewConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *OverviewConnectionExec) Edges() *OverviewEdgeExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "OverviewEdge"},
		"edges",
		[]string{"cursor"})

	return &OverviewEdgeExec{ret}
}

func (instance *OverviewConnectionExec) Aggregate(ctx context.Context) (Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateOverview"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return v, err
}

func (instance OverviewConnectionExec) Exec(ctx context.Context) (*OverviewConnection, error) {
	var v OverviewConnection
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance OverviewConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type OverviewConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance OverviewConnectionExecArray) Exec(ctx context.Context) ([]OverviewConnection, error) {
	var v []OverviewConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type OverviewConnection struct {
}

type DetailsPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance DetailsPreviousValuesExec) Exec(ctx context.Context) (*DetailsPreviousValues, error) {
	var v DetailsPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance DetailsPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type DetailsPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance DetailsPreviousValuesExecArray) Exec(ctx context.Context) ([]DetailsPreviousValues, error) {
	var v []DetailsPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type DetailsPreviousValues struct {
	ProviderName     string  `json:"providerName"`
	ProviderWeb      *string `json:"providerWeb,omitempty"`
	ContactPhone     *string `json:"contactPhone,omitempty"`
	ContactEmail     *string `json:"contactEmail,omitempty"`
	AddressReference *string `json:"addressReference,omitempty"`
}

type CreditCardExec struct {
	exec *prisma.Exec
}

func (instance *CreditCardExec) Owner() *TravelerExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Traveler"},
		"owner",
		[]string{"id", "createdAt", "updatedAt", "username"})

	return &TravelerExec{ret}
}

type UsesParamsExec struct {
	Where   *PaymentEntryWhereInput
	OrderBy *PaymentEntryOrderByInput
	Skip    *int32
	After   *string
	Before  *string
	First   *int32
	Last    *int32
}

func (instance *CreditCardExec) Uses(params *UsesParamsExec) *PaymentEntryExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := instance.exec.Client.GetMany(
		instance.exec,
		wparams,
		[3]string{"PaymentEntryWhereInput", "PaymentEntryOrderByInput", "PaymentEntry"},
		"uses",
		[]string{"id", "createdAt", "updatedAt", "externalID", "productID", "product", "gatewayResponse", "amount", "discountID", "discount"})

	return &PaymentEntryExecArray{ret}
}

func (instance CreditCardExec) Exec(ctx context.Context) (*CreditCard, error) {
	var v CreditCard
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance CreditCardExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type CreditCardExecArray struct {
	exec *prisma.Exec
}

func (instance CreditCardExecArray) Exec(ctx context.Context) ([]CreditCard, error) {
	var v []CreditCard
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type CreditCard struct {
	ID         string         `json:"id"`
	CreatedAt  string         `json:"createdAt"`
	UpdatedAt  string         `json:"updatedAt"`
	CardNumber string         `json:"cardNumber"`
	CardToken  string         `json:"cardToken"`
	Type       CreditCardType `json:"type"`
	LastUsed   *string        `json:"lastUsed,omitempty"`
}

type OpeningHoursConnectionExec struct {
	exec *prisma.Exec
}

func (instance *OpeningHoursConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *OpeningHoursConnectionExec) Edges() *OpeningHoursEdgeExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "OpeningHoursEdge"},
		"edges",
		[]string{"cursor"})

	return &OpeningHoursEdgeExec{ret}
}

func (instance *OpeningHoursConnectionExec) Aggregate(ctx context.Context) (Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateOpeningHours"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return v, err
}

func (instance OpeningHoursConnectionExec) Exec(ctx context.Context) (*OpeningHoursConnection, error) {
	var v OpeningHoursConnection
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance OpeningHoursConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type OpeningHoursConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance OpeningHoursConnectionExecArray) Exec(ctx context.Context) ([]OpeningHoursConnection, error) {
	var v []OpeningHoursConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type OpeningHoursConnection struct {
}

type EmailChannelSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *EmailChannelSubscriptionPayloadExec) Node() *EmailChannelExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "EmailChannel"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "displayName", "valid", "value", "extras"})

	return &EmailChannelExec{ret}
}

func (instance *EmailChannelSubscriptionPayloadExec) PreviousValues() *EmailChannelPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "EmailChannelPreviousValues"},
		"previousValues",
		[]string{"id", "createdAt", "updatedAt", "displayName", "valid", "value", "extras"})

	return &EmailChannelPreviousValuesExec{ret}
}

func (instance EmailChannelSubscriptionPayloadExec) Exec(ctx context.Context) (*EmailChannelSubscriptionPayload, error) {
	var v EmailChannelSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance EmailChannelSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type EmailChannelSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance EmailChannelSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]EmailChannelSubscriptionPayload, error) {
	var v []EmailChannelSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type EmailChannelSubscriptionPayload struct {
	Mutation      MutationType `json:"mutation"`
	UpdatedFields []string     `json:"updatedFields,omitempty"`
}

type LocationEdgeExec struct {
	exec *prisma.Exec
}

func (instance *LocationEdgeExec) Node() *LocationExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Location"},
		"node",
		[]string{"longitude", "latitude", "description"})

	return &LocationExec{ret}
}

func (instance LocationEdgeExec) Exec(ctx context.Context) (*LocationEdge, error) {
	var v LocationEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance LocationEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type LocationEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance LocationEdgeExecArray) Exec(ctx context.Context) ([]LocationEdge, error) {
	var v []LocationEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type LocationEdge struct {
	Cursor string `json:"cursor"`
}

type EmailChannelPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance EmailChannelPreviousValuesExec) Exec(ctx context.Context) (*EmailChannelPreviousValues, error) {
	var v EmailChannelPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance EmailChannelPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type EmailChannelPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance EmailChannelPreviousValuesExecArray) Exec(ctx context.Context) ([]EmailChannelPreviousValues, error) {
	var v []EmailChannelPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type EmailChannelPreviousValues struct {
	ID          string   `json:"id"`
	CreatedAt   string   `json:"createdAt"`
	UpdatedAt   string   `json:"updatedAt"`
	DisplayName string   `json:"displayName"`
	Valid       bool     `json:"valid"`
	Value       string   `json:"value"`
	Extras      []string `json:"extras,omitempty"`
}

type TicketTypePreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance TicketTypePreviousValuesExec) Exec(ctx context.Context) (*TicketTypePreviousValues, error) {
	var v TicketTypePreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance TicketTypePreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type TicketTypePreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance TicketTypePreviousValuesExecArray) Exec(ctx context.Context) ([]TicketTypePreviousValues, error) {
	var v []TicketTypePreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type TicketTypePreviousValues struct {
	ID        string  `json:"id"`
	CreatedAt string  `json:"createdAt"`
	UpdatedAt string  `json:"updatedAt"`
	CreatorId string  `json:"creatorID"`
	Cost      float64 `json:"cost"`
}

type IDentificationDocumentEdgeExec struct {
	exec *prisma.Exec
}

func (instance *IDentificationDocumentEdgeExec) Node() *IDentificationDocumentExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "IdentificationDocument"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "type", "value", "validated"})

	return &IDentificationDocumentExec{ret}
}

func (instance IDentificationDocumentEdgeExec) Exec(ctx context.Context) (*IDentificationDocumentEdge, error) {
	var v IDentificationDocumentEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance IDentificationDocumentEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type IDentificationDocumentEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance IDentificationDocumentEdgeExecArray) Exec(ctx context.Context) ([]IDentificationDocumentEdge, error) {
	var v []IDentificationDocumentEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type IDentificationDocumentEdge struct {
	Cursor string `json:"cursor"`
}

type FeatureSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *FeatureSubscriptionPayloadExec) Node() *FeatureExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Feature"},
		"node",
		[]string{"name", "image"})

	return &FeatureExec{ret}
}

func (instance *FeatureSubscriptionPayloadExec) PreviousValues() *FeaturePreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "FeaturePreviousValues"},
		"previousValues",
		[]string{"name", "image"})

	return &FeaturePreviousValuesExec{ret}
}

func (instance FeatureSubscriptionPayloadExec) Exec(ctx context.Context) (*FeatureSubscriptionPayload, error) {
	var v FeatureSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance FeatureSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type FeatureSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance FeatureSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]FeatureSubscriptionPayload, error) {
	var v []FeatureSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type FeatureSubscriptionPayload struct {
	Mutation      MutationType `json:"mutation"`
	UpdatedFields []string     `json:"updatedFields,omitempty"`
}

type TicketTypeSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *TicketTypeSubscriptionPayloadExec) Node() *TicketTypeExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "TicketType"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "creatorID", "cost"})

	return &TicketTypeExec{ret}
}

func (instance *TicketTypeSubscriptionPayloadExec) PreviousValues() *TicketTypePreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "TicketTypePreviousValues"},
		"previousValues",
		[]string{"id", "createdAt", "updatedAt", "creatorID", "cost"})

	return &TicketTypePreviousValuesExec{ret}
}

func (instance TicketTypeSubscriptionPayloadExec) Exec(ctx context.Context) (*TicketTypeSubscriptionPayload, error) {
	var v TicketTypeSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance TicketTypeSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type TicketTypeSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance TicketTypeSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]TicketTypeSubscriptionPayload, error) {
	var v []TicketTypeSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type TicketTypeSubscriptionPayload struct {
	Mutation      MutationType `json:"mutation"`
	UpdatedFields []string     `json:"updatedFields,omitempty"`
}

type FeaturePreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance FeaturePreviousValuesExec) Exec(ctx context.Context) (*FeaturePreviousValues, error) {
	var v FeaturePreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance FeaturePreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type FeaturePreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance FeaturePreviousValuesExecArray) Exec(ctx context.Context) ([]FeaturePreviousValues, error) {
	var v []FeaturePreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type FeaturePreviousValues struct {
	Name  *string `json:"name,omitempty"`
	Image *string `json:"image,omitempty"`
}

type FeatureEdgeExec struct {
	exec *prisma.Exec
}

func (instance *FeatureEdgeExec) Node() *FeatureExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Feature"},
		"node",
		[]string{"name", "image"})

	return &FeatureExec{ret}
}

func (instance FeatureEdgeExec) Exec(ctx context.Context) (*FeatureEdge, error) {
	var v FeatureEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance FeatureEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type FeatureEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance FeatureEdgeExecArray) Exec(ctx context.Context) ([]FeatureEdge, error) {
	var v []FeatureEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type FeatureEdge struct {
	Cursor string `json:"cursor"`
}

type CredentialEdgeExec struct {
	exec *prisma.Exec
}

func (instance *CredentialEdgeExec) Node() *CredentialExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Credential"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "displayName", "isMain", "type", "validated", "validationID", "value", "rawPassword", "hashedPassword"})

	return &CredentialExec{ret}
}

func (instance CredentialEdgeExec) Exec(ctx context.Context) (*CredentialEdge, error) {
	var v CredentialEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance CredentialEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type CredentialEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance CredentialEdgeExecArray) Exec(ctx context.Context) ([]CredentialEdge, error) {
	var v []CredentialEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type CredentialEdge struct {
	Cursor string `json:"cursor"`
}

type IDentificationDocumentSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *IDentificationDocumentSubscriptionPayloadExec) Node() *IDentificationDocumentExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "IdentificationDocument"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "type", "value", "validated"})

	return &IDentificationDocumentExec{ret}
}

func (instance *IDentificationDocumentSubscriptionPayloadExec) PreviousValues() *IDentificationDocumentPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "IdentificationDocumentPreviousValues"},
		"previousValues",
		[]string{"id", "createdAt", "updatedAt", "type", "value", "validated"})

	return &IDentificationDocumentPreviousValuesExec{ret}
}

func (instance IDentificationDocumentSubscriptionPayloadExec) Exec(ctx context.Context) (*IDentificationDocumentSubscriptionPayload, error) {
	var v IDentificationDocumentSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance IDentificationDocumentSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type IDentificationDocumentSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance IDentificationDocumentSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]IDentificationDocumentSubscriptionPayload, error) {
	var v []IDentificationDocumentSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type IDentificationDocumentSubscriptionPayload struct {
	Mutation      MutationType `json:"mutation"`
	UpdatedFields []string     `json:"updatedFields,omitempty"`
}

type EmailChannelConnectionExec struct {
	exec *prisma.Exec
}

func (instance *EmailChannelConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *EmailChannelConnectionExec) Edges() *EmailChannelEdgeExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "EmailChannelEdge"},
		"edges",
		[]string{"cursor"})

	return &EmailChannelEdgeExec{ret}
}

func (instance *EmailChannelConnectionExec) Aggregate(ctx context.Context) (Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateEmailChannel"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return v, err
}

func (instance EmailChannelConnectionExec) Exec(ctx context.Context) (*EmailChannelConnection, error) {
	var v EmailChannelConnection
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance EmailChannelConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type EmailChannelConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance EmailChannelConnectionExecArray) Exec(ctx context.Context) ([]EmailChannelConnection, error) {
	var v []EmailChannelConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type EmailChannelConnection struct {
}

type IDentificationDocumentPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance IDentificationDocumentPreviousValuesExec) Exec(ctx context.Context) (*IDentificationDocumentPreviousValues, error) {
	var v IDentificationDocumentPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance IDentificationDocumentPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type IDentificationDocumentPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance IDentificationDocumentPreviousValuesExecArray) Exec(ctx context.Context) ([]IDentificationDocumentPreviousValues, error) {
	var v []IDentificationDocumentPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type IDentificationDocumentPreviousValues struct {
	ID        string             `json:"id"`
	CreatedAt string             `json:"createdAt"`
	UpdatedAt string             `json:"updatedAt"`
	Type      IDentificationType `json:"type"`
	Value     string             `json:"value"`
	Validated *bool              `json:"validated,omitempty"`
}

type DetailsEdgeExec struct {
	exec *prisma.Exec
}

func (instance *DetailsEdgeExec) Node() *DetailsExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Details"},
		"node",
		[]string{"providerName", "providerWeb", "contactPhone", "contactEmail", "addressReference"})

	return &DetailsExec{ret}
}

func (instance DetailsEdgeExec) Exec(ctx context.Context) (*DetailsEdge, error) {
	var v DetailsEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance DetailsEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type DetailsEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance DetailsEdgeExecArray) Exec(ctx context.Context) ([]DetailsEdge, error) {
	var v []DetailsEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type DetailsEdge struct {
	Cursor string `json:"cursor"`
}

type CredentialConnectionExec struct {
	exec *prisma.Exec
}

func (instance *CredentialConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *CredentialConnectionExec) Edges() *CredentialEdgeExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "CredentialEdge"},
		"edges",
		[]string{"cursor"})

	return &CredentialEdgeExec{ret}
}

func (instance *CredentialConnectionExec) Aggregate(ctx context.Context) (Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateCredential"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return v, err
}

func (instance CredentialConnectionExec) Exec(ctx context.Context) (*CredentialConnection, error) {
	var v CredentialConnection
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance CredentialConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type CredentialConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance CredentialConnectionExecArray) Exec(ctx context.Context) ([]CredentialConnection, error) {
	var v []CredentialConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type CredentialConnection struct {
}

type PhoneChannelExec struct {
	exec *prisma.Exec
}

func (instance PhoneChannelExec) Exec(ctx context.Context) (*PhoneChannel, error) {
	var v PhoneChannel
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance PhoneChannelExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type PhoneChannelExecArray struct {
	exec *prisma.Exec
}

func (instance PhoneChannelExecArray) Exec(ctx context.Context) ([]PhoneChannel, error) {
	var v []PhoneChannel
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type PhoneChannel struct {
	ID          string  `json:"id"`
	CreatedAt   string  `json:"createdAt"`
	UpdatedAt   string  `json:"updatedAt"`
	DisplayName string  `json:"displayName"`
	Valid       bool    `json:"valid"`
	CountryCode string  `json:"countryCode"`
	Number      *string `json:"number,omitempty"`
}

type LocationSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *LocationSubscriptionPayloadExec) Node() *LocationExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Location"},
		"node",
		[]string{"longitude", "latitude", "description"})

	return &LocationExec{ret}
}

func (instance *LocationSubscriptionPayloadExec) PreviousValues() *LocationPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "LocationPreviousValues"},
		"previousValues",
		[]string{"longitude", "latitude", "description"})

	return &LocationPreviousValuesExec{ret}
}

func (instance LocationSubscriptionPayloadExec) Exec(ctx context.Context) (*LocationSubscriptionPayload, error) {
	var v LocationSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance LocationSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type LocationSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance LocationSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]LocationSubscriptionPayload, error) {
	var v []LocationSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type LocationSubscriptionPayload struct {
	Mutation      MutationType `json:"mutation"`
	UpdatedFields []string     `json:"updatedFields,omitempty"`
}

type TravelerConnectionExec struct {
	exec *prisma.Exec
}

func (instance *TravelerConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *TravelerConnectionExec) Edges() *TravelerEdgeExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "TravelerEdge"},
		"edges",
		[]string{"cursor"})

	return &TravelerEdgeExec{ret}
}

func (instance *TravelerConnectionExec) Aggregate(ctx context.Context) (Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateTraveler"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return v, err
}

func (instance TravelerConnectionExec) Exec(ctx context.Context) (*TravelerConnection, error) {
	var v TravelerConnection
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance TravelerConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type TravelerConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance TravelerConnectionExecArray) Exec(ctx context.Context) ([]TravelerConnection, error) {
	var v []TravelerConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type TravelerConnection struct {
}

type LocationPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance LocationPreviousValuesExec) Exec(ctx context.Context) (*LocationPreviousValues, error) {
	var v LocationPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance LocationPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type LocationPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance LocationPreviousValuesExecArray) Exec(ctx context.Context) ([]LocationPreviousValues, error) {
	var v []LocationPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type LocationPreviousValues struct {
	Longitude   float64 `json:"longitude"`
	Latitude    float64 `json:"latitude"`
	Description *string `json:"description,omitempty"`
}

type TicketTypeConnectionExec struct {
	exec *prisma.Exec
}

func (instance *TicketTypeConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *TicketTypeConnectionExec) Edges() *TicketTypeEdgeExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "TicketTypeEdge"},
		"edges",
		[]string{"cursor"})

	return &TicketTypeEdgeExec{ret}
}

func (instance *TicketTypeConnectionExec) Aggregate(ctx context.Context) (Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateTicketType"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return v, err
}

func (instance TicketTypeConnectionExec) Exec(ctx context.Context) (*TicketTypeConnection, error) {
	var v TicketTypeConnection
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance TicketTypeConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type TicketTypeConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance TicketTypeConnectionExecArray) Exec(ctx context.Context) ([]TicketTypeConnection, error) {
	var v []TicketTypeConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type TicketTypeConnection struct {
}

type TicketConnectionExec struct {
	exec *prisma.Exec
}

func (instance *TicketConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *TicketConnectionExec) Edges() *TicketEdgeExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "TicketEdge"},
		"edges",
		[]string{"cursor"})

	return &TicketEdgeExec{ret}
}

func (instance *TicketConnectionExec) Aggregate(ctx context.Context) (Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateTicket"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return v, err
}

func (instance TicketConnectionExec) Exec(ctx context.Context) (*TicketConnection, error) {
	var v TicketConnection
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance TicketConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type TicketConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance TicketConnectionExecArray) Exec(ctx context.Context) ([]TicketConnection, error) {
	var v []TicketConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type TicketConnection struct {
}

type OpeningHoursSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *OpeningHoursSubscriptionPayloadExec) Node() *OpeningHoursExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "OpeningHours"},
		"node",
		[]string{"from", "to"})

	return &OpeningHoursExec{ret}
}

func (instance *OpeningHoursSubscriptionPayloadExec) PreviousValues() *OpeningHoursPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "OpeningHoursPreviousValues"},
		"previousValues",
		[]string{"from", "to"})

	return &OpeningHoursPreviousValuesExec{ret}
}

func (instance OpeningHoursSubscriptionPayloadExec) Exec(ctx context.Context) (*OpeningHoursSubscriptionPayload, error) {
	var v OpeningHoursSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance OpeningHoursSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type OpeningHoursSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance OpeningHoursSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]OpeningHoursSubscriptionPayload, error) {
	var v []OpeningHoursSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type OpeningHoursSubscriptionPayload struct {
	Mutation      MutationType `json:"mutation"`
	UpdatedFields []string     `json:"updatedFields,omitempty"`
}

type OpeningHoursPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance OpeningHoursPreviousValuesExec) Exec(ctx context.Context) (*OpeningHoursPreviousValues, error) {
	var v OpeningHoursPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance OpeningHoursPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type OpeningHoursPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance OpeningHoursPreviousValuesExecArray) Exec(ctx context.Context) ([]OpeningHoursPreviousValues, error) {
	var v []OpeningHoursPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type OpeningHoursPreviousValues struct {
	From string `json:"from"`
	To   string `json:"to"`
}

type PersonEdgeExec struct {
	exec *prisma.Exec
}

func (instance *PersonEdgeExec) Node() *PersonExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Person"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "mID", "name", "photo", "birthday", "from", "tags"})

	return &PersonExec{ret}
}

func (instance PersonEdgeExec) Exec(ctx context.Context) (*PersonEdge, error) {
	var v PersonEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance PersonEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type PersonEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance PersonEdgeExecArray) Exec(ctx context.Context) ([]PersonEdge, error) {
	var v []PersonEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type PersonEdge struct {
	Cursor string `json:"cursor"`
}

type AttractionEdgeExec struct {
	exec *prisma.Exec
}

func (instance *AttractionEdgeExec) Node() *AttractionExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Attraction"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "maxUses", "address", "popularity", "types", "tags"})

	return &AttractionExec{ret}
}

func (instance AttractionEdgeExec) Exec(ctx context.Context) (*AttractionEdge, error) {
	var v AttractionEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance AttractionEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type AttractionEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance AttractionEdgeExecArray) Exec(ctx context.Context) ([]AttractionEdge, error) {
	var v []AttractionEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type AttractionEdge struct {
	Cursor string `json:"cursor"`
}

type PaymentEntryConnectionExec struct {
	exec *prisma.Exec
}

func (instance *PaymentEntryConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *PaymentEntryConnectionExec) Edges() *PaymentEntryEdgeExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PaymentEntryEdge"},
		"edges",
		[]string{"cursor"})

	return &PaymentEntryEdgeExec{ret}
}

func (instance *PaymentEntryConnectionExec) Aggregate(ctx context.Context) (Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregatePaymentEntry"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return v, err
}

func (instance PaymentEntryConnectionExec) Exec(ctx context.Context) (*PaymentEntryConnection, error) {
	var v PaymentEntryConnection
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance PaymentEntryConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type PaymentEntryConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance PaymentEntryConnectionExecArray) Exec(ctx context.Context) ([]PaymentEntryConnection, error) {
	var v []PaymentEntryConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type PaymentEntryConnection struct {
}

type OverviewSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *OverviewSubscriptionPayloadExec) Node() *OverviewExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Overview"},
		"node",
		[]string{"name", "description"})

	return &OverviewExec{ret}
}

func (instance *OverviewSubscriptionPayloadExec) PreviousValues() *OverviewPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "OverviewPreviousValues"},
		"previousValues",
		[]string{"name", "description"})

	return &OverviewPreviousValuesExec{ret}
}

func (instance OverviewSubscriptionPayloadExec) Exec(ctx context.Context) (*OverviewSubscriptionPayload, error) {
	var v OverviewSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance OverviewSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type OverviewSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance OverviewSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]OverviewSubscriptionPayload, error) {
	var v []OverviewSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type OverviewSubscriptionPayload struct {
	Mutation      MutationType `json:"mutation"`
	UpdatedFields []string     `json:"updatedFields,omitempty"`
}

type PersonExec struct {
	exec *prisma.Exec
}

type ChannelsPhoneParamsExec struct {
	Where   *PhoneChannelWhereInput
	OrderBy *PhoneChannelOrderByInput
	Skip    *int32
	After   *string
	Before  *string
	First   *int32
	Last    *int32
}

func (instance *PersonExec) ChannelsPhone(params *ChannelsPhoneParamsExec) *PhoneChannelExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := instance.exec.Client.GetMany(
		instance.exec,
		wparams,
		[3]string{"PhoneChannelWhereInput", "PhoneChannelOrderByInput", "PhoneChannel"},
		"channelsPhone",
		[]string{"id", "createdAt", "updatedAt", "displayName", "valid", "countryCode", "number"})

	return &PhoneChannelExecArray{ret}
}

type ChannelsEmailParamsExec struct {
	Where   *EmailChannelWhereInput
	OrderBy *EmailChannelOrderByInput
	Skip    *int32
	After   *string
	Before  *string
	First   *int32
	Last    *int32
}

func (instance *PersonExec) ChannelsEmail(params *ChannelsEmailParamsExec) *EmailChannelExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := instance.exec.Client.GetMany(
		instance.exec,
		wparams,
		[3]string{"EmailChannelWhereInput", "EmailChannelOrderByInput", "EmailChannel"},
		"channelsEmail",
		[]string{"id", "createdAt", "updatedAt", "displayName", "valid", "value", "extras"})

	return &EmailChannelExecArray{ret}
}

func (instance *PersonExec) IDentification() *IDentificationDocumentExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "IdentificationDocument"},
		"identification",
		[]string{"id", "createdAt", "updatedAt", "type", "value", "validated"})

	return &IDentificationDocumentExec{ret}
}

type CredentialsParamsExec struct {
	Where   *CredentialWhereInput
	OrderBy *CredentialOrderByInput
	Skip    *int32
	After   *string
	Before  *string
	First   *int32
	Last    *int32
}

func (instance *PersonExec) Credentials(params *CredentialsParamsExec) *CredentialExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := instance.exec.Client.GetMany(
		instance.exec,
		wparams,
		[3]string{"CredentialWhereInput", "CredentialOrderByInput", "Credential"},
		"credentials",
		[]string{"id", "createdAt", "updatedAt", "displayName", "isMain", "type", "validated", "validationID", "value", "rawPassword", "hashedPassword"})

	return &CredentialExecArray{ret}
}

func (instance PersonExec) Exec(ctx context.Context) (*Person, error) {
	var v Person
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance PersonExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type PersonExecArray struct {
	exec *prisma.Exec
}

func (instance PersonExecArray) Exec(ctx context.Context) ([]Person, error) {
	var v []Person
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type Person struct {
	ID        string   `json:"id"`
	CreatedAt string   `json:"createdAt"`
	UpdatedAt string   `json:"updatedAt"`
	MId       *string  `json:"mID,omitempty"`
	Name      string   `json:"name"`
	Photo     *string  `json:"photo,omitempty"`
	Birthday  string   `json:"birthday"`
	From      *string  `json:"from,omitempty"`
	Tags      []string `json:"tags,omitempty"`
}

type OverviewPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance OverviewPreviousValuesExec) Exec(ctx context.Context) (*OverviewPreviousValues, error) {
	var v OverviewPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance OverviewPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type OverviewPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance OverviewPreviousValuesExecArray) Exec(ctx context.Context) ([]OverviewPreviousValues, error) {
	var v []OverviewPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type OverviewPreviousValues struct {
	Name        string `json:"name"`
	Description string `json:"description"`
}

type FeatureExec struct {
	exec *prisma.Exec
}

func (instance FeatureExec) Exec(ctx context.Context) (*Feature, error) {
	var v Feature
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance FeatureExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type FeatureExecArray struct {
	exec *prisma.Exec
}

func (instance FeatureExecArray) Exec(ctx context.Context) ([]Feature, error) {
	var v []Feature
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type Feature struct {
	Name  *string `json:"name,omitempty"`
	Image *string `json:"image,omitempty"`
}

type PageInfoExec struct {
	exec *prisma.Exec
}

func (instance PageInfoExec) Exec(ctx context.Context) (*PageInfo, error) {
	var v PageInfo
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance PageInfoExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type PageInfoExecArray struct {
	exec *prisma.Exec
}

func (instance PageInfoExecArray) Exec(ctx context.Context) ([]PageInfo, error) {
	var v []PageInfo
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type PageInfo struct {
	HasNextPage     bool    `json:"hasNextPage"`
	HasPreviousPage bool    `json:"hasPreviousPage"`
	StartCursor     *string `json:"startCursor,omitempty"`
	EndCursor       *string `json:"endCursor,omitempty"`
}

type PartnerSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *PartnerSubscriptionPayloadExec) Node() *PartnerExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Partner"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "brandName", "socialReason", "ruc", "address"})

	return &PartnerExec{ret}
}

func (instance *PartnerSubscriptionPayloadExec) PreviousValues() *PartnerPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PartnerPreviousValues"},
		"previousValues",
		[]string{"id", "createdAt", "updatedAt", "brandName", "socialReason", "ruc", "address"})

	return &PartnerPreviousValuesExec{ret}
}

func (instance PartnerSubscriptionPayloadExec) Exec(ctx context.Context) (*PartnerSubscriptionPayload, error) {
	var v PartnerSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance PartnerSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type PartnerSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance PartnerSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]PartnerSubscriptionPayload, error) {
	var v []PartnerSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type PartnerSubscriptionPayload struct {
	Mutation      MutationType `json:"mutation"`
	UpdatedFields []string     `json:"updatedFields,omitempty"`
}

type PartnerPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance PartnerPreviousValuesExec) Exec(ctx context.Context) (*PartnerPreviousValues, error) {
	var v PartnerPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance PartnerPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type PartnerPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance PartnerPreviousValuesExecArray) Exec(ctx context.Context) ([]PartnerPreviousValues, error) {
	var v []PartnerPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type PartnerPreviousValues struct {
	ID           string `json:"id"`
	CreatedAt    string `json:"createdAt"`
	UpdatedAt    string `json:"updatedAt"`
	BrandName    string `json:"brandName"`
	SocialReason string `json:"socialReason"`
	Ruc          string `json:"ruc"`
	Address      string `json:"address"`
}

type AttractionConnectionExec struct {
	exec *prisma.Exec
}

func (instance *AttractionConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *AttractionConnectionExec) Edges() *AttractionEdgeExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AttractionEdge"},
		"edges",
		[]string{"cursor"})

	return &AttractionEdgeExec{ret}
}

func (instance *AttractionConnectionExec) Aggregate(ctx context.Context) (Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateAttraction"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return v, err
}

func (instance AttractionConnectionExec) Exec(ctx context.Context) (*AttractionConnection, error) {
	var v AttractionConnection
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance AttractionConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type AttractionConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance AttractionConnectionExecArray) Exec(ctx context.Context) ([]AttractionConnection, error) {
	var v []AttractionConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type AttractionConnection struct {
}

type EmailChannelEdgeExec struct {
	exec *prisma.Exec
}

func (instance *EmailChannelEdgeExec) Node() *EmailChannelExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "EmailChannel"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "displayName", "valid", "value", "extras"})

	return &EmailChannelExec{ret}
}

func (instance EmailChannelEdgeExec) Exec(ctx context.Context) (*EmailChannelEdge, error) {
	var v EmailChannelEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance EmailChannelEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type EmailChannelEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance EmailChannelEdgeExecArray) Exec(ctx context.Context) ([]EmailChannelEdge, error) {
	var v []EmailChannelEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type EmailChannelEdge struct {
	Cursor string `json:"cursor"`
}

type PaymentEntrySubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *PaymentEntrySubscriptionPayloadExec) Node() *PaymentEntryExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PaymentEntry"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "externalID", "productID", "product", "gatewayResponse", "amount", "discountID", "discount"})

	return &PaymentEntryExec{ret}
}

func (instance *PaymentEntrySubscriptionPayloadExec) PreviousValues() *PaymentEntryPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PaymentEntryPreviousValues"},
		"previousValues",
		[]string{"id", "createdAt", "updatedAt", "externalID", "productID", "product", "gatewayResponse", "amount", "discountID", "discount"})

	return &PaymentEntryPreviousValuesExec{ret}
}

func (instance PaymentEntrySubscriptionPayloadExec) Exec(ctx context.Context) (*PaymentEntrySubscriptionPayload, error) {
	var v PaymentEntrySubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance PaymentEntrySubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type PaymentEntrySubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance PaymentEntrySubscriptionPayloadExecArray) Exec(ctx context.Context) ([]PaymentEntrySubscriptionPayload, error) {
	var v []PaymentEntrySubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type PaymentEntrySubscriptionPayload struct {
	Mutation      MutationType `json:"mutation"`
	UpdatedFields []string     `json:"updatedFields,omitempty"`
}

type DetailsConnectionExec struct {
	exec *prisma.Exec
}

func (instance *DetailsConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *DetailsConnectionExec) Edges() *DetailsEdgeExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "DetailsEdge"},
		"edges",
		[]string{"cursor"})

	return &DetailsEdgeExec{ret}
}

func (instance *DetailsConnectionExec) Aggregate(ctx context.Context) (Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateDetails"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return v, err
}

func (instance DetailsConnectionExec) Exec(ctx context.Context) (*DetailsConnection, error) {
	var v DetailsConnection
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance DetailsConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type DetailsConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance DetailsConnectionExecArray) Exec(ctx context.Context) ([]DetailsConnection, error) {
	var v []DetailsConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type DetailsConnection struct {
}

type PaymentEntryPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance PaymentEntryPreviousValuesExec) Exec(ctx context.Context) (*PaymentEntryPreviousValues, error) {
	var v PaymentEntryPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance PaymentEntryPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type PaymentEntryPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance PaymentEntryPreviousValuesExecArray) Exec(ctx context.Context) ([]PaymentEntryPreviousValues, error) {
	var v []PaymentEntryPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type PaymentEntryPreviousValues struct {
	ID              string  `json:"id"`
	CreatedAt       string  `json:"createdAt"`
	UpdatedAt       string  `json:"updatedAt"`
	ExternalId      string  `json:"externalID"`
	ProductId       string  `json:"productID"`
	Product         string  `json:"product"`
	GatewayResponse *string `json:"gatewayResponse,omitempty"`
	Amount          int32   `json:"amount"`
	DiscountId      *string `json:"discountID,omitempty"`
	Discount        *int32  `json:"discount,omitempty"`
}

type DetailsExec struct {
	exec *prisma.Exec
}

func (instance DetailsExec) Exec(ctx context.Context) (*Details, error) {
	var v Details
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance DetailsExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type DetailsExecArray struct {
	exec *prisma.Exec
}

func (instance DetailsExecArray) Exec(ctx context.Context) ([]Details, error) {
	var v []Details
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type Details struct {
	ProviderName     string  `json:"providerName"`
	ProviderWeb      *string `json:"providerWeb,omitempty"`
	ContactPhone     *string `json:"contactPhone,omitempty"`
	ContactEmail     *string `json:"contactEmail,omitempty"`
	AddressReference *string `json:"addressReference,omitempty"`
}

type PhoneChannelEdgeExec struct {
	exec *prisma.Exec
}

func (instance *PhoneChannelEdgeExec) Node() *PhoneChannelExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PhoneChannel"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "displayName", "valid", "countryCode", "number"})

	return &PhoneChannelExec{ret}
}

func (instance PhoneChannelEdgeExec) Exec(ctx context.Context) (*PhoneChannelEdge, error) {
	var v PhoneChannelEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance PhoneChannelEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type PhoneChannelEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance PhoneChannelEdgeExecArray) Exec(ctx context.Context) ([]PhoneChannelEdge, error) {
	var v []PhoneChannelEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type PhoneChannelEdge struct {
	Cursor string `json:"cursor"`
}

type PersonSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *PersonSubscriptionPayloadExec) Node() *PersonExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Person"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "mID", "name", "photo", "birthday", "from", "tags"})

	return &PersonExec{ret}
}

func (instance *PersonSubscriptionPayloadExec) PreviousValues() *PersonPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PersonPreviousValues"},
		"previousValues",
		[]string{"id", "createdAt", "updatedAt", "mID", "name", "photo", "birthday", "from", "tags"})

	return &PersonPreviousValuesExec{ret}
}

func (instance PersonSubscriptionPayloadExec) Exec(ctx context.Context) (*PersonSubscriptionPayload, error) {
	var v PersonSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance PersonSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type PersonSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance PersonSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]PersonSubscriptionPayload, error) {
	var v []PersonSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type PersonSubscriptionPayload struct {
	Mutation      MutationType `json:"mutation"`
	UpdatedFields []string     `json:"updatedFields,omitempty"`
}

type PersonPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance PersonPreviousValuesExec) Exec(ctx context.Context) (*PersonPreviousValues, error) {
	var v PersonPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance PersonPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type PersonPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance PersonPreviousValuesExecArray) Exec(ctx context.Context) ([]PersonPreviousValues, error) {
	var v []PersonPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type PersonPreviousValues struct {
	ID        string   `json:"id"`
	CreatedAt string   `json:"createdAt"`
	UpdatedAt string   `json:"updatedAt"`
	MId       *string  `json:"mID,omitempty"`
	Name      string   `json:"name"`
	Photo     *string  `json:"photo,omitempty"`
	Birthday  string   `json:"birthday"`
	From      *string  `json:"from,omitempty"`
	Tags      []string `json:"tags,omitempty"`
}

type OverviewEdgeExec struct {
	exec *prisma.Exec
}

func (instance *OverviewEdgeExec) Node() *OverviewExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Overview"},
		"node",
		[]string{"name", "description"})

	return &OverviewExec{ret}
}

func (instance OverviewEdgeExec) Exec(ctx context.Context) (*OverviewEdge, error) {
	var v OverviewEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance OverviewEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type OverviewEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance OverviewEdgeExecArray) Exec(ctx context.Context) ([]OverviewEdge, error) {
	var v []OverviewEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type OverviewEdge struct {
	Cursor string `json:"cursor"`
}

type PersonReviewsExec struct {
	exec *prisma.Exec
}

func (instance *PersonReviewsExec) Person() *PersonExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Person"},
		"person",
		[]string{"id", "createdAt", "updatedAt", "mID", "name", "photo", "birthday", "from", "tags"})

	return &PersonExec{ret}
}

type CommentsParamsExec struct {
	Where   *PersonReviewsWhereInput
	OrderBy *PersonReviewsOrderByInput
	Skip    *int32
	After   *string
	Before  *string
	First   *int32
	Last    *int32
}

func (instance *PersonReviewsExec) Comments(params *CommentsParamsExec) *PersonReviewsExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := instance.exec.Client.GetMany(
		instance.exec,
		wparams,
		[3]string{"PersonReviewsWhereInput", "PersonReviewsOrderByInput", "PersonReviews"},
		"comments",
		[]string{"id", "createdAt", "updatedAt", "title", "description", "aproveNumber", "declineNumber"})

	return &PersonReviewsExecArray{ret}
}

func (instance PersonReviewsExec) Exec(ctx context.Context) (*PersonReviews, error) {
	var v PersonReviews
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance PersonReviewsExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type PersonReviewsExecArray struct {
	exec *prisma.Exec
}

func (instance PersonReviewsExecArray) Exec(ctx context.Context) ([]PersonReviews, error) {
	var v []PersonReviews
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type PersonReviews struct {
	ID            string `json:"id"`
	CreatedAt     string `json:"createdAt"`
	UpdatedAt     string `json:"updatedAt"`
	Title         string `json:"title"`
	Description   string `json:"description"`
	AproveNumber  *int32 `json:"aproveNumber,omitempty"`
	DeclineNumber *int32 `json:"declineNumber,omitempty"`
}

type LocationConnectionExec struct {
	exec *prisma.Exec
}

func (instance *LocationConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *LocationConnectionExec) Edges() *LocationEdgeExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "LocationEdge"},
		"edges",
		[]string{"cursor"})

	return &LocationEdgeExec{ret}
}

func (instance *LocationConnectionExec) Aggregate(ctx context.Context) (Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateLocation"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return v, err
}

func (instance LocationConnectionExec) Exec(ctx context.Context) (*LocationConnection, error) {
	var v LocationConnection
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance LocationConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type LocationConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance LocationConnectionExecArray) Exec(ctx context.Context) ([]LocationConnection, error) {
	var v []LocationConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type LocationConnection struct {
}

type PersonReviewsSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *PersonReviewsSubscriptionPayloadExec) Node() *PersonReviewsExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PersonReviews"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "title", "description", "aproveNumber", "declineNumber"})

	return &PersonReviewsExec{ret}
}

func (instance *PersonReviewsSubscriptionPayloadExec) PreviousValues() *PersonReviewsPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PersonReviewsPreviousValues"},
		"previousValues",
		[]string{"id", "createdAt", "updatedAt", "title", "description", "aproveNumber", "declineNumber"})

	return &PersonReviewsPreviousValuesExec{ret}
}

func (instance PersonReviewsSubscriptionPayloadExec) Exec(ctx context.Context) (*PersonReviewsSubscriptionPayload, error) {
	var v PersonReviewsSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance PersonReviewsSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type PersonReviewsSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance PersonReviewsSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]PersonReviewsSubscriptionPayload, error) {
	var v []PersonReviewsSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type PersonReviewsSubscriptionPayload struct {
	Mutation      MutationType `json:"mutation"`
	UpdatedFields []string     `json:"updatedFields,omitempty"`
}

type FeatureConnectionExec struct {
	exec *prisma.Exec
}

func (instance *FeatureConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *FeatureConnectionExec) Edges() *FeatureEdgeExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "FeatureEdge"},
		"edges",
		[]string{"cursor"})

	return &FeatureEdgeExec{ret}
}

func (instance *FeatureConnectionExec) Aggregate(ctx context.Context) (Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateFeature"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return v, err
}

func (instance FeatureConnectionExec) Exec(ctx context.Context) (*FeatureConnection, error) {
	var v FeatureConnection
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance FeatureConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type FeatureConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance FeatureConnectionExecArray) Exec(ctx context.Context) ([]FeatureConnection, error) {
	var v []FeatureConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type FeatureConnection struct {
}

type PersonReviewsPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance PersonReviewsPreviousValuesExec) Exec(ctx context.Context) (*PersonReviewsPreviousValues, error) {
	var v PersonReviewsPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance PersonReviewsPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type PersonReviewsPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance PersonReviewsPreviousValuesExecArray) Exec(ctx context.Context) ([]PersonReviewsPreviousValues, error) {
	var v []PersonReviewsPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type PersonReviewsPreviousValues struct {
	ID            string `json:"id"`
	CreatedAt     string `json:"createdAt"`
	UpdatedAt     string `json:"updatedAt"`
	Title         string `json:"title"`
	Description   string `json:"description"`
	AproveNumber  *int32 `json:"aproveNumber,omitempty"`
	DeclineNumber *int32 `json:"declineNumber,omitempty"`
}

type CredentialExec struct {
	exec *prisma.Exec
}

func (instance *CredentialExec) Owner() *PersonExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Person"},
		"owner",
		[]string{"id", "createdAt", "updatedAt", "mID", "name", "photo", "birthday", "from", "tags"})

	return &PersonExec{ret}
}

func (instance CredentialExec) Exec(ctx context.Context) (*Credential, error) {
	var v Credential
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance CredentialExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type CredentialExecArray struct {
	exec *prisma.Exec
}

func (instance CredentialExecArray) Exec(ctx context.Context) ([]Credential, error) {
	var v []Credential
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type Credential struct {
	ID             string         `json:"id"`
	CreatedAt      string         `json:"createdAt"`
	UpdatedAt      string         `json:"updatedAt"`
	DisplayName    *string        `json:"displayName,omitempty"`
	IsMain         bool           `json:"isMain"`
	Type           CredentialType `json:"type"`
	Validated      *bool          `json:"validated,omitempty"`
	ValidationId   *string        `json:"validationID,omitempty"`
	Value          string         `json:"value"`
	RawPassword    *string        `json:"rawPassword,omitempty"`
	HashedPassword string         `json:"hashedPassword"`
}

type PersonReviewsConnectionExec struct {
	exec *prisma.Exec
}

func (instance *PersonReviewsConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *PersonReviewsConnectionExec) Edges() *PersonReviewsEdgeExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PersonReviewsEdge"},
		"edges",
		[]string{"cursor"})

	return &PersonReviewsEdgeExec{ret}
}

func (instance *PersonReviewsConnectionExec) Aggregate(ctx context.Context) (Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregatePersonReviews"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return v, err
}

func (instance PersonReviewsConnectionExec) Exec(ctx context.Context) (*PersonReviewsConnection, error) {
	var v PersonReviewsConnection
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance PersonReviewsConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type PersonReviewsConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance PersonReviewsConnectionExecArray) Exec(ctx context.Context) ([]PersonReviewsConnection, error) {
	var v []PersonReviewsConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type PersonReviewsConnection struct {
}

type OpeningHoursEdgeExec struct {
	exec *prisma.Exec
}

func (instance *OpeningHoursEdgeExec) Node() *OpeningHoursExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "OpeningHours"},
		"node",
		[]string{"from", "to"})

	return &OpeningHoursExec{ret}
}

func (instance OpeningHoursEdgeExec) Exec(ctx context.Context) (*OpeningHoursEdge, error) {
	var v OpeningHoursEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance OpeningHoursEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type OpeningHoursEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance OpeningHoursEdgeExecArray) Exec(ctx context.Context) ([]OpeningHoursEdge, error) {
	var v []OpeningHoursEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type OpeningHoursEdge struct {
	Cursor string `json:"cursor"`
}

type TicketSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *TicketSubscriptionPayloadExec) Node() *TicketExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Ticket"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "expireAt"})

	return &TicketExec{ret}
}

func (instance *TicketSubscriptionPayloadExec) PreviousValues() *TicketPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "TicketPreviousValues"},
		"previousValues",
		[]string{"id", "createdAt", "updatedAt", "expireAt"})

	return &TicketPreviousValuesExec{ret}
}

func (instance TicketSubscriptionPayloadExec) Exec(ctx context.Context) (*TicketSubscriptionPayload, error) {
	var v TicketSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance TicketSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type TicketSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance TicketSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]TicketSubscriptionPayload, error) {
	var v []TicketSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type TicketSubscriptionPayload struct {
	Mutation      MutationType `json:"mutation"`
	UpdatedFields []string     `json:"updatedFields,omitempty"`
}

type OverviewExec struct {
	exec *prisma.Exec
}

func (instance OverviewExec) Exec(ctx context.Context) (*Overview, error) {
	var v Overview
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance OverviewExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type OverviewExecArray struct {
	exec *prisma.Exec
}

func (instance OverviewExecArray) Exec(ctx context.Context) ([]Overview, error) {
	var v []Overview
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type Overview struct {
	Name        string `json:"name"`
	Description string `json:"description"`
}

type PhoneChannelPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance PhoneChannelPreviousValuesExec) Exec(ctx context.Context) (*PhoneChannelPreviousValues, error) {
	var v PhoneChannelPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance PhoneChannelPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type PhoneChannelPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance PhoneChannelPreviousValuesExecArray) Exec(ctx context.Context) ([]PhoneChannelPreviousValues, error) {
	var v []PhoneChannelPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type PhoneChannelPreviousValues struct {
	ID          string  `json:"id"`
	CreatedAt   string  `json:"createdAt"`
	UpdatedAt   string  `json:"updatedAt"`
	DisplayName string  `json:"displayName"`
	Valid       bool    `json:"valid"`
	CountryCode string  `json:"countryCode"`
	Number      *string `json:"number,omitempty"`
}

type PhoneChannelSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *PhoneChannelSubscriptionPayloadExec) Node() *PhoneChannelExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PhoneChannel"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "displayName", "valid", "countryCode", "number"})

	return &PhoneChannelExec{ret}
}

func (instance *PhoneChannelSubscriptionPayloadExec) PreviousValues() *PhoneChannelPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PhoneChannelPreviousValues"},
		"previousValues",
		[]string{"id", "createdAt", "updatedAt", "displayName", "valid", "countryCode", "number"})

	return &PhoneChannelPreviousValuesExec{ret}
}

func (instance PhoneChannelSubscriptionPayloadExec) Exec(ctx context.Context) (*PhoneChannelSubscriptionPayload, error) {
	var v PhoneChannelSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance PhoneChannelSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type PhoneChannelSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance PhoneChannelSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]PhoneChannelSubscriptionPayload, error) {
	var v []PhoneChannelSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type PhoneChannelSubscriptionPayload struct {
	Mutation      MutationType `json:"mutation"`
	UpdatedFields []string     `json:"updatedFields,omitempty"`
}

type IDentificationDocumentConnectionExec struct {
	exec *prisma.Exec
}

func (instance *IDentificationDocumentConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *IDentificationDocumentConnectionExec) Edges() *IDentificationDocumentEdgeExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "IdentificationDocumentEdge"},
		"edges",
		[]string{"cursor"})

	return &IDentificationDocumentEdgeExec{ret}
}

func (instance *IDentificationDocumentConnectionExec) Aggregate(ctx context.Context) (Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateIdentificationDocument"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return v, err
}

func (instance IDentificationDocumentConnectionExec) Exec(ctx context.Context) (*IDentificationDocumentConnection, error) {
	var v IDentificationDocumentConnection
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance IDentificationDocumentConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type IDentificationDocumentConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance IDentificationDocumentConnectionExecArray) Exec(ctx context.Context) ([]IDentificationDocumentConnection, error) {
	var v []IDentificationDocumentConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type IDentificationDocumentConnection struct {
}

type PartnerEdgeExec struct {
	exec *prisma.Exec
}

func (instance *PartnerEdgeExec) Node() *PartnerExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Partner"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "brandName", "socialReason", "ruc", "address"})

	return &PartnerExec{ret}
}

func (instance PartnerEdgeExec) Exec(ctx context.Context) (*PartnerEdge, error) {
	var v PartnerEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance PartnerEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type PartnerEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance PartnerEdgeExecArray) Exec(ctx context.Context) ([]PartnerEdge, error) {
	var v []PartnerEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type PartnerEdge struct {
	Cursor string `json:"cursor"`
}
