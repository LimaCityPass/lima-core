// Code generated by Prisma CLI (https://github.com/prisma/prisma). DO NOT EDIT.

package prisma

import (
	"context"
	"errors"

	"github.com/prisma/prisma-client-lib-go"

	"github.com/machinebox/graphql"
)

var ErrNoResult = errors.New("query returned no result")

func Str(v string) *string { return &v }
func Int32(v int32) *int32 { return &v }
func Bool(v bool) *bool    { return &v }

type BatchPayloadExec struct {
	exec *prisma.BatchPayloadExec
}

func (exec *BatchPayloadExec) Exec(ctx context.Context) (BatchPayload, error) {
	bp, err := exec.exec.Exec(ctx)
	return BatchPayload(bp), err
}

type BatchPayload struct {
	Count int64 `json:"count"`
}

type Aggregate struct {
	Count int64 `json:"count"`
}

type Client struct {
	Client *prisma.Client
}

type Options struct {
	Endpoint string
	Secret   string
}

func New(options *Options, opts ...graphql.ClientOption) *Client {
	endpoint := DefaultEndpoint
	secret := Secret
	if options != nil {
		endpoint = options.Endpoint
		secret = options.Secret
	}
	return &Client{
		Client: prisma.New(endpoint, secret, opts...),
	}
}

func (client *Client) GraphQL(ctx context.Context, query string, variables map[string]interface{}) (map[string]interface{}, error) {
	return client.Client.GraphQL(ctx, query, variables)
}

var DefaultEndpoint = "https://us1.prisma.sh/bregy-malpartida-2d1dcf/limadb/dev"
var Secret = ""

func (client *Client) Attraction(params AttractionWhereUniqueInput) *AttractionExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"AttractionWhereUniqueInput!", "Attraction"},
		"attraction",
		[]string{"id", "createdAt", "updatedAt", "name", "description", "address", "popularity", "types", "tags"})

	return &AttractionExec{ret}
}

type AttractionsParams struct {
	Where   *AttractionWhereInput   `json:"where,omitempty"`
	OrderBy *AttractionOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                  `json:"skip,omitempty"`
	After   *string                 `json:"after,omitempty"`
	Before  *string                 `json:"before,omitempty"`
	First   *int32                  `json:"first,omitempty"`
	Last    *int32                  `json:"last,omitempty"`
}

func (client *Client) Attractions(params *AttractionsParams) *AttractionExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"AttractionWhereInput", "AttractionOrderByInput", "Attraction"},
		"attractions",
		[]string{"id", "createdAt", "updatedAt", "name", "description", "address", "popularity", "types", "tags"})

	return &AttractionExecArray{ret}
}

type AttractionsConnectionParams struct {
	Where   *AttractionWhereInput   `json:"where,omitempty"`
	OrderBy *AttractionOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                  `json:"skip,omitempty"`
	After   *string                 `json:"after,omitempty"`
	Before  *string                 `json:"before,omitempty"`
	First   *int32                  `json:"first,omitempty"`
	Last    *int32                  `json:"last,omitempty"`
}

func (client *Client) AttractionsConnection(params *AttractionsConnectionParams) AttractionConnectionExec {
	panic("not implemented")
}

func (client *Client) Credential(params CredentialWhereUniqueInput) *CredentialExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"CredentialWhereUniqueInput!", "Credential"},
		"credential",
		[]string{"id", "createdAt", "updatedAt", "displayName", "isMain", "type", "validated", "validationID", "value", "rawPassword", "hashedPassword"})

	return &CredentialExec{ret}
}

type CredentialsParams struct {
	Where   *CredentialWhereInput   `json:"where,omitempty"`
	OrderBy *CredentialOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                  `json:"skip,omitempty"`
	After   *string                 `json:"after,omitempty"`
	Before  *string                 `json:"before,omitempty"`
	First   *int32                  `json:"first,omitempty"`
	Last    *int32                  `json:"last,omitempty"`
}

func (client *Client) Credentials(params *CredentialsParams) *CredentialExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"CredentialWhereInput", "CredentialOrderByInput", "Credential"},
		"credentials",
		[]string{"id", "createdAt", "updatedAt", "displayName", "isMain", "type", "validated", "validationID", "value", "rawPassword", "hashedPassword"})

	return &CredentialExecArray{ret}
}

type CredentialsConnectionParams struct {
	Where   *CredentialWhereInput   `json:"where,omitempty"`
	OrderBy *CredentialOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                  `json:"skip,omitempty"`
	After   *string                 `json:"after,omitempty"`
	Before  *string                 `json:"before,omitempty"`
	First   *int32                  `json:"first,omitempty"`
	Last    *int32                  `json:"last,omitempty"`
}

func (client *Client) CredentialsConnection(params *CredentialsConnectionParams) CredentialConnectionExec {
	panic("not implemented")
}

func (client *Client) CreditCard(params CreditCardWhereUniqueInput) *CreditCardExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"CreditCardWhereUniqueInput!", "CreditCard"},
		"creditCard",
		[]string{"id", "createdAt", "updatedAt", "cardNumber", "cardToken", "type", "lastUsed"})

	return &CreditCardExec{ret}
}

type CreditCardsParams struct {
	Where   *CreditCardWhereInput   `json:"where,omitempty"`
	OrderBy *CreditCardOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                  `json:"skip,omitempty"`
	After   *string                 `json:"after,omitempty"`
	Before  *string                 `json:"before,omitempty"`
	First   *int32                  `json:"first,omitempty"`
	Last    *int32                  `json:"last,omitempty"`
}

func (client *Client) CreditCards(params *CreditCardsParams) *CreditCardExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"CreditCardWhereInput", "CreditCardOrderByInput", "CreditCard"},
		"creditCards",
		[]string{"id", "createdAt", "updatedAt", "cardNumber", "cardToken", "type", "lastUsed"})

	return &CreditCardExecArray{ret}
}

type CreditCardsConnectionParams struct {
	Where   *CreditCardWhereInput   `json:"where,omitempty"`
	OrderBy *CreditCardOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                  `json:"skip,omitempty"`
	After   *string                 `json:"after,omitempty"`
	Before  *string                 `json:"before,omitempty"`
	First   *int32                  `json:"first,omitempty"`
	Last    *int32                  `json:"last,omitempty"`
}

func (client *Client) CreditCardsConnection(params *CreditCardsConnectionParams) CreditCardConnectionExec {
	panic("not implemented")
}

type EmailsParams struct {
	Where   *EmailWhereInput   `json:"where,omitempty"`
	OrderBy *EmailOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32             `json:"skip,omitempty"`
	After   *string            `json:"after,omitempty"`
	Before  *string            `json:"before,omitempty"`
	First   *int32             `json:"first,omitempty"`
	Last    *int32             `json:"last,omitempty"`
}

func (client *Client) Emails(params *EmailsParams) *EmailExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"EmailWhereInput", "EmailOrderByInput", "Email"},
		"emails",
		[]string{"type", "value", "extras"})

	return &EmailExecArray{ret}
}

type EmailsConnectionParams struct {
	Where   *EmailWhereInput   `json:"where,omitempty"`
	OrderBy *EmailOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32             `json:"skip,omitempty"`
	After   *string            `json:"after,omitempty"`
	Before  *string            `json:"before,omitempty"`
	First   *int32             `json:"first,omitempty"`
	Last    *int32             `json:"last,omitempty"`
}

func (client *Client) EmailsConnection(params *EmailsConnectionParams) EmailConnectionExec {
	panic("not implemented")
}

func (client *Client) IDentificationDocument(params IDentificationDocumentWhereUniqueInput) *IDentificationDocumentExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"IdentificationDocumentWhereUniqueInput!", "IdentificationDocument"},
		"identificationDocument",
		[]string{"id", "createdAt", "updatedAt", "type", "value"})

	return &IDentificationDocumentExec{ret}
}

type IDentificationDocumentsParams struct {
	Where   *IDentificationDocumentWhereInput   `json:"where,omitempty"`
	OrderBy *IDentificationDocumentOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                              `json:"skip,omitempty"`
	After   *string                             `json:"after,omitempty"`
	Before  *string                             `json:"before,omitempty"`
	First   *int32                              `json:"first,omitempty"`
	Last    *int32                              `json:"last,omitempty"`
}

func (client *Client) IDentificationDocuments(params *IDentificationDocumentsParams) *IDentificationDocumentExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"IdentificationDocumentWhereInput", "IdentificationDocumentOrderByInput", "IdentificationDocument"},
		"identificationDocuments",
		[]string{"id", "createdAt", "updatedAt", "type", "value"})

	return &IDentificationDocumentExecArray{ret}
}

type IDentificationDocumentsConnectionParams struct {
	Where   *IDentificationDocumentWhereInput   `json:"where,omitempty"`
	OrderBy *IDentificationDocumentOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                              `json:"skip,omitempty"`
	After   *string                             `json:"after,omitempty"`
	Before  *string                             `json:"before,omitempty"`
	First   *int32                              `json:"first,omitempty"`
	Last    *int32                              `json:"last,omitempty"`
}

func (client *Client) IDentificationDocumentsConnection(params *IDentificationDocumentsConnectionParams) IDentificationDocumentConnectionExec {
	panic("not implemented")
}

type LocationsParams struct {
	Where   *LocationWhereInput   `json:"where,omitempty"`
	OrderBy *LocationOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                `json:"skip,omitempty"`
	After   *string               `json:"after,omitempty"`
	Before  *string               `json:"before,omitempty"`
	First   *int32                `json:"first,omitempty"`
	Last    *int32                `json:"last,omitempty"`
}

func (client *Client) Locations(params *LocationsParams) *LocationExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"LocationWhereInput", "LocationOrderByInput", "Location"},
		"locations",
		[]string{"longitude", "latitude"})

	return &LocationExecArray{ret}
}

type LocationsConnectionParams struct {
	Where   *LocationWhereInput   `json:"where,omitempty"`
	OrderBy *LocationOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                `json:"skip,omitempty"`
	After   *string               `json:"after,omitempty"`
	Before  *string               `json:"before,omitempty"`
	First   *int32                `json:"first,omitempty"`
	Last    *int32                `json:"last,omitempty"`
}

func (client *Client) LocationsConnection(params *LocationsConnectionParams) LocationConnectionExec {
	panic("not implemented")
}

func (client *Client) Partner(params PartnerWhereUniqueInput) *PartnerExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"PartnerWhereUniqueInput!", "Partner"},
		"partner",
		[]string{"id", "createdAt", "updatedAt"})

	return &PartnerExec{ret}
}

type PartnersParams struct {
	Where   *PartnerWhereInput   `json:"where,omitempty"`
	OrderBy *PartnerOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32               `json:"skip,omitempty"`
	After   *string              `json:"after,omitempty"`
	Before  *string              `json:"before,omitempty"`
	First   *int32               `json:"first,omitempty"`
	Last    *int32               `json:"last,omitempty"`
}

func (client *Client) Partners(params *PartnersParams) *PartnerExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"PartnerWhereInput", "PartnerOrderByInput", "Partner"},
		"partners",
		[]string{"id", "createdAt", "updatedAt"})

	return &PartnerExecArray{ret}
}

type PartnersConnectionParams struct {
	Where   *PartnerWhereInput   `json:"where,omitempty"`
	OrderBy *PartnerOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32               `json:"skip,omitempty"`
	After   *string              `json:"after,omitempty"`
	Before  *string              `json:"before,omitempty"`
	First   *int32               `json:"first,omitempty"`
	Last    *int32               `json:"last,omitempty"`
}

func (client *Client) PartnersConnection(params *PartnersConnectionParams) PartnerConnectionExec {
	panic("not implemented")
}

func (client *Client) PaymentEntry(params PaymentEntryWhereUniqueInput) *PaymentEntryExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"PaymentEntryWhereUniqueInput!", "PaymentEntry"},
		"paymentEntry",
		[]string{"id", "createdAt", "updatedAt", "externalID", "productID", "product", "gatewayResponse", "amount", "discountID", "discount"})

	return &PaymentEntryExec{ret}
}

type PaymentEntriesParams struct {
	Where   *PaymentEntryWhereInput   `json:"where,omitempty"`
	OrderBy *PaymentEntryOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                    `json:"skip,omitempty"`
	After   *string                   `json:"after,omitempty"`
	Before  *string                   `json:"before,omitempty"`
	First   *int32                    `json:"first,omitempty"`
	Last    *int32                    `json:"last,omitempty"`
}

func (client *Client) PaymentEntries(params *PaymentEntriesParams) *PaymentEntryExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"PaymentEntryWhereInput", "PaymentEntryOrderByInput", "PaymentEntry"},
		"paymentEntries",
		[]string{"id", "createdAt", "updatedAt", "externalID", "productID", "product", "gatewayResponse", "amount", "discountID", "discount"})

	return &PaymentEntryExecArray{ret}
}

type PaymentEntriesConnectionParams struct {
	Where   *PaymentEntryWhereInput   `json:"where,omitempty"`
	OrderBy *PaymentEntryOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                    `json:"skip,omitempty"`
	After   *string                   `json:"after,omitempty"`
	Before  *string                   `json:"before,omitempty"`
	First   *int32                    `json:"first,omitempty"`
	Last    *int32                    `json:"last,omitempty"`
}

func (client *Client) PaymentEntriesConnection(params *PaymentEntriesConnectionParams) PaymentEntryConnectionExec {
	panic("not implemented")
}

func (client *Client) Person(params PersonWhereUniqueInput) *PersonExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"PersonWhereUniqueInput!", "Person"},
		"person",
		[]string{"id", "createdAt", "updatedAt", "mID", "name", "photo", "birthday", "from", "tags"})

	return &PersonExec{ret}
}

type PersonsParams struct {
	Where   *PersonWhereInput   `json:"where,omitempty"`
	OrderBy *PersonOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32              `json:"skip,omitempty"`
	After   *string             `json:"after,omitempty"`
	Before  *string             `json:"before,omitempty"`
	First   *int32              `json:"first,omitempty"`
	Last    *int32              `json:"last,omitempty"`
}

func (client *Client) Persons(params *PersonsParams) *PersonExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"PersonWhereInput", "PersonOrderByInput", "Person"},
		"persons",
		[]string{"id", "createdAt", "updatedAt", "mID", "name", "photo", "birthday", "from", "tags"})

	return &PersonExecArray{ret}
}

type PersonsConnectionParams struct {
	Where   *PersonWhereInput   `json:"where,omitempty"`
	OrderBy *PersonOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32              `json:"skip,omitempty"`
	After   *string             `json:"after,omitempty"`
	Before  *string             `json:"before,omitempty"`
	First   *int32              `json:"first,omitempty"`
	Last    *int32              `json:"last,omitempty"`
}

func (client *Client) PersonsConnection(params *PersonsConnectionParams) PersonConnectionExec {
	panic("not implemented")
}

type PhonesParams struct {
	Where   *PhoneWhereInput   `json:"where,omitempty"`
	OrderBy *PhoneOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32             `json:"skip,omitempty"`
	After   *string            `json:"after,omitempty"`
	Before  *string            `json:"before,omitempty"`
	First   *int32             `json:"first,omitempty"`
	Last    *int32             `json:"last,omitempty"`
}

func (client *Client) Phones(params *PhonesParams) *PhoneExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"PhoneWhereInput", "PhoneOrderByInput", "Phone"},
		"phones",
		[]string{"type", "countryCode", "number"})

	return &PhoneExecArray{ret}
}

type PhonesConnectionParams struct {
	Where   *PhoneWhereInput   `json:"where,omitempty"`
	OrderBy *PhoneOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32             `json:"skip,omitempty"`
	After   *string            `json:"after,omitempty"`
	Before  *string            `json:"before,omitempty"`
	First   *int32             `json:"first,omitempty"`
	Last    *int32             `json:"last,omitempty"`
}

func (client *Client) PhonesConnection(params *PhonesConnectionParams) PhoneConnectionExec {
	panic("not implemented")
}

func (client *Client) Traveler(params TravelerWhereUniqueInput) *TravelerExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"TravelerWhereUniqueInput!", "Traveler"},
		"traveler",
		[]string{"id", "createdAt", "updatedAt", "username"})

	return &TravelerExec{ret}
}

type TravelersParams struct {
	Where   *TravelerWhereInput   `json:"where,omitempty"`
	OrderBy *TravelerOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                `json:"skip,omitempty"`
	After   *string               `json:"after,omitempty"`
	Before  *string               `json:"before,omitempty"`
	First   *int32                `json:"first,omitempty"`
	Last    *int32                `json:"last,omitempty"`
}

func (client *Client) Travelers(params *TravelersParams) *TravelerExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"TravelerWhereInput", "TravelerOrderByInput", "Traveler"},
		"travelers",
		[]string{"id", "createdAt", "updatedAt", "username"})

	return &TravelerExecArray{ret}
}

type TravelersConnectionParams struct {
	Where   *TravelerWhereInput   `json:"where,omitempty"`
	OrderBy *TravelerOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                `json:"skip,omitempty"`
	After   *string               `json:"after,omitempty"`
	Before  *string               `json:"before,omitempty"`
	First   *int32                `json:"first,omitempty"`
	Last    *int32                `json:"last,omitempty"`
}

func (client *Client) TravelersConnection(params *TravelersConnectionParams) TravelerConnectionExec {
	panic("not implemented")
}

func (client *Client) CreateAttraction(params AttractionCreateInput) *AttractionExec {
	ret := client.Client.Create(
		params,
		[2]string{"AttractionCreateInput!", "Attraction"},
		"createAttraction",
		[]string{"id", "createdAt", "updatedAt", "name", "description", "address", "popularity", "types", "tags"})

	return &AttractionExec{ret}
}

type AttractionUpdateParams struct {
	Data  AttractionUpdateInput      `json:"data"`
	Where AttractionWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateAttraction(params AttractionUpdateParams) *AttractionExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"AttractionUpdateInput!", "AttractionWhereUniqueInput!", "Attraction"},
		"updateAttraction",
		[]string{"id", "createdAt", "updatedAt", "name", "description", "address", "popularity", "types", "tags"})

	return &AttractionExec{ret}
}

type AttractionUpdateManyParams struct {
	Data  AttractionUpdateManyMutationInput `json:"data"`
	Where *AttractionWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyAttractions(params AttractionUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"AttractionUpdateManyMutationInput!", "AttractionWhereInput"},
		"updateManyAttractions")
	return &BatchPayloadExec{exec}
}

type AttractionUpsertParams struct {
	Where  AttractionWhereUniqueInput `json:"where"`
	Create AttractionCreateInput      `json:"create"`
	Update AttractionUpdateInput      `json:"update"`
}

func (client *Client) UpsertAttraction(params AttractionUpsertParams) *AttractionExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"AttractionWhereUniqueInput!", "AttractionCreateInput!", "AttractionUpdateInput!", "Attraction"},
		"upsertAttraction",
		[]string{"id", "createdAt", "updatedAt", "name", "description", "address", "popularity", "types", "tags"})

	return &AttractionExec{ret}
}

func (client *Client) DeleteAttraction(params AttractionWhereUniqueInput) *AttractionExec {
	ret := client.Client.Delete(
		params,
		[2]string{"AttractionWhereUniqueInput!", "Attraction"},
		"deleteAttraction",
		[]string{"id", "createdAt", "updatedAt", "name", "description", "address", "popularity", "types", "tags"})

	return &AttractionExec{ret}
}

func (client *Client) DeleteManyAttractions(params *AttractionWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "AttractionWhereInput", "deleteManyAttractions")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreateCredential(params CredentialCreateInput) *CredentialExec {
	ret := client.Client.Create(
		params,
		[2]string{"CredentialCreateInput!", "Credential"},
		"createCredential",
		[]string{"id", "createdAt", "updatedAt", "displayName", "isMain", "type", "validated", "validationID", "value", "rawPassword", "hashedPassword"})

	return &CredentialExec{ret}
}

type CredentialUpdateParams struct {
	Data  CredentialUpdateInput      `json:"data"`
	Where CredentialWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateCredential(params CredentialUpdateParams) *CredentialExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"CredentialUpdateInput!", "CredentialWhereUniqueInput!", "Credential"},
		"updateCredential",
		[]string{"id", "createdAt", "updatedAt", "displayName", "isMain", "type", "validated", "validationID", "value", "rawPassword", "hashedPassword"})

	return &CredentialExec{ret}
}

type CredentialUpdateManyParams struct {
	Data  CredentialUpdateManyMutationInput `json:"data"`
	Where *CredentialWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyCredentials(params CredentialUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"CredentialUpdateManyMutationInput!", "CredentialWhereInput"},
		"updateManyCredentials")
	return &BatchPayloadExec{exec}
}

type CredentialUpsertParams struct {
	Where  CredentialWhereUniqueInput `json:"where"`
	Create CredentialCreateInput      `json:"create"`
	Update CredentialUpdateInput      `json:"update"`
}

func (client *Client) UpsertCredential(params CredentialUpsertParams) *CredentialExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"CredentialWhereUniqueInput!", "CredentialCreateInput!", "CredentialUpdateInput!", "Credential"},
		"upsertCredential",
		[]string{"id", "createdAt", "updatedAt", "displayName", "isMain", "type", "validated", "validationID", "value", "rawPassword", "hashedPassword"})

	return &CredentialExec{ret}
}

func (client *Client) DeleteCredential(params CredentialWhereUniqueInput) *CredentialExec {
	ret := client.Client.Delete(
		params,
		[2]string{"CredentialWhereUniqueInput!", "Credential"},
		"deleteCredential",
		[]string{"id", "createdAt", "updatedAt", "displayName", "isMain", "type", "validated", "validationID", "value", "rawPassword", "hashedPassword"})

	return &CredentialExec{ret}
}

func (client *Client) DeleteManyCredentials(params *CredentialWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "CredentialWhereInput", "deleteManyCredentials")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreateCreditCard(params CreditCardCreateInput) *CreditCardExec {
	ret := client.Client.Create(
		params,
		[2]string{"CreditCardCreateInput!", "CreditCard"},
		"createCreditCard",
		[]string{"id", "createdAt", "updatedAt", "cardNumber", "cardToken", "type", "lastUsed"})

	return &CreditCardExec{ret}
}

type CreditCardUpdateParams struct {
	Data  CreditCardUpdateInput      `json:"data"`
	Where CreditCardWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateCreditCard(params CreditCardUpdateParams) *CreditCardExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"CreditCardUpdateInput!", "CreditCardWhereUniqueInput!", "CreditCard"},
		"updateCreditCard",
		[]string{"id", "createdAt", "updatedAt", "cardNumber", "cardToken", "type", "lastUsed"})

	return &CreditCardExec{ret}
}

type CreditCardUpdateManyParams struct {
	Data  CreditCardUpdateManyMutationInput `json:"data"`
	Where *CreditCardWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyCreditCards(params CreditCardUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"CreditCardUpdateManyMutationInput!", "CreditCardWhereInput"},
		"updateManyCreditCards")
	return &BatchPayloadExec{exec}
}

type CreditCardUpsertParams struct {
	Where  CreditCardWhereUniqueInput `json:"where"`
	Create CreditCardCreateInput      `json:"create"`
	Update CreditCardUpdateInput      `json:"update"`
}

func (client *Client) UpsertCreditCard(params CreditCardUpsertParams) *CreditCardExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"CreditCardWhereUniqueInput!", "CreditCardCreateInput!", "CreditCardUpdateInput!", "CreditCard"},
		"upsertCreditCard",
		[]string{"id", "createdAt", "updatedAt", "cardNumber", "cardToken", "type", "lastUsed"})

	return &CreditCardExec{ret}
}

func (client *Client) DeleteCreditCard(params CreditCardWhereUniqueInput) *CreditCardExec {
	ret := client.Client.Delete(
		params,
		[2]string{"CreditCardWhereUniqueInput!", "CreditCard"},
		"deleteCreditCard",
		[]string{"id", "createdAt", "updatedAt", "cardNumber", "cardToken", "type", "lastUsed"})

	return &CreditCardExec{ret}
}

func (client *Client) DeleteManyCreditCards(params *CreditCardWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "CreditCardWhereInput", "deleteManyCreditCards")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreateEmail(params EmailCreateInput) *EmailExec {
	ret := client.Client.Create(
		params,
		[2]string{"EmailCreateInput!", "Email"},
		"createEmail",
		[]string{"type", "value", "extras"})

	return &EmailExec{ret}
}

type EmailUpdateManyParams struct {
	Data  EmailUpdateManyMutationInput `json:"data"`
	Where *EmailWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyEmails(params EmailUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"EmailUpdateManyMutationInput!", "EmailWhereInput"},
		"updateManyEmails")
	return &BatchPayloadExec{exec}
}

func (client *Client) DeleteManyEmails(params *EmailWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "EmailWhereInput", "deleteManyEmails")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreateIdentificationDocument(params IDentificationDocumentCreateInput) *IDentificationDocumentExec {
	ret := client.Client.Create(
		params,
		[2]string{"IdentificationDocumentCreateInput!", "IdentificationDocument"},
		"createIdentificationDocument",
		[]string{"id", "createdAt", "updatedAt", "type", "value"})

	return &IDentificationDocumentExec{ret}
}

type IDentificationDocumentUpdateParams struct {
	Data  IDentificationDocumentUpdateInput      `json:"data"`
	Where IDentificationDocumentWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateIdentificationDocument(params IDentificationDocumentUpdateParams) *IDentificationDocumentExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"IdentificationDocumentUpdateInput!", "IdentificationDocumentWhereUniqueInput!", "IdentificationDocument"},
		"updateIdentificationDocument",
		[]string{"id", "createdAt", "updatedAt", "type", "value"})

	return &IDentificationDocumentExec{ret}
}

type IDentificationDocumentUpdateManyParams struct {
	Data  IDentificationDocumentUpdateManyMutationInput `json:"data"`
	Where *IDentificationDocumentWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyIdentificationDocuments(params IDentificationDocumentUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"IdentificationDocumentUpdateManyMutationInput!", "IdentificationDocumentWhereInput"},
		"updateManyIdentificationDocuments")
	return &BatchPayloadExec{exec}
}

type IDentificationDocumentUpsertParams struct {
	Where  IDentificationDocumentWhereUniqueInput `json:"where"`
	Create IDentificationDocumentCreateInput      `json:"create"`
	Update IDentificationDocumentUpdateInput      `json:"update"`
}

func (client *Client) UpsertIdentificationDocument(params IDentificationDocumentUpsertParams) *IDentificationDocumentExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"IdentificationDocumentWhereUniqueInput!", "IdentificationDocumentCreateInput!", "IdentificationDocumentUpdateInput!", "IdentificationDocument"},
		"upsertIdentificationDocument",
		[]string{"id", "createdAt", "updatedAt", "type", "value"})

	return &IDentificationDocumentExec{ret}
}

func (client *Client) DeleteIdentificationDocument(params IDentificationDocumentWhereUniqueInput) *IDentificationDocumentExec {
	ret := client.Client.Delete(
		params,
		[2]string{"IdentificationDocumentWhereUniqueInput!", "IdentificationDocument"},
		"deleteIdentificationDocument",
		[]string{"id", "createdAt", "updatedAt", "type", "value"})

	return &IDentificationDocumentExec{ret}
}

func (client *Client) DeleteManyIdentificationDocuments(params *IDentificationDocumentWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "IdentificationDocumentWhereInput", "deleteManyIdentificationDocuments")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreateLocation(params LocationCreateInput) *LocationExec {
	ret := client.Client.Create(
		params,
		[2]string{"LocationCreateInput!", "Location"},
		"createLocation",
		[]string{"longitude", "latitude"})

	return &LocationExec{ret}
}

type LocationUpdateManyParams struct {
	Data  LocationUpdateManyMutationInput `json:"data"`
	Where *LocationWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyLocations(params LocationUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"LocationUpdateManyMutationInput!", "LocationWhereInput"},
		"updateManyLocations")
	return &BatchPayloadExec{exec}
}

func (client *Client) DeleteManyLocations(params *LocationWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "LocationWhereInput", "deleteManyLocations")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreatePartner(params PartnerCreateInput) *PartnerExec {
	ret := client.Client.Create(
		params,
		[2]string{"PartnerCreateInput!", "Partner"},
		"createPartner",
		[]string{"id", "createdAt", "updatedAt"})

	return &PartnerExec{ret}
}

type PartnerUpdateParams struct {
	Data  PartnerUpdateInput      `json:"data"`
	Where PartnerWhereUniqueInput `json:"where"`
}

func (client *Client) UpdatePartner(params PartnerUpdateParams) *PartnerExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"PartnerUpdateInput!", "PartnerWhereUniqueInput!", "Partner"},
		"updatePartner",
		[]string{"id", "createdAt", "updatedAt"})

	return &PartnerExec{ret}
}

type PartnerUpsertParams struct {
	Where  PartnerWhereUniqueInput `json:"where"`
	Create PartnerCreateInput      `json:"create"`
	Update PartnerUpdateInput      `json:"update"`
}

func (client *Client) UpsertPartner(params PartnerUpsertParams) *PartnerExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"PartnerWhereUniqueInput!", "PartnerCreateInput!", "PartnerUpdateInput!", "Partner"},
		"upsertPartner",
		[]string{"id", "createdAt", "updatedAt"})

	return &PartnerExec{ret}
}

func (client *Client) DeletePartner(params PartnerWhereUniqueInput) *PartnerExec {
	ret := client.Client.Delete(
		params,
		[2]string{"PartnerWhereUniqueInput!", "Partner"},
		"deletePartner",
		[]string{"id", "createdAt", "updatedAt"})

	return &PartnerExec{ret}
}

func (client *Client) DeleteManyPartners(params *PartnerWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "PartnerWhereInput", "deleteManyPartners")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreatePaymentEntry(params PaymentEntryCreateInput) *PaymentEntryExec {
	ret := client.Client.Create(
		params,
		[2]string{"PaymentEntryCreateInput!", "PaymentEntry"},
		"createPaymentEntry",
		[]string{"id", "createdAt", "updatedAt", "externalID", "productID", "product", "gatewayResponse", "amount", "discountID", "discount"})

	return &PaymentEntryExec{ret}
}

type PaymentEntryUpdateParams struct {
	Data  PaymentEntryUpdateInput      `json:"data"`
	Where PaymentEntryWhereUniqueInput `json:"where"`
}

func (client *Client) UpdatePaymentEntry(params PaymentEntryUpdateParams) *PaymentEntryExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"PaymentEntryUpdateInput!", "PaymentEntryWhereUniqueInput!", "PaymentEntry"},
		"updatePaymentEntry",
		[]string{"id", "createdAt", "updatedAt", "externalID", "productID", "product", "gatewayResponse", "amount", "discountID", "discount"})

	return &PaymentEntryExec{ret}
}

type PaymentEntryUpdateManyParams struct {
	Data  PaymentEntryUpdateManyMutationInput `json:"data"`
	Where *PaymentEntryWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyPaymentEntries(params PaymentEntryUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"PaymentEntryUpdateManyMutationInput!", "PaymentEntryWhereInput"},
		"updateManyPaymentEntries")
	return &BatchPayloadExec{exec}
}

type PaymentEntryUpsertParams struct {
	Where  PaymentEntryWhereUniqueInput `json:"where"`
	Create PaymentEntryCreateInput      `json:"create"`
	Update PaymentEntryUpdateInput      `json:"update"`
}

func (client *Client) UpsertPaymentEntry(params PaymentEntryUpsertParams) *PaymentEntryExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"PaymentEntryWhereUniqueInput!", "PaymentEntryCreateInput!", "PaymentEntryUpdateInput!", "PaymentEntry"},
		"upsertPaymentEntry",
		[]string{"id", "createdAt", "updatedAt", "externalID", "productID", "product", "gatewayResponse", "amount", "discountID", "discount"})

	return &PaymentEntryExec{ret}
}

func (client *Client) DeletePaymentEntry(params PaymentEntryWhereUniqueInput) *PaymentEntryExec {
	ret := client.Client.Delete(
		params,
		[2]string{"PaymentEntryWhereUniqueInput!", "PaymentEntry"},
		"deletePaymentEntry",
		[]string{"id", "createdAt", "updatedAt", "externalID", "productID", "product", "gatewayResponse", "amount", "discountID", "discount"})

	return &PaymentEntryExec{ret}
}

func (client *Client) DeleteManyPaymentEntries(params *PaymentEntryWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "PaymentEntryWhereInput", "deleteManyPaymentEntries")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreatePerson(params PersonCreateInput) *PersonExec {
	ret := client.Client.Create(
		params,
		[2]string{"PersonCreateInput!", "Person"},
		"createPerson",
		[]string{"id", "createdAt", "updatedAt", "mID", "name", "photo", "birthday", "from", "tags"})

	return &PersonExec{ret}
}

type PersonUpdateParams struct {
	Data  PersonUpdateInput      `json:"data"`
	Where PersonWhereUniqueInput `json:"where"`
}

func (client *Client) UpdatePerson(params PersonUpdateParams) *PersonExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"PersonUpdateInput!", "PersonWhereUniqueInput!", "Person"},
		"updatePerson",
		[]string{"id", "createdAt", "updatedAt", "mID", "name", "photo", "birthday", "from", "tags"})

	return &PersonExec{ret}
}

type PersonUpdateManyParams struct {
	Data  PersonUpdateManyMutationInput `json:"data"`
	Where *PersonWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyPersons(params PersonUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"PersonUpdateManyMutationInput!", "PersonWhereInput"},
		"updateManyPersons")
	return &BatchPayloadExec{exec}
}

type PersonUpsertParams struct {
	Where  PersonWhereUniqueInput `json:"where"`
	Create PersonCreateInput      `json:"create"`
	Update PersonUpdateInput      `json:"update"`
}

func (client *Client) UpsertPerson(params PersonUpsertParams) *PersonExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"PersonWhereUniqueInput!", "PersonCreateInput!", "PersonUpdateInput!", "Person"},
		"upsertPerson",
		[]string{"id", "createdAt", "updatedAt", "mID", "name", "photo", "birthday", "from", "tags"})

	return &PersonExec{ret}
}

func (client *Client) DeletePerson(params PersonWhereUniqueInput) *PersonExec {
	ret := client.Client.Delete(
		params,
		[2]string{"PersonWhereUniqueInput!", "Person"},
		"deletePerson",
		[]string{"id", "createdAt", "updatedAt", "mID", "name", "photo", "birthday", "from", "tags"})

	return &PersonExec{ret}
}

func (client *Client) DeleteManyPersons(params *PersonWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "PersonWhereInput", "deleteManyPersons")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreatePhone(params PhoneCreateInput) *PhoneExec {
	ret := client.Client.Create(
		params,
		[2]string{"PhoneCreateInput!", "Phone"},
		"createPhone",
		[]string{"type", "countryCode", "number"})

	return &PhoneExec{ret}
}

type PhoneUpdateManyParams struct {
	Data  PhoneUpdateManyMutationInput `json:"data"`
	Where *PhoneWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyPhones(params PhoneUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"PhoneUpdateManyMutationInput!", "PhoneWhereInput"},
		"updateManyPhones")
	return &BatchPayloadExec{exec}
}

func (client *Client) DeleteManyPhones(params *PhoneWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "PhoneWhereInput", "deleteManyPhones")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreateTraveler(params TravelerCreateInput) *TravelerExec {
	ret := client.Client.Create(
		params,
		[2]string{"TravelerCreateInput!", "Traveler"},
		"createTraveler",
		[]string{"id", "createdAt", "updatedAt", "username"})

	return &TravelerExec{ret}
}

type TravelerUpdateParams struct {
	Data  TravelerUpdateInput      `json:"data"`
	Where TravelerWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateTraveler(params TravelerUpdateParams) *TravelerExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"TravelerUpdateInput!", "TravelerWhereUniqueInput!", "Traveler"},
		"updateTraveler",
		[]string{"id", "createdAt", "updatedAt", "username"})

	return &TravelerExec{ret}
}

type TravelerUpdateManyParams struct {
	Data  TravelerUpdateManyMutationInput `json:"data"`
	Where *TravelerWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyTravelers(params TravelerUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"TravelerUpdateManyMutationInput!", "TravelerWhereInput"},
		"updateManyTravelers")
	return &BatchPayloadExec{exec}
}

type TravelerUpsertParams struct {
	Where  TravelerWhereUniqueInput `json:"where"`
	Create TravelerCreateInput      `json:"create"`
	Update TravelerUpdateInput      `json:"update"`
}

func (client *Client) UpsertTraveler(params TravelerUpsertParams) *TravelerExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"TravelerWhereUniqueInput!", "TravelerCreateInput!", "TravelerUpdateInput!", "Traveler"},
		"upsertTraveler",
		[]string{"id", "createdAt", "updatedAt", "username"})

	return &TravelerExec{ret}
}

func (client *Client) DeleteTraveler(params TravelerWhereUniqueInput) *TravelerExec {
	ret := client.Client.Delete(
		params,
		[2]string{"TravelerWhereUniqueInput!", "Traveler"},
		"deleteTraveler",
		[]string{"id", "createdAt", "updatedAt", "username"})

	return &TravelerExec{ret}
}

func (client *Client) DeleteManyTravelers(params *TravelerWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "TravelerWhereInput", "deleteManyTravelers")
	return &BatchPayloadExec{exec}
}

type CreditCardOrderByInput string

const (
	CreditCardOrderByInputIDAsc          CreditCardOrderByInput = "id_ASC"
	CreditCardOrderByInputIDDesc         CreditCardOrderByInput = "id_DESC"
	CreditCardOrderByInputCreatedAtAsc   CreditCardOrderByInput = "createdAt_ASC"
	CreditCardOrderByInputCreatedAtDesc  CreditCardOrderByInput = "createdAt_DESC"
	CreditCardOrderByInputUpdatedAtAsc   CreditCardOrderByInput = "updatedAt_ASC"
	CreditCardOrderByInputUpdatedAtDesc  CreditCardOrderByInput = "updatedAt_DESC"
	CreditCardOrderByInputCardNumberAsc  CreditCardOrderByInput = "cardNumber_ASC"
	CreditCardOrderByInputCardNumberDesc CreditCardOrderByInput = "cardNumber_DESC"
	CreditCardOrderByInputCardTokenAsc   CreditCardOrderByInput = "cardToken_ASC"
	CreditCardOrderByInputCardTokenDesc  CreditCardOrderByInput = "cardToken_DESC"
	CreditCardOrderByInputTypeAsc        CreditCardOrderByInput = "type_ASC"
	CreditCardOrderByInputTypeDesc       CreditCardOrderByInput = "type_DESC"
	CreditCardOrderByInputLastUsedAsc    CreditCardOrderByInput = "lastUsed_ASC"
	CreditCardOrderByInputLastUsedDesc   CreditCardOrderByInput = "lastUsed_DESC"
)

type CredentialType string

const (
	CredentialTypeEmail     CredentialType = "EMAIL"
	CredentialTypePhone     CredentialType = "PHONE"
	CredentialTypeGmail     CredentialType = "GMAIL"
	CredentialTypeFacebook  CredentialType = "FACEBOOK"
	CredentialTypeAnonymous CredentialType = "ANONYMOUS"
)

type CreditCardType string

const (
	CreditCardTypeVisa       CreditCardType = "VISA"
	CreditCardTypeMastercard CreditCardType = "MASTERCARD"
	CreditCardTypeAmerican   CreditCardType = "AMERICAN"
)

type TravelerOrderByInput string

const (
	TravelerOrderByInputIDAsc         TravelerOrderByInput = "id_ASC"
	TravelerOrderByInputIDDesc        TravelerOrderByInput = "id_DESC"
	TravelerOrderByInputCreatedAtAsc  TravelerOrderByInput = "createdAt_ASC"
	TravelerOrderByInputCreatedAtDesc TravelerOrderByInput = "createdAt_DESC"
	TravelerOrderByInputUpdatedAtAsc  TravelerOrderByInput = "updatedAt_ASC"
	TravelerOrderByInputUpdatedAtDesc TravelerOrderByInput = "updatedAt_DESC"
	TravelerOrderByInputUsernameAsc   TravelerOrderByInput = "username_ASC"
	TravelerOrderByInputUsernameDesc  TravelerOrderByInput = "username_DESC"
)

type AttractionOrderByInput string

const (
	AttractionOrderByInputIDAsc           AttractionOrderByInput = "id_ASC"
	AttractionOrderByInputIDDesc          AttractionOrderByInput = "id_DESC"
	AttractionOrderByInputCreatedAtAsc    AttractionOrderByInput = "createdAt_ASC"
	AttractionOrderByInputCreatedAtDesc   AttractionOrderByInput = "createdAt_DESC"
	AttractionOrderByInputUpdatedAtAsc    AttractionOrderByInput = "updatedAt_ASC"
	AttractionOrderByInputUpdatedAtDesc   AttractionOrderByInput = "updatedAt_DESC"
	AttractionOrderByInputNameAsc         AttractionOrderByInput = "name_ASC"
	AttractionOrderByInputNameDesc        AttractionOrderByInput = "name_DESC"
	AttractionOrderByInputDescriptionAsc  AttractionOrderByInput = "description_ASC"
	AttractionOrderByInputDescriptionDesc AttractionOrderByInput = "description_DESC"
	AttractionOrderByInputAddressAsc      AttractionOrderByInput = "address_ASC"
	AttractionOrderByInputAddressDesc     AttractionOrderByInput = "address_DESC"
	AttractionOrderByInputPopularityAsc   AttractionOrderByInput = "popularity_ASC"
	AttractionOrderByInputPopularityDesc  AttractionOrderByInput = "popularity_DESC"
)

type LocationOrderByInput string

const (
	LocationOrderByInputLongitudeAsc  LocationOrderByInput = "longitude_ASC"
	LocationOrderByInputLongitudeDesc LocationOrderByInput = "longitude_DESC"
	LocationOrderByInputLatitudeAsc   LocationOrderByInput = "latitude_ASC"
	LocationOrderByInputLatitudeDesc  LocationOrderByInput = "latitude_DESC"
	LocationOrderByInputIDAsc         LocationOrderByInput = "id_ASC"
	LocationOrderByInputIDDesc        LocationOrderByInput = "id_DESC"
	LocationOrderByInputCreatedAtAsc  LocationOrderByInput = "createdAt_ASC"
	LocationOrderByInputCreatedAtDesc LocationOrderByInput = "createdAt_DESC"
	LocationOrderByInputUpdatedAtAsc  LocationOrderByInput = "updatedAt_ASC"
	LocationOrderByInputUpdatedAtDesc LocationOrderByInput = "updatedAt_DESC"
)

type EmailOrderByInput string

const (
	EmailOrderByInputTypeAsc       EmailOrderByInput = "type_ASC"
	EmailOrderByInputTypeDesc      EmailOrderByInput = "type_DESC"
	EmailOrderByInputValueAsc      EmailOrderByInput = "value_ASC"
	EmailOrderByInputValueDesc     EmailOrderByInput = "value_DESC"
	EmailOrderByInputIDAsc         EmailOrderByInput = "id_ASC"
	EmailOrderByInputIDDesc        EmailOrderByInput = "id_DESC"
	EmailOrderByInputCreatedAtAsc  EmailOrderByInput = "createdAt_ASC"
	EmailOrderByInputCreatedAtDesc EmailOrderByInput = "createdAt_DESC"
	EmailOrderByInputUpdatedAtAsc  EmailOrderByInput = "updatedAt_ASC"
	EmailOrderByInputUpdatedAtDesc EmailOrderByInput = "updatedAt_DESC"
)

type PaymentEntryOrderByInput string

const (
	PaymentEntryOrderByInputIDAsc               PaymentEntryOrderByInput = "id_ASC"
	PaymentEntryOrderByInputIDDesc              PaymentEntryOrderByInput = "id_DESC"
	PaymentEntryOrderByInputCreatedAtAsc        PaymentEntryOrderByInput = "createdAt_ASC"
	PaymentEntryOrderByInputCreatedAtDesc       PaymentEntryOrderByInput = "createdAt_DESC"
	PaymentEntryOrderByInputUpdatedAtAsc        PaymentEntryOrderByInput = "updatedAt_ASC"
	PaymentEntryOrderByInputUpdatedAtDesc       PaymentEntryOrderByInput = "updatedAt_DESC"
	PaymentEntryOrderByInputExternalIdAsc       PaymentEntryOrderByInput = "externalID_ASC"
	PaymentEntryOrderByInputExternalIdDesc      PaymentEntryOrderByInput = "externalID_DESC"
	PaymentEntryOrderByInputProductIdAsc        PaymentEntryOrderByInput = "productID_ASC"
	PaymentEntryOrderByInputProductIdDesc       PaymentEntryOrderByInput = "productID_DESC"
	PaymentEntryOrderByInputProductAsc          PaymentEntryOrderByInput = "product_ASC"
	PaymentEntryOrderByInputProductDesc         PaymentEntryOrderByInput = "product_DESC"
	PaymentEntryOrderByInputGatewayResponseAsc  PaymentEntryOrderByInput = "gatewayResponse_ASC"
	PaymentEntryOrderByInputGatewayResponseDesc PaymentEntryOrderByInput = "gatewayResponse_DESC"
	PaymentEntryOrderByInputAmountAsc           PaymentEntryOrderByInput = "amount_ASC"
	PaymentEntryOrderByInputAmountDesc          PaymentEntryOrderByInput = "amount_DESC"
	PaymentEntryOrderByInputDiscountIdAsc       PaymentEntryOrderByInput = "discountID_ASC"
	PaymentEntryOrderByInputDiscountIdDesc      PaymentEntryOrderByInput = "discountID_DESC"
	PaymentEntryOrderByInputDiscountAsc         PaymentEntryOrderByInput = "discount_ASC"
	PaymentEntryOrderByInputDiscountDesc        PaymentEntryOrderByInput = "discount_DESC"
)

type CredentialOrderByInput string

const (
	CredentialOrderByInputIDAsc              CredentialOrderByInput = "id_ASC"
	CredentialOrderByInputIDDesc             CredentialOrderByInput = "id_DESC"
	CredentialOrderByInputCreatedAtAsc       CredentialOrderByInput = "createdAt_ASC"
	CredentialOrderByInputCreatedAtDesc      CredentialOrderByInput = "createdAt_DESC"
	CredentialOrderByInputUpdatedAtAsc       CredentialOrderByInput = "updatedAt_ASC"
	CredentialOrderByInputUpdatedAtDesc      CredentialOrderByInput = "updatedAt_DESC"
	CredentialOrderByInputDisplayNameAsc     CredentialOrderByInput = "displayName_ASC"
	CredentialOrderByInputDisplayNameDesc    CredentialOrderByInput = "displayName_DESC"
	CredentialOrderByInputIsMainAsc          CredentialOrderByInput = "isMain_ASC"
	CredentialOrderByInputIsMainDesc         CredentialOrderByInput = "isMain_DESC"
	CredentialOrderByInputTypeAsc            CredentialOrderByInput = "type_ASC"
	CredentialOrderByInputTypeDesc           CredentialOrderByInput = "type_DESC"
	CredentialOrderByInputValidatedAsc       CredentialOrderByInput = "validated_ASC"
	CredentialOrderByInputValidatedDesc      CredentialOrderByInput = "validated_DESC"
	CredentialOrderByInputValidationIdAsc    CredentialOrderByInput = "validationID_ASC"
	CredentialOrderByInputValidationIdDesc   CredentialOrderByInput = "validationID_DESC"
	CredentialOrderByInputValueAsc           CredentialOrderByInput = "value_ASC"
	CredentialOrderByInputValueDesc          CredentialOrderByInput = "value_DESC"
	CredentialOrderByInputRawPasswordAsc     CredentialOrderByInput = "rawPassword_ASC"
	CredentialOrderByInputRawPasswordDesc    CredentialOrderByInput = "rawPassword_DESC"
	CredentialOrderByInputHashedPasswordAsc  CredentialOrderByInput = "hashedPassword_ASC"
	CredentialOrderByInputHashedPasswordDesc CredentialOrderByInput = "hashedPassword_DESC"
)

type IDentificationType string

const (
	IDentificationTypeDni      IDentificationType = "DNI"
	IDentificationTypePassport IDentificationType = "PASSPORT"
)

type PersonOrderByInput string

const (
	PersonOrderByInputIDAsc         PersonOrderByInput = "id_ASC"
	PersonOrderByInputIDDesc        PersonOrderByInput = "id_DESC"
	PersonOrderByInputCreatedAtAsc  PersonOrderByInput = "createdAt_ASC"
	PersonOrderByInputCreatedAtDesc PersonOrderByInput = "createdAt_DESC"
	PersonOrderByInputUpdatedAtAsc  PersonOrderByInput = "updatedAt_ASC"
	PersonOrderByInputUpdatedAtDesc PersonOrderByInput = "updatedAt_DESC"
	PersonOrderByInputMIdAsc        PersonOrderByInput = "mID_ASC"
	PersonOrderByInputMIdDesc       PersonOrderByInput = "mID_DESC"
	PersonOrderByInputNameAsc       PersonOrderByInput = "name_ASC"
	PersonOrderByInputNameDesc      PersonOrderByInput = "name_DESC"
	PersonOrderByInputPhotoAsc      PersonOrderByInput = "photo_ASC"
	PersonOrderByInputPhotoDesc     PersonOrderByInput = "photo_DESC"
	PersonOrderByInputBirthdayAsc   PersonOrderByInput = "birthday_ASC"
	PersonOrderByInputBirthdayDesc  PersonOrderByInput = "birthday_DESC"
	PersonOrderByInputFromAsc       PersonOrderByInput = "from_ASC"
	PersonOrderByInputFromDesc      PersonOrderByInput = "from_DESC"
)

type AttractionType string

const (
	AttractionTypeAdventure AttractionType = "ADVENTURE"
	AttractionTypeHistory   AttractionType = "HISTORY"
)

type CommunicationType string

const (
	CommunicationTypeEmail CommunicationType = "EMAIL"
	CommunicationTypePhone CommunicationType = "PHONE"
)

type IDentificationDocumentOrderByInput string

const (
	IDentificationDocumentOrderByInputIDAsc         IDentificationDocumentOrderByInput = "id_ASC"
	IDentificationDocumentOrderByInputIDDesc        IDentificationDocumentOrderByInput = "id_DESC"
	IDentificationDocumentOrderByInputCreatedAtAsc  IDentificationDocumentOrderByInput = "createdAt_ASC"
	IDentificationDocumentOrderByInputCreatedAtDesc IDentificationDocumentOrderByInput = "createdAt_DESC"
	IDentificationDocumentOrderByInputUpdatedAtAsc  IDentificationDocumentOrderByInput = "updatedAt_ASC"
	IDentificationDocumentOrderByInputUpdatedAtDesc IDentificationDocumentOrderByInput = "updatedAt_DESC"
	IDentificationDocumentOrderByInputTypeAsc       IDentificationDocumentOrderByInput = "type_ASC"
	IDentificationDocumentOrderByInputTypeDesc      IDentificationDocumentOrderByInput = "type_DESC"
	IDentificationDocumentOrderByInputValueAsc      IDentificationDocumentOrderByInput = "value_ASC"
	IDentificationDocumentOrderByInputValueDesc     IDentificationDocumentOrderByInput = "value_DESC"
)

type PartnerOrderByInput string

const (
	PartnerOrderByInputIDAsc         PartnerOrderByInput = "id_ASC"
	PartnerOrderByInputIDDesc        PartnerOrderByInput = "id_DESC"
	PartnerOrderByInputCreatedAtAsc  PartnerOrderByInput = "createdAt_ASC"
	PartnerOrderByInputCreatedAtDesc PartnerOrderByInput = "createdAt_DESC"
	PartnerOrderByInputUpdatedAtAsc  PartnerOrderByInput = "updatedAt_ASC"
	PartnerOrderByInputUpdatedAtDesc PartnerOrderByInput = "updatedAt_DESC"
)

type MutationType string

const (
	MutationTypeCreated MutationType = "CREATED"
	MutationTypeUpdated MutationType = "UPDATED"
	MutationTypeDeleted MutationType = "DELETED"
)

type PhoneOrderByInput string

const (
	PhoneOrderByInputTypeAsc         PhoneOrderByInput = "type_ASC"
	PhoneOrderByInputTypeDesc        PhoneOrderByInput = "type_DESC"
	PhoneOrderByInputCountryCodeAsc  PhoneOrderByInput = "countryCode_ASC"
	PhoneOrderByInputCountryCodeDesc PhoneOrderByInput = "countryCode_DESC"
	PhoneOrderByInputNumberAsc       PhoneOrderByInput = "number_ASC"
	PhoneOrderByInputNumberDesc      PhoneOrderByInput = "number_DESC"
	PhoneOrderByInputIDAsc           PhoneOrderByInput = "id_ASC"
	PhoneOrderByInputIDDesc          PhoneOrderByInput = "id_DESC"
	PhoneOrderByInputCreatedAtAsc    PhoneOrderByInput = "createdAt_ASC"
	PhoneOrderByInputCreatedAtDesc   PhoneOrderByInput = "createdAt_DESC"
	PhoneOrderByInputUpdatedAtAsc    PhoneOrderByInput = "updatedAt_ASC"
	PhoneOrderByInputUpdatedAtDesc   PhoneOrderByInput = "updatedAt_DESC"
)

type IDentificationDocumentUpsertWithoutPersonInput struct {
	Update IDentificationDocumentUpdateWithoutPersonDataInput `json:"update"`
	Create IDentificationDocumentCreateWithoutPersonInput     `json:"create"`
}

type AttractionWhereUniqueInput struct {
	ID *string `json:"id,omitempty"`
}

type PartnerUpsertWithoutAttractionInput struct {
	Update PartnerUpdateWithoutAttractionDataInput `json:"update"`
	Create PartnerCreateWithoutAttractionInput     `json:"create"`
}

type IDentificationDocumentWhereInput struct {
	ID                 *string                            `json:"id,omitempty"`
	IDNot              *string                            `json:"id_not,omitempty"`
	IDIn               []string                           `json:"id_in,omitempty"`
	IDNotIn            []string                           `json:"id_not_in,omitempty"`
	IDLt               *string                            `json:"id_lt,omitempty"`
	IDLte              *string                            `json:"id_lte,omitempty"`
	IDGt               *string                            `json:"id_gt,omitempty"`
	IDGte              *string                            `json:"id_gte,omitempty"`
	IDContains         *string                            `json:"id_contains,omitempty"`
	IDNotContains      *string                            `json:"id_not_contains,omitempty"`
	IDStartsWith       *string                            `json:"id_starts_with,omitempty"`
	IDNotStartsWith    *string                            `json:"id_not_starts_with,omitempty"`
	IDEndsWith         *string                            `json:"id_ends_with,omitempty"`
	IDNotEndsWith      *string                            `json:"id_not_ends_with,omitempty"`
	CreatedAt          *string                            `json:"createdAt,omitempty"`
	CreatedAtNot       *string                            `json:"createdAt_not,omitempty"`
	CreatedAtIn        []string                           `json:"createdAt_in,omitempty"`
	CreatedAtNotIn     []string                           `json:"createdAt_not_in,omitempty"`
	CreatedAtLt        *string                            `json:"createdAt_lt,omitempty"`
	CreatedAtLte       *string                            `json:"createdAt_lte,omitempty"`
	CreatedAtGt        *string                            `json:"createdAt_gt,omitempty"`
	CreatedAtGte       *string                            `json:"createdAt_gte,omitempty"`
	UpdatedAt          *string                            `json:"updatedAt,omitempty"`
	UpdatedAtNot       *string                            `json:"updatedAt_not,omitempty"`
	UpdatedAtIn        []string                           `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn     []string                           `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt        *string                            `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte       *string                            `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt        *string                            `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte       *string                            `json:"updatedAt_gte,omitempty"`
	Person             *PersonWhereInput                  `json:"person,omitempty"`
	Type               *IDentificationType                `json:"type,omitempty"`
	TypeNot            *IDentificationType                `json:"type_not,omitempty"`
	TypeIn             []IDentificationType               `json:"type_in,omitempty"`
	TypeNotIn          []IDentificationType               `json:"type_not_in,omitempty"`
	Value              *string                            `json:"value,omitempty"`
	ValueNot           *string                            `json:"value_not,omitempty"`
	ValueIn            []string                           `json:"value_in,omitempty"`
	ValueNotIn         []string                           `json:"value_not_in,omitempty"`
	ValueLt            *string                            `json:"value_lt,omitempty"`
	ValueLte           *string                            `json:"value_lte,omitempty"`
	ValueGt            *string                            `json:"value_gt,omitempty"`
	ValueGte           *string                            `json:"value_gte,omitempty"`
	ValueContains      *string                            `json:"value_contains,omitempty"`
	ValueNotContains   *string                            `json:"value_not_contains,omitempty"`
	ValueStartsWith    *string                            `json:"value_starts_with,omitempty"`
	ValueNotStartsWith *string                            `json:"value_not_starts_with,omitempty"`
	ValueEndsWith      *string                            `json:"value_ends_with,omitempty"`
	ValueNotEndsWith   *string                            `json:"value_not_ends_with,omitempty"`
	And                []IDentificationDocumentWhereInput `json:"AND,omitempty"`
	Or                 []IDentificationDocumentWhereInput `json:"OR,omitempty"`
	Not                []IDentificationDocumentWhereInput `json:"NOT,omitempty"`
}

type LocationUpdateOneRequiredInput struct {
	Create *LocationCreateInput       `json:"create,omitempty"`
	Update *LocationUpdateDataInput   `json:"update,omitempty"`
	Upsert *LocationUpsertNestedInput `json:"upsert,omitempty"`
}

type PersonWhereInput struct {
	ID                 *string                           `json:"id,omitempty"`
	IDNot              *string                           `json:"id_not,omitempty"`
	IDIn               []string                          `json:"id_in,omitempty"`
	IDNotIn            []string                          `json:"id_not_in,omitempty"`
	IDLt               *string                           `json:"id_lt,omitempty"`
	IDLte              *string                           `json:"id_lte,omitempty"`
	IDGt               *string                           `json:"id_gt,omitempty"`
	IDGte              *string                           `json:"id_gte,omitempty"`
	IDContains         *string                           `json:"id_contains,omitempty"`
	IDNotContains      *string                           `json:"id_not_contains,omitempty"`
	IDStartsWith       *string                           `json:"id_starts_with,omitempty"`
	IDNotStartsWith    *string                           `json:"id_not_starts_with,omitempty"`
	IDEndsWith         *string                           `json:"id_ends_with,omitempty"`
	IDNotEndsWith      *string                           `json:"id_not_ends_with,omitempty"`
	CreatedAt          *string                           `json:"createdAt,omitempty"`
	CreatedAtNot       *string                           `json:"createdAt_not,omitempty"`
	CreatedAtIn        []string                          `json:"createdAt_in,omitempty"`
	CreatedAtNotIn     []string                          `json:"createdAt_not_in,omitempty"`
	CreatedAtLt        *string                           `json:"createdAt_lt,omitempty"`
	CreatedAtLte       *string                           `json:"createdAt_lte,omitempty"`
	CreatedAtGt        *string                           `json:"createdAt_gt,omitempty"`
	CreatedAtGte       *string                           `json:"createdAt_gte,omitempty"`
	UpdatedAt          *string                           `json:"updatedAt,omitempty"`
	UpdatedAtNot       *string                           `json:"updatedAt_not,omitempty"`
	UpdatedAtIn        []string                          `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn     []string                          `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt        *string                           `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte       *string                           `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt        *string                           `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte       *string                           `json:"updatedAt_gte,omitempty"`
	MId                *string                           `json:"mID,omitempty"`
	MIdNot             *string                           `json:"mID_not,omitempty"`
	MIdIn              []string                          `json:"mID_in,omitempty"`
	MIdNotIn           []string                          `json:"mID_not_in,omitempty"`
	MIdLt              *string                           `json:"mID_lt,omitempty"`
	MIdLte             *string                           `json:"mID_lte,omitempty"`
	MIdGt              *string                           `json:"mID_gt,omitempty"`
	MIdGte             *string                           `json:"mID_gte,omitempty"`
	MIdContains        *string                           `json:"mID_contains,omitempty"`
	MIdNotContains     *string                           `json:"mID_not_contains,omitempty"`
	MIdStartsWith      *string                           `json:"mID_starts_with,omitempty"`
	MIdNotStartsWith   *string                           `json:"mID_not_starts_with,omitempty"`
	MIdEndsWith        *string                           `json:"mID_ends_with,omitempty"`
	MIdNotEndsWith     *string                           `json:"mID_not_ends_with,omitempty"`
	Name               *string                           `json:"name,omitempty"`
	NameNot            *string                           `json:"name_not,omitempty"`
	NameIn             []string                          `json:"name_in,omitempty"`
	NameNotIn          []string                          `json:"name_not_in,omitempty"`
	NameLt             *string                           `json:"name_lt,omitempty"`
	NameLte            *string                           `json:"name_lte,omitempty"`
	NameGt             *string                           `json:"name_gt,omitempty"`
	NameGte            *string                           `json:"name_gte,omitempty"`
	NameContains       *string                           `json:"name_contains,omitempty"`
	NameNotContains    *string                           `json:"name_not_contains,omitempty"`
	NameStartsWith     *string                           `json:"name_starts_with,omitempty"`
	NameNotStartsWith  *string                           `json:"name_not_starts_with,omitempty"`
	NameEndsWith       *string                           `json:"name_ends_with,omitempty"`
	NameNotEndsWith    *string                           `json:"name_not_ends_with,omitempty"`
	Photo              *string                           `json:"photo,omitempty"`
	PhotoNot           *string                           `json:"photo_not,omitempty"`
	PhotoIn            []string                          `json:"photo_in,omitempty"`
	PhotoNotIn         []string                          `json:"photo_not_in,omitempty"`
	PhotoLt            *string                           `json:"photo_lt,omitempty"`
	PhotoLte           *string                           `json:"photo_lte,omitempty"`
	PhotoGt            *string                           `json:"photo_gt,omitempty"`
	PhotoGte           *string                           `json:"photo_gte,omitempty"`
	PhotoContains      *string                           `json:"photo_contains,omitempty"`
	PhotoNotContains   *string                           `json:"photo_not_contains,omitempty"`
	PhotoStartsWith    *string                           `json:"photo_starts_with,omitempty"`
	PhotoNotStartsWith *string                           `json:"photo_not_starts_with,omitempty"`
	PhotoEndsWith      *string                           `json:"photo_ends_with,omitempty"`
	PhotoNotEndsWith   *string                           `json:"photo_not_ends_with,omitempty"`
	Birthday           *string                           `json:"birthday,omitempty"`
	BirthdayNot        *string                           `json:"birthday_not,omitempty"`
	BirthdayIn         []string                          `json:"birthday_in,omitempty"`
	BirthdayNotIn      []string                          `json:"birthday_not_in,omitempty"`
	BirthdayLt         *string                           `json:"birthday_lt,omitempty"`
	BirthdayLte        *string                           `json:"birthday_lte,omitempty"`
	BirthdayGt         *string                           `json:"birthday_gt,omitempty"`
	BirthdayGte        *string                           `json:"birthday_gte,omitempty"`
	From               *string                           `json:"from,omitempty"`
	FromNot            *string                           `json:"from_not,omitempty"`
	FromIn             []string                          `json:"from_in,omitempty"`
	FromNotIn          []string                          `json:"from_not_in,omitempty"`
	FromLt             *string                           `json:"from_lt,omitempty"`
	FromLte            *string                           `json:"from_lte,omitempty"`
	FromGt             *string                           `json:"from_gt,omitempty"`
	FromGte            *string                           `json:"from_gte,omitempty"`
	FromContains       *string                           `json:"from_contains,omitempty"`
	FromNotContains    *string                           `json:"from_not_contains,omitempty"`
	FromStartsWith     *string                           `json:"from_starts_with,omitempty"`
	FromNotStartsWith  *string                           `json:"from_not_starts_with,omitempty"`
	FromEndsWith       *string                           `json:"from_ends_with,omitempty"`
	FromNotEndsWith    *string                           `json:"from_not_ends_with,omitempty"`
	ChannelsPhoneEvery *PhoneWhereInput                  `json:"channelsPhone_every,omitempty"`
	ChannelsPhoneSome  *PhoneWhereInput                  `json:"channelsPhone_some,omitempty"`
	ChannelsPhoneNone  *PhoneWhereInput                  `json:"channelsPhone_none,omitempty"`
	ChannelsEmailEvery *EmailWhereInput                  `json:"channelsEmail_every,omitempty"`
	ChannelsEmailSome  *EmailWhereInput                  `json:"channelsEmail_some,omitempty"`
	ChannelsEmailNone  *EmailWhereInput                  `json:"channelsEmail_none,omitempty"`
	IDentification     *IDentificationDocumentWhereInput `json:"identification,omitempty"`
	CredentialsEvery   *CredentialWhereInput             `json:"credentials_every,omitempty"`
	CredentialsSome    *CredentialWhereInput             `json:"credentials_some,omitempty"`
	CredentialsNone    *CredentialWhereInput             `json:"credentials_none,omitempty"`
	And                []PersonWhereInput                `json:"AND,omitempty"`
	Or                 []PersonWhereInput                `json:"OR,omitempty"`
	Not                []PersonWhereInput                `json:"NOT,omitempty"`
}

type IDentificationDocumentCreateWithoutPersonInput struct {
	Type  IDentificationType `json:"type"`
	Value string             `json:"value"`
}

type CreditCardUpdateManyMutationInput struct {
	CardNumber *string         `json:"cardNumber,omitempty"`
	CardToken  *string         `json:"cardToken,omitempty"`
	Type       *CreditCardType `json:"type,omitempty"`
	LastUsed   *string         `json:"lastUsed,omitempty"`
}

type PersonCreatetagsInput struct {
	Set []string `json:"set,omitempty"`
}

type LocationUpdateDataInput struct {
	Longitude *float64 `json:"longitude,omitempty"`
	Latitude  *float64 `json:"latitude,omitempty"`
}

type CredentialCreateManyWithoutOwnerInput struct {
	Create  []CredentialCreateWithoutOwnerInput `json:"create,omitempty"`
	Connect []CredentialWhereUniqueInput        `json:"connect,omitempty"`
}

type PhoneSubscriptionWhereInput struct {
	MutationIn                 []MutationType                `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                       `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                      `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                      `json:"updatedFields_contains_some,omitempty"`
	Node                       *PhoneWhereInput              `json:"node,omitempty"`
	And                        []PhoneSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []PhoneSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []PhoneSubscriptionWhereInput `json:"NOT,omitempty"`
}

type CredentialCreateWithoutOwnerInput struct {
	DisplayName    *string         `json:"displayName,omitempty"`
	IsMain         bool            `json:"isMain"`
	Type           *CredentialType `json:"type,omitempty"`
	Validated      *bool           `json:"validated,omitempty"`
	ValidationId   *string         `json:"validationID,omitempty"`
	Value          string          `json:"value"`
	RawPassword    *string         `json:"rawPassword,omitempty"`
	HashedPassword string          `json:"hashedPassword"`
}

type AttractionWhereInput struct {
	ID                       *string                `json:"id,omitempty"`
	IDNot                    *string                `json:"id_not,omitempty"`
	IDIn                     []string               `json:"id_in,omitempty"`
	IDNotIn                  []string               `json:"id_not_in,omitempty"`
	IDLt                     *string                `json:"id_lt,omitempty"`
	IDLte                    *string                `json:"id_lte,omitempty"`
	IDGt                     *string                `json:"id_gt,omitempty"`
	IDGte                    *string                `json:"id_gte,omitempty"`
	IDContains               *string                `json:"id_contains,omitempty"`
	IDNotContains            *string                `json:"id_not_contains,omitempty"`
	IDStartsWith             *string                `json:"id_starts_with,omitempty"`
	IDNotStartsWith          *string                `json:"id_not_starts_with,omitempty"`
	IDEndsWith               *string                `json:"id_ends_with,omitempty"`
	IDNotEndsWith            *string                `json:"id_not_ends_with,omitempty"`
	CreatedAt                *string                `json:"createdAt,omitempty"`
	CreatedAtNot             *string                `json:"createdAt_not,omitempty"`
	CreatedAtIn              []string               `json:"createdAt_in,omitempty"`
	CreatedAtNotIn           []string               `json:"createdAt_not_in,omitempty"`
	CreatedAtLt              *string                `json:"createdAt_lt,omitempty"`
	CreatedAtLte             *string                `json:"createdAt_lte,omitempty"`
	CreatedAtGt              *string                `json:"createdAt_gt,omitempty"`
	CreatedAtGte             *string                `json:"createdAt_gte,omitempty"`
	UpdatedAt                *string                `json:"updatedAt,omitempty"`
	UpdatedAtNot             *string                `json:"updatedAt_not,omitempty"`
	UpdatedAtIn              []string               `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn           []string               `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt              *string                `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte             *string                `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt              *string                `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte             *string                `json:"updatedAt_gte,omitempty"`
	Owner                    *PartnerWhereInput     `json:"owner,omitempty"`
	Name                     *string                `json:"name,omitempty"`
	NameNot                  *string                `json:"name_not,omitempty"`
	NameIn                   []string               `json:"name_in,omitempty"`
	NameNotIn                []string               `json:"name_not_in,omitempty"`
	NameLt                   *string                `json:"name_lt,omitempty"`
	NameLte                  *string                `json:"name_lte,omitempty"`
	NameGt                   *string                `json:"name_gt,omitempty"`
	NameGte                  *string                `json:"name_gte,omitempty"`
	NameContains             *string                `json:"name_contains,omitempty"`
	NameNotContains          *string                `json:"name_not_contains,omitempty"`
	NameStartsWith           *string                `json:"name_starts_with,omitempty"`
	NameNotStartsWith        *string                `json:"name_not_starts_with,omitempty"`
	NameEndsWith             *string                `json:"name_ends_with,omitempty"`
	NameNotEndsWith          *string                `json:"name_not_ends_with,omitempty"`
	Description              *string                `json:"description,omitempty"`
	DescriptionNot           *string                `json:"description_not,omitempty"`
	DescriptionIn            []string               `json:"description_in,omitempty"`
	DescriptionNotIn         []string               `json:"description_not_in,omitempty"`
	DescriptionLt            *string                `json:"description_lt,omitempty"`
	DescriptionLte           *string                `json:"description_lte,omitempty"`
	DescriptionGt            *string                `json:"description_gt,omitempty"`
	DescriptionGte           *string                `json:"description_gte,omitempty"`
	DescriptionContains      *string                `json:"description_contains,omitempty"`
	DescriptionNotContains   *string                `json:"description_not_contains,omitempty"`
	DescriptionStartsWith    *string                `json:"description_starts_with,omitempty"`
	DescriptionNotStartsWith *string                `json:"description_not_starts_with,omitempty"`
	DescriptionEndsWith      *string                `json:"description_ends_with,omitempty"`
	DescriptionNotEndsWith   *string                `json:"description_not_ends_with,omitempty"`
	Address                  *string                `json:"address,omitempty"`
	AddressNot               *string                `json:"address_not,omitempty"`
	AddressIn                []string               `json:"address_in,omitempty"`
	AddressNotIn             []string               `json:"address_not_in,omitempty"`
	AddressLt                *string                `json:"address_lt,omitempty"`
	AddressLte               *string                `json:"address_lte,omitempty"`
	AddressGt                *string                `json:"address_gt,omitempty"`
	AddressGte               *string                `json:"address_gte,omitempty"`
	AddressContains          *string                `json:"address_contains,omitempty"`
	AddressNotContains       *string                `json:"address_not_contains,omitempty"`
	AddressStartsWith        *string                `json:"address_starts_with,omitempty"`
	AddressNotStartsWith     *string                `json:"address_not_starts_with,omitempty"`
	AddressEndsWith          *string                `json:"address_ends_with,omitempty"`
	AddressNotEndsWith       *string                `json:"address_not_ends_with,omitempty"`
	Location                 *LocationWhereInput    `json:"location,omitempty"`
	Popularity               *int32                 `json:"popularity,omitempty"`
	PopularityNot            *int32                 `json:"popularity_not,omitempty"`
	PopularityIn             []int32                `json:"popularity_in,omitempty"`
	PopularityNotIn          []int32                `json:"popularity_not_in,omitempty"`
	PopularityLt             *int32                 `json:"popularity_lt,omitempty"`
	PopularityLte            *int32                 `json:"popularity_lte,omitempty"`
	PopularityGt             *int32                 `json:"popularity_gt,omitempty"`
	PopularityGte            *int32                 `json:"popularity_gte,omitempty"`
	LikedByEvery             *PersonWhereInput      `json:"likedBy_every,omitempty"`
	LikedBySome              *PersonWhereInput      `json:"likedBy_some,omitempty"`
	LikedByNone              *PersonWhereInput      `json:"likedBy_none,omitempty"`
	And                      []AttractionWhereInput `json:"AND,omitempty"`
	Or                       []AttractionWhereInput `json:"OR,omitempty"`
	Not                      []AttractionWhereInput `json:"NOT,omitempty"`
}

type LocationCreateOneInput struct {
	Create *LocationCreateInput `json:"create,omitempty"`
}

type LocationWhereInput struct {
	Longitude      *float64             `json:"longitude,omitempty"`
	LongitudeNot   *float64             `json:"longitude_not,omitempty"`
	LongitudeIn    []float64            `json:"longitude_in,omitempty"`
	LongitudeNotIn []float64            `json:"longitude_not_in,omitempty"`
	LongitudeLt    *float64             `json:"longitude_lt,omitempty"`
	LongitudeLte   *float64             `json:"longitude_lte,omitempty"`
	LongitudeGt    *float64             `json:"longitude_gt,omitempty"`
	LongitudeGte   *float64             `json:"longitude_gte,omitempty"`
	Latitude       *float64             `json:"latitude,omitempty"`
	LatitudeNot    *float64             `json:"latitude_not,omitempty"`
	LatitudeIn     []float64            `json:"latitude_in,omitempty"`
	LatitudeNotIn  []float64            `json:"latitude_not_in,omitempty"`
	LatitudeLt     *float64             `json:"latitude_lt,omitempty"`
	LatitudeLte    *float64             `json:"latitude_lte,omitempty"`
	LatitudeGt     *float64             `json:"latitude_gt,omitempty"`
	LatitudeGte    *float64             `json:"latitude_gte,omitempty"`
	And            []LocationWhereInput `json:"AND,omitempty"`
	Or             []LocationWhereInput `json:"OR,omitempty"`
	Not            []LocationWhereInput `json:"NOT,omitempty"`
}

type LocationCreateInput struct {
	Longitude float64 `json:"longitude"`
	Latitude  float64 `json:"latitude"`
}

type PaymentEntrySubscriptionWhereInput struct {
	MutationIn                 []MutationType                       `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                              `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                             `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                             `json:"updatedFields_contains_some,omitempty"`
	Node                       *PaymentEntryWhereInput              `json:"node,omitempty"`
	And                        []PaymentEntrySubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []PaymentEntrySubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []PaymentEntrySubscriptionWhereInput `json:"NOT,omitempty"`
}

type PersonCreateManyInput struct {
	Create  []PersonCreateInput      `json:"create,omitempty"`
	Connect []PersonWhereUniqueInput `json:"connect,omitempty"`
}

type LocationSubscriptionWhereInput struct {
	MutationIn                 []MutationType                   `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                          `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                         `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                         `json:"updatedFields_contains_some,omitempty"`
	Node                       *LocationWhereInput              `json:"node,omitempty"`
	And                        []LocationSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []LocationSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []LocationSubscriptionWhereInput `json:"NOT,omitempty"`
}

type AttractionCreatetypesInput struct {
	Set []AttractionType `json:"set,omitempty"`
}

type CredentialWhereUniqueInput struct {
	ID    *string `json:"id,omitempty"`
	Value *string `json:"value,omitempty"`
}

type AttractionCreatetagsInput struct {
	Set []string `json:"set,omitempty"`
}

type CreditCardSubscriptionWhereInput struct {
	MutationIn                 []MutationType                     `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                            `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                           `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                           `json:"updatedFields_contains_some,omitempty"`
	Node                       *CreditCardWhereInput              `json:"node,omitempty"`
	And                        []CreditCardSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []CreditCardSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []CreditCardSubscriptionWhereInput `json:"NOT,omitempty"`
}

type AttractionUpdateInput struct {
	Owner       *PartnerUpdateOneRequiredWithoutAttractionInput `json:"owner,omitempty"`
	Name        *string                                         `json:"name,omitempty"`
	Description *string                                         `json:"description,omitempty"`
	Address     *string                                         `json:"address,omitempty"`
	Location    *LocationUpdateOneRequiredInput                 `json:"location,omitempty"`
	Popularity  *int32                                          `json:"popularity,omitempty"`
	LikedBy     *PersonUpdateManyInput                          `json:"likedBy,omitempty"`
	Types       *AttractionUpdatetypesInput                     `json:"types,omitempty"`
	Tags        *AttractionUpdatetagsInput                      `json:"tags,omitempty"`
}

type CreditCardWhereUniqueInput struct {
	ID *string `json:"id,omitempty"`
}

type PartnerUpdateOneRequiredWithoutAttractionInput struct {
	Create  *PartnerCreateWithoutAttractionInput     `json:"create,omitempty"`
	Update  *PartnerUpdateWithoutAttractionDataInput `json:"update,omitempty"`
	Upsert  *PartnerUpsertWithoutAttractionInput     `json:"upsert,omitempty"`
	Connect *PartnerWhereUniqueInput                 `json:"connect,omitempty"`
}

type TravelerUpdateManyMutationInput struct {
	Username *string `json:"username,omitempty"`
}

type PartnerUpdateWithoutAttractionDataInput struct {
	Person *PersonUpdateOneRequiredInput `json:"person,omitempty"`
}

type TravelerWhereInput struct {
	ID                    *string               `json:"id,omitempty"`
	IDNot                 *string               `json:"id_not,omitempty"`
	IDIn                  []string              `json:"id_in,omitempty"`
	IDNotIn               []string              `json:"id_not_in,omitempty"`
	IDLt                  *string               `json:"id_lt,omitempty"`
	IDLte                 *string               `json:"id_lte,omitempty"`
	IDGt                  *string               `json:"id_gt,omitempty"`
	IDGte                 *string               `json:"id_gte,omitempty"`
	IDContains            *string               `json:"id_contains,omitempty"`
	IDNotContains         *string               `json:"id_not_contains,omitempty"`
	IDStartsWith          *string               `json:"id_starts_with,omitempty"`
	IDNotStartsWith       *string               `json:"id_not_starts_with,omitempty"`
	IDEndsWith            *string               `json:"id_ends_with,omitempty"`
	IDNotEndsWith         *string               `json:"id_not_ends_with,omitempty"`
	CreatedAt             *string               `json:"createdAt,omitempty"`
	CreatedAtNot          *string               `json:"createdAt_not,omitempty"`
	CreatedAtIn           []string              `json:"createdAt_in,omitempty"`
	CreatedAtNotIn        []string              `json:"createdAt_not_in,omitempty"`
	CreatedAtLt           *string               `json:"createdAt_lt,omitempty"`
	CreatedAtLte          *string               `json:"createdAt_lte,omitempty"`
	CreatedAtGt           *string               `json:"createdAt_gt,omitempty"`
	CreatedAtGte          *string               `json:"createdAt_gte,omitempty"`
	UpdatedAt             *string               `json:"updatedAt,omitempty"`
	UpdatedAtNot          *string               `json:"updatedAt_not,omitempty"`
	UpdatedAtIn           []string              `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn        []string              `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt           *string               `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte          *string               `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt           *string               `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte          *string               `json:"updatedAt_gte,omitempty"`
	Person                *PersonWhereInput     `json:"person,omitempty"`
	Username              *string               `json:"username,omitempty"`
	UsernameNot           *string               `json:"username_not,omitempty"`
	UsernameIn            []string              `json:"username_in,omitempty"`
	UsernameNotIn         []string              `json:"username_not_in,omitempty"`
	UsernameLt            *string               `json:"username_lt,omitempty"`
	UsernameLte           *string               `json:"username_lte,omitempty"`
	UsernameGt            *string               `json:"username_gt,omitempty"`
	UsernameGte           *string               `json:"username_gte,omitempty"`
	UsernameContains      *string               `json:"username_contains,omitempty"`
	UsernameNotContains   *string               `json:"username_not_contains,omitempty"`
	UsernameStartsWith    *string               `json:"username_starts_with,omitempty"`
	UsernameNotStartsWith *string               `json:"username_not_starts_with,omitempty"`
	UsernameEndsWith      *string               `json:"username_ends_with,omitempty"`
	UsernameNotEndsWith   *string               `json:"username_not_ends_with,omitempty"`
	CardsEvery            *CreditCardWhereInput `json:"cards_every,omitempty"`
	CardsSome             *CreditCardWhereInput `json:"cards_some,omitempty"`
	CardsNone             *CreditCardWhereInput `json:"cards_none,omitempty"`
	And                   []TravelerWhereInput  `json:"AND,omitempty"`
	Or                    []TravelerWhereInput  `json:"OR,omitempty"`
	Not                   []TravelerWhereInput  `json:"NOT,omitempty"`
}

type PersonUpdateOneRequiredInput struct {
	Create  *PersonCreateInput       `json:"create,omitempty"`
	Update  *PersonUpdateDataInput   `json:"update,omitempty"`
	Upsert  *PersonUpsertNestedInput `json:"upsert,omitempty"`
	Connect *PersonWhereUniqueInput  `json:"connect,omitempty"`
}

type PaymentEntryWhereInput struct {
	ID                           *string                  `json:"id,omitempty"`
	IDNot                        *string                  `json:"id_not,omitempty"`
	IDIn                         []string                 `json:"id_in,omitempty"`
	IDNotIn                      []string                 `json:"id_not_in,omitempty"`
	IDLt                         *string                  `json:"id_lt,omitempty"`
	IDLte                        *string                  `json:"id_lte,omitempty"`
	IDGt                         *string                  `json:"id_gt,omitempty"`
	IDGte                        *string                  `json:"id_gte,omitempty"`
	IDContains                   *string                  `json:"id_contains,omitempty"`
	IDNotContains                *string                  `json:"id_not_contains,omitempty"`
	IDStartsWith                 *string                  `json:"id_starts_with,omitempty"`
	IDNotStartsWith              *string                  `json:"id_not_starts_with,omitempty"`
	IDEndsWith                   *string                  `json:"id_ends_with,omitempty"`
	IDNotEndsWith                *string                  `json:"id_not_ends_with,omitempty"`
	CreatedAt                    *string                  `json:"createdAt,omitempty"`
	CreatedAtNot                 *string                  `json:"createdAt_not,omitempty"`
	CreatedAtIn                  []string                 `json:"createdAt_in,omitempty"`
	CreatedAtNotIn               []string                 `json:"createdAt_not_in,omitempty"`
	CreatedAtLt                  *string                  `json:"createdAt_lt,omitempty"`
	CreatedAtLte                 *string                  `json:"createdAt_lte,omitempty"`
	CreatedAtGt                  *string                  `json:"createdAt_gt,omitempty"`
	CreatedAtGte                 *string                  `json:"createdAt_gte,omitempty"`
	UpdatedAt                    *string                  `json:"updatedAt,omitempty"`
	UpdatedAtNot                 *string                  `json:"updatedAt_not,omitempty"`
	UpdatedAtIn                  []string                 `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn               []string                 `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt                  *string                  `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte                 *string                  `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt                  *string                  `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte                 *string                  `json:"updatedAt_gte,omitempty"`
	ExternalId                   *string                  `json:"externalID,omitempty"`
	ExternalIdNot                *string                  `json:"externalID_not,omitempty"`
	ExternalIdIn                 []string                 `json:"externalID_in,omitempty"`
	ExternalIdNotIn              []string                 `json:"externalID_not_in,omitempty"`
	ExternalIdLt                 *string                  `json:"externalID_lt,omitempty"`
	ExternalIdLte                *string                  `json:"externalID_lte,omitempty"`
	ExternalIdGt                 *string                  `json:"externalID_gt,omitempty"`
	ExternalIdGte                *string                  `json:"externalID_gte,omitempty"`
	ExternalIdContains           *string                  `json:"externalID_contains,omitempty"`
	ExternalIdNotContains        *string                  `json:"externalID_not_contains,omitempty"`
	ExternalIdStartsWith         *string                  `json:"externalID_starts_with,omitempty"`
	ExternalIdNotStartsWith      *string                  `json:"externalID_not_starts_with,omitempty"`
	ExternalIdEndsWith           *string                  `json:"externalID_ends_with,omitempty"`
	ExternalIdNotEndsWith        *string                  `json:"externalID_not_ends_with,omitempty"`
	WithCard                     *CreditCardWhereInput    `json:"withCard,omitempty"`
	ProductId                    *string                  `json:"productID,omitempty"`
	ProductIdNot                 *string                  `json:"productID_not,omitempty"`
	ProductIdIn                  []string                 `json:"productID_in,omitempty"`
	ProductIdNotIn               []string                 `json:"productID_not_in,omitempty"`
	ProductIdLt                  *string                  `json:"productID_lt,omitempty"`
	ProductIdLte                 *string                  `json:"productID_lte,omitempty"`
	ProductIdGt                  *string                  `json:"productID_gt,omitempty"`
	ProductIdGte                 *string                  `json:"productID_gte,omitempty"`
	ProductIdContains            *string                  `json:"productID_contains,omitempty"`
	ProductIdNotContains         *string                  `json:"productID_not_contains,omitempty"`
	ProductIdStartsWith          *string                  `json:"productID_starts_with,omitempty"`
	ProductIdNotStartsWith       *string                  `json:"productID_not_starts_with,omitempty"`
	ProductIdEndsWith            *string                  `json:"productID_ends_with,omitempty"`
	ProductIdNotEndsWith         *string                  `json:"productID_not_ends_with,omitempty"`
	Product                      *string                  `json:"product,omitempty"`
	ProductNot                   *string                  `json:"product_not,omitempty"`
	ProductIn                    []string                 `json:"product_in,omitempty"`
	ProductNotIn                 []string                 `json:"product_not_in,omitempty"`
	ProductLt                    *string                  `json:"product_lt,omitempty"`
	ProductLte                   *string                  `json:"product_lte,omitempty"`
	ProductGt                    *string                  `json:"product_gt,omitempty"`
	ProductGte                   *string                  `json:"product_gte,omitempty"`
	ProductContains              *string                  `json:"product_contains,omitempty"`
	ProductNotContains           *string                  `json:"product_not_contains,omitempty"`
	ProductStartsWith            *string                  `json:"product_starts_with,omitempty"`
	ProductNotStartsWith         *string                  `json:"product_not_starts_with,omitempty"`
	ProductEndsWith              *string                  `json:"product_ends_with,omitempty"`
	ProductNotEndsWith           *string                  `json:"product_not_ends_with,omitempty"`
	GatewayResponse              *string                  `json:"gatewayResponse,omitempty"`
	GatewayResponseNot           *string                  `json:"gatewayResponse_not,omitempty"`
	GatewayResponseIn            []string                 `json:"gatewayResponse_in,omitempty"`
	GatewayResponseNotIn         []string                 `json:"gatewayResponse_not_in,omitempty"`
	GatewayResponseLt            *string                  `json:"gatewayResponse_lt,omitempty"`
	GatewayResponseLte           *string                  `json:"gatewayResponse_lte,omitempty"`
	GatewayResponseGt            *string                  `json:"gatewayResponse_gt,omitempty"`
	GatewayResponseGte           *string                  `json:"gatewayResponse_gte,omitempty"`
	GatewayResponseContains      *string                  `json:"gatewayResponse_contains,omitempty"`
	GatewayResponseNotContains   *string                  `json:"gatewayResponse_not_contains,omitempty"`
	GatewayResponseStartsWith    *string                  `json:"gatewayResponse_starts_with,omitempty"`
	GatewayResponseNotStartsWith *string                  `json:"gatewayResponse_not_starts_with,omitempty"`
	GatewayResponseEndsWith      *string                  `json:"gatewayResponse_ends_with,omitempty"`
	GatewayResponseNotEndsWith   *string                  `json:"gatewayResponse_not_ends_with,omitempty"`
	Amount                       *int32                   `json:"amount,omitempty"`
	AmountNot                    *int32                   `json:"amount_not,omitempty"`
	AmountIn                     []int32                  `json:"amount_in,omitempty"`
	AmountNotIn                  []int32                  `json:"amount_not_in,omitempty"`
	AmountLt                     *int32                   `json:"amount_lt,omitempty"`
	AmountLte                    *int32                   `json:"amount_lte,omitempty"`
	AmountGt                     *int32                   `json:"amount_gt,omitempty"`
	AmountGte                    *int32                   `json:"amount_gte,omitempty"`
	DiscountId                   *string                  `json:"discountID,omitempty"`
	DiscountIdNot                *string                  `json:"discountID_not,omitempty"`
	DiscountIdIn                 []string                 `json:"discountID_in,omitempty"`
	DiscountIdNotIn              []string                 `json:"discountID_not_in,omitempty"`
	DiscountIdLt                 *string                  `json:"discountID_lt,omitempty"`
	DiscountIdLte                *string                  `json:"discountID_lte,omitempty"`
	DiscountIdGt                 *string                  `json:"discountID_gt,omitempty"`
	DiscountIdGte                *string                  `json:"discountID_gte,omitempty"`
	DiscountIdContains           *string                  `json:"discountID_contains,omitempty"`
	DiscountIdNotContains        *string                  `json:"discountID_not_contains,omitempty"`
	DiscountIdStartsWith         *string                  `json:"discountID_starts_with,omitempty"`
	DiscountIdNotStartsWith      *string                  `json:"discountID_not_starts_with,omitempty"`
	DiscountIdEndsWith           *string                  `json:"discountID_ends_with,omitempty"`
	DiscountIdNotEndsWith        *string                  `json:"discountID_not_ends_with,omitempty"`
	Discount                     *int32                   `json:"discount,omitempty"`
	DiscountNot                  *int32                   `json:"discount_not,omitempty"`
	DiscountIn                   []int32                  `json:"discount_in,omitempty"`
	DiscountNotIn                []int32                  `json:"discount_not_in,omitempty"`
	DiscountLt                   *int32                   `json:"discount_lt,omitempty"`
	DiscountLte                  *int32                   `json:"discount_lte,omitempty"`
	DiscountGt                   *int32                   `json:"discount_gt,omitempty"`
	DiscountGte                  *int32                   `json:"discount_gte,omitempty"`
	And                          []PaymentEntryWhereInput `json:"AND,omitempty"`
	Or                           []PaymentEntryWhereInput `json:"OR,omitempty"`
	Not                          []PaymentEntryWhereInput `json:"NOT,omitempty"`
}

type PersonUpdateDataInput struct {
	MId            *string                                                    `json:"mID,omitempty"`
	Name           *string                                                    `json:"name,omitempty"`
	Photo          *string                                                    `json:"photo,omitempty"`
	Birthday       *string                                                    `json:"birthday,omitempty"`
	From           *string                                                    `json:"from,omitempty"`
	ChannelsPhone  *PhoneUpdateManyInput                                      `json:"channelsPhone,omitempty"`
	ChannelsEmail  *EmailUpdateManyInput                                      `json:"channelsEmail,omitempty"`
	IDentification *IDentificationDocumentUpdateOneRequiredWithoutPersonInput `json:"identification,omitempty"`
	Tags           *PersonUpdatetagsInput                                     `json:"tags,omitempty"`
	Credentials    *CredentialUpdateManyWithoutOwnerInput                     `json:"credentials,omitempty"`
}

type PhoneWhereInput struct {
	Type                     *CommunicationType  `json:"type,omitempty"`
	TypeNot                  *CommunicationType  `json:"type_not,omitempty"`
	TypeIn                   []CommunicationType `json:"type_in,omitempty"`
	TypeNotIn                []CommunicationType `json:"type_not_in,omitempty"`
	CountryCode              *string             `json:"countryCode,omitempty"`
	CountryCodeNot           *string             `json:"countryCode_not,omitempty"`
	CountryCodeIn            []string            `json:"countryCode_in,omitempty"`
	CountryCodeNotIn         []string            `json:"countryCode_not_in,omitempty"`
	CountryCodeLt            *string             `json:"countryCode_lt,omitempty"`
	CountryCodeLte           *string             `json:"countryCode_lte,omitempty"`
	CountryCodeGt            *string             `json:"countryCode_gt,omitempty"`
	CountryCodeGte           *string             `json:"countryCode_gte,omitempty"`
	CountryCodeContains      *string             `json:"countryCode_contains,omitempty"`
	CountryCodeNotContains   *string             `json:"countryCode_not_contains,omitempty"`
	CountryCodeStartsWith    *string             `json:"countryCode_starts_with,omitempty"`
	CountryCodeNotStartsWith *string             `json:"countryCode_not_starts_with,omitempty"`
	CountryCodeEndsWith      *string             `json:"countryCode_ends_with,omitempty"`
	CountryCodeNotEndsWith   *string             `json:"countryCode_not_ends_with,omitempty"`
	Number                   *string             `json:"number,omitempty"`
	NumberNot                *string             `json:"number_not,omitempty"`
	NumberIn                 []string            `json:"number_in,omitempty"`
	NumberNotIn              []string            `json:"number_not_in,omitempty"`
	NumberLt                 *string             `json:"number_lt,omitempty"`
	NumberLte                *string             `json:"number_lte,omitempty"`
	NumberGt                 *string             `json:"number_gt,omitempty"`
	NumberGte                *string             `json:"number_gte,omitempty"`
	NumberContains           *string             `json:"number_contains,omitempty"`
	NumberNotContains        *string             `json:"number_not_contains,omitempty"`
	NumberStartsWith         *string             `json:"number_starts_with,omitempty"`
	NumberNotStartsWith      *string             `json:"number_not_starts_with,omitempty"`
	NumberEndsWith           *string             `json:"number_ends_with,omitempty"`
	NumberNotEndsWith        *string             `json:"number_not_ends_with,omitempty"`
	And                      []PhoneWhereInput   `json:"AND,omitempty"`
	Or                       []PhoneWhereInput   `json:"OR,omitempty"`
	Not                      []PhoneWhereInput   `json:"NOT,omitempty"`
}

type PhoneUpdateManyInput struct {
	Create     []PhoneCreateInput                    `json:"create,omitempty"`
	DeleteMany []PhoneScalarWhereInput               `json:"deleteMany,omitempty"`
	UpdateMany []PhoneUpdateManyWithWhereNestedInput `json:"updateMany,omitempty"`
}

type CreditCardUpsertWithWhereUniqueWithoutOwnerInput struct {
	Where  CreditCardWhereUniqueInput            `json:"where"`
	Update CreditCardUpdateWithoutOwnerDataInput `json:"update"`
	Create CreditCardCreateWithoutOwnerInput     `json:"create"`
}

type PhoneScalarWhereInput struct {
	Type                     *CommunicationType      `json:"type,omitempty"`
	TypeNot                  *CommunicationType      `json:"type_not,omitempty"`
	TypeIn                   []CommunicationType     `json:"type_in,omitempty"`
	TypeNotIn                []CommunicationType     `json:"type_not_in,omitempty"`
	CountryCode              *string                 `json:"countryCode,omitempty"`
	CountryCodeNot           *string                 `json:"countryCode_not,omitempty"`
	CountryCodeIn            []string                `json:"countryCode_in,omitempty"`
	CountryCodeNotIn         []string                `json:"countryCode_not_in,omitempty"`
	CountryCodeLt            *string                 `json:"countryCode_lt,omitempty"`
	CountryCodeLte           *string                 `json:"countryCode_lte,omitempty"`
	CountryCodeGt            *string                 `json:"countryCode_gt,omitempty"`
	CountryCodeGte           *string                 `json:"countryCode_gte,omitempty"`
	CountryCodeContains      *string                 `json:"countryCode_contains,omitempty"`
	CountryCodeNotContains   *string                 `json:"countryCode_not_contains,omitempty"`
	CountryCodeStartsWith    *string                 `json:"countryCode_starts_with,omitempty"`
	CountryCodeNotStartsWith *string                 `json:"countryCode_not_starts_with,omitempty"`
	CountryCodeEndsWith      *string                 `json:"countryCode_ends_with,omitempty"`
	CountryCodeNotEndsWith   *string                 `json:"countryCode_not_ends_with,omitempty"`
	Number                   *string                 `json:"number,omitempty"`
	NumberNot                *string                 `json:"number_not,omitempty"`
	NumberIn                 []string                `json:"number_in,omitempty"`
	NumberNotIn              []string                `json:"number_not_in,omitempty"`
	NumberLt                 *string                 `json:"number_lt,omitempty"`
	NumberLte                *string                 `json:"number_lte,omitempty"`
	NumberGt                 *string                 `json:"number_gt,omitempty"`
	NumberGte                *string                 `json:"number_gte,omitempty"`
	NumberContains           *string                 `json:"number_contains,omitempty"`
	NumberNotContains        *string                 `json:"number_not_contains,omitempty"`
	NumberStartsWith         *string                 `json:"number_starts_with,omitempty"`
	NumberNotStartsWith      *string                 `json:"number_not_starts_with,omitempty"`
	NumberEndsWith           *string                 `json:"number_ends_with,omitempty"`
	NumberNotEndsWith        *string                 `json:"number_not_ends_with,omitempty"`
	And                      []PhoneScalarWhereInput `json:"AND,omitempty"`
	Or                       []PhoneScalarWhereInput `json:"OR,omitempty"`
	Not                      []PhoneScalarWhereInput `json:"NOT,omitempty"`
}

type CreditCardUpdateWithWhereUniqueWithoutOwnerInput struct {
	Where CreditCardWhereUniqueInput            `json:"where"`
	Data  CreditCardUpdateWithoutOwnerDataInput `json:"data"`
}

type PhoneUpdateManyWithWhereNestedInput struct {
	Where PhoneScalarWhereInput    `json:"where"`
	Data  PhoneUpdateManyDataInput `json:"data"`
}

type TravelerUpdateInput struct {
	Person   *PersonUpdateOneRequiredInput          `json:"person,omitempty"`
	Username *string                                `json:"username,omitempty"`
	Cards    *CreditCardUpdateManyWithoutOwnerInput `json:"cards,omitempty"`
}

type PhoneUpdateManyDataInput struct {
	Type        *CommunicationType `json:"type,omitempty"`
	CountryCode *string            `json:"countryCode,omitempty"`
	Number      *string            `json:"number,omitempty"`
}

type IDentificationDocumentWhereUniqueInput struct {
	ID *string `json:"id,omitempty"`
}

type EmailUpdateManyInput struct {
	Create     []EmailCreateInput                    `json:"create,omitempty"`
	DeleteMany []EmailScalarWhereInput               `json:"deleteMany,omitempty"`
	UpdateMany []EmailUpdateManyWithWhereNestedInput `json:"updateMany,omitempty"`
}

type TravelerCreateInput struct {
	Person   PersonCreateOneInput                   `json:"person"`
	Username string                                 `json:"username"`
	Cards    *CreditCardCreateManyWithoutOwnerInput `json:"cards,omitempty"`
}

type EmailScalarWhereInput struct {
	Type               *CommunicationType      `json:"type,omitempty"`
	TypeNot            *CommunicationType      `json:"type_not,omitempty"`
	TypeIn             []CommunicationType     `json:"type_in,omitempty"`
	TypeNotIn          []CommunicationType     `json:"type_not_in,omitempty"`
	Value              *string                 `json:"value,omitempty"`
	ValueNot           *string                 `json:"value_not,omitempty"`
	ValueIn            []string                `json:"value_in,omitempty"`
	ValueNotIn         []string                `json:"value_not_in,omitempty"`
	ValueLt            *string                 `json:"value_lt,omitempty"`
	ValueLte           *string                 `json:"value_lte,omitempty"`
	ValueGt            *string                 `json:"value_gt,omitempty"`
	ValueGte           *string                 `json:"value_gte,omitempty"`
	ValueContains      *string                 `json:"value_contains,omitempty"`
	ValueNotContains   *string                 `json:"value_not_contains,omitempty"`
	ValueStartsWith    *string                 `json:"value_starts_with,omitempty"`
	ValueNotStartsWith *string                 `json:"value_not_starts_with,omitempty"`
	ValueEndsWith      *string                 `json:"value_ends_with,omitempty"`
	ValueNotEndsWith   *string                 `json:"value_not_ends_with,omitempty"`
	And                []EmailScalarWhereInput `json:"AND,omitempty"`
	Or                 []EmailScalarWhereInput `json:"OR,omitempty"`
	Not                []EmailScalarWhereInput `json:"NOT,omitempty"`
}

type PersonUpdateManyMutationInput struct {
	MId      *string                `json:"mID,omitempty"`
	Name     *string                `json:"name,omitempty"`
	Photo    *string                `json:"photo,omitempty"`
	Birthday *string                `json:"birthday,omitempty"`
	From     *string                `json:"from,omitempty"`
	Tags     *PersonUpdatetagsInput `json:"tags,omitempty"`
}

type EmailUpdateManyWithWhereNestedInput struct {
	Where EmailScalarWhereInput    `json:"where"`
	Data  EmailUpdateManyDataInput `json:"data"`
}

type PaymentEntryUpdateManyMutationInput struct {
	ExternalId      *string `json:"externalID,omitempty"`
	ProductId       *string `json:"productID,omitempty"`
	Product         *string `json:"product,omitempty"`
	GatewayResponse *string `json:"gatewayResponse,omitempty"`
	Amount          *int32  `json:"amount,omitempty"`
	DiscountId      *string `json:"discountID,omitempty"`
	Discount        *int32  `json:"discount,omitempty"`
}

type EmailUpdateManyDataInput struct {
	Type   *CommunicationType      `json:"type,omitempty"`
	Value  *string                 `json:"value,omitempty"`
	Extras *EmailUpdateextrasInput `json:"extras,omitempty"`
}

type CreditCardUpdateWithoutUsesDataInput struct {
	Owner      *TravelerUpdateOneRequiredWithoutCardsInput `json:"owner,omitempty"`
	CardNumber *string                                     `json:"cardNumber,omitempty"`
	CardToken  *string                                     `json:"cardToken,omitempty"`
	Type       *CreditCardType                             `json:"type,omitempty"`
	LastUsed   *string                                     `json:"lastUsed,omitempty"`
}

type EmailUpdateextrasInput struct {
	Set []string `json:"set,omitempty"`
}

type CreditCardUpdateOneRequiredWithoutUsesInput struct {
	Create  *CreditCardCreateWithoutUsesInput     `json:"create,omitempty"`
	Update  *CreditCardUpdateWithoutUsesDataInput `json:"update,omitempty"`
	Upsert  *CreditCardUpsertWithoutUsesInput     `json:"upsert,omitempty"`
	Connect *CreditCardWhereUniqueInput           `json:"connect,omitempty"`
}

type IDentificationDocumentUpdateOneRequiredWithoutPersonInput struct {
	Create  *IDentificationDocumentCreateWithoutPersonInput     `json:"create,omitempty"`
	Update  *IDentificationDocumentUpdateWithoutPersonDataInput `json:"update,omitempty"`
	Upsert  *IDentificationDocumentUpsertWithoutPersonInput     `json:"upsert,omitempty"`
	Connect *IDentificationDocumentWhereUniqueInput             `json:"connect,omitempty"`
}

type CreditCardCreateWithoutUsesInput struct {
	Owner      TravelerCreateOneWithoutCardsInput `json:"owner"`
	CardNumber string                             `json:"cardNumber"`
	CardToken  string                             `json:"cardToken"`
	Type       *CreditCardType                    `json:"type,omitempty"`
	LastUsed   *string                            `json:"lastUsed,omitempty"`
}

type IDentificationDocumentUpdateWithoutPersonDataInput struct {
	Type  *IDentificationType `json:"type,omitempty"`
	Value *string             `json:"value,omitempty"`
}

type PaymentEntryWhereUniqueInput struct {
	ID *string `json:"id,omitempty"`
}

type IDentificationDocumentUpdateInput struct {
	Person *PersonUpdateOneRequiredWithoutIdentificationInput `json:"person,omitempty"`
	Type   *IDentificationType                                `json:"type,omitempty"`
	Value  *string                                            `json:"value,omitempty"`
}

type AttractionUpsertWithoutOwnerInput struct {
	Update AttractionUpdateWithoutOwnerDataInput `json:"update"`
	Create AttractionCreateWithoutOwnerInput     `json:"create"`
}

type PersonUpdatetagsInput struct {
	Set []string `json:"set,omitempty"`
}

type PersonWhereUniqueInput struct {
	ID *string `json:"id,omitempty"`
}

type CredentialUpdateManyWithoutOwnerInput struct {
	Create     []CredentialCreateWithoutOwnerInput                `json:"create,omitempty"`
	Delete     []CredentialWhereUniqueInput                       `json:"delete,omitempty"`
	Connect    []CredentialWhereUniqueInput                       `json:"connect,omitempty"`
	Set        []CredentialWhereUniqueInput                       `json:"set,omitempty"`
	Disconnect []CredentialWhereUniqueInput                       `json:"disconnect,omitempty"`
	Update     []CredentialUpdateWithWhereUniqueWithoutOwnerInput `json:"update,omitempty"`
	Upsert     []CredentialUpsertWithWhereUniqueWithoutOwnerInput `json:"upsert,omitempty"`
	DeleteMany []CredentialScalarWhereInput                       `json:"deleteMany,omitempty"`
	UpdateMany []CredentialUpdateManyWithWhereNestedInput         `json:"updateMany,omitempty"`
}

type PartnerUpdateInput struct {
	Person     *PersonUpdateOneRequiredInput                 `json:"person,omitempty"`
	Attraction *AttractionUpdateOneRequiredWithoutOwnerInput `json:"attraction,omitempty"`
}

type CredentialUpdateWithWhereUniqueWithoutOwnerInput struct {
	Where CredentialWhereUniqueInput            `json:"where"`
	Data  CredentialUpdateWithoutOwnerDataInput `json:"data"`
}

type AttractionCreateOneWithoutOwnerInput struct {
	Create  *AttractionCreateWithoutOwnerInput `json:"create,omitempty"`
	Connect *AttractionWhereUniqueInput        `json:"connect,omitempty"`
}

type CredentialUpdateWithoutOwnerDataInput struct {
	DisplayName    *string         `json:"displayName,omitempty"`
	IsMain         *bool           `json:"isMain,omitempty"`
	Type           *CredentialType `json:"type,omitempty"`
	Validated      *bool           `json:"validated,omitempty"`
	ValidationId   *string         `json:"validationID,omitempty"`
	Value          *string         `json:"value,omitempty"`
	RawPassword    *string         `json:"rawPassword,omitempty"`
	HashedPassword *string         `json:"hashedPassword,omitempty"`
}

type LocationUpdateManyMutationInput struct {
	Longitude *float64 `json:"longitude,omitempty"`
	Latitude  *float64 `json:"latitude,omitempty"`
}

type CredentialUpsertWithWhereUniqueWithoutOwnerInput struct {
	Where  CredentialWhereUniqueInput            `json:"where"`
	Update CredentialUpdateWithoutOwnerDataInput `json:"update"`
	Create CredentialCreateWithoutOwnerInput     `json:"create"`
}

type IDentificationDocumentUpdateManyMutationInput struct {
	Type  *IDentificationType `json:"type,omitempty"`
	Value *string             `json:"value,omitempty"`
}

type CredentialScalarWhereInput struct {
	ID                          *string                      `json:"id,omitempty"`
	IDNot                       *string                      `json:"id_not,omitempty"`
	IDIn                        []string                     `json:"id_in,omitempty"`
	IDNotIn                     []string                     `json:"id_not_in,omitempty"`
	IDLt                        *string                      `json:"id_lt,omitempty"`
	IDLte                       *string                      `json:"id_lte,omitempty"`
	IDGt                        *string                      `json:"id_gt,omitempty"`
	IDGte                       *string                      `json:"id_gte,omitempty"`
	IDContains                  *string                      `json:"id_contains,omitempty"`
	IDNotContains               *string                      `json:"id_not_contains,omitempty"`
	IDStartsWith                *string                      `json:"id_starts_with,omitempty"`
	IDNotStartsWith             *string                      `json:"id_not_starts_with,omitempty"`
	IDEndsWith                  *string                      `json:"id_ends_with,omitempty"`
	IDNotEndsWith               *string                      `json:"id_not_ends_with,omitempty"`
	CreatedAt                   *string                      `json:"createdAt,omitempty"`
	CreatedAtNot                *string                      `json:"createdAt_not,omitempty"`
	CreatedAtIn                 []string                     `json:"createdAt_in,omitempty"`
	CreatedAtNotIn              []string                     `json:"createdAt_not_in,omitempty"`
	CreatedAtLt                 *string                      `json:"createdAt_lt,omitempty"`
	CreatedAtLte                *string                      `json:"createdAt_lte,omitempty"`
	CreatedAtGt                 *string                      `json:"createdAt_gt,omitempty"`
	CreatedAtGte                *string                      `json:"createdAt_gte,omitempty"`
	UpdatedAt                   *string                      `json:"updatedAt,omitempty"`
	UpdatedAtNot                *string                      `json:"updatedAt_not,omitempty"`
	UpdatedAtIn                 []string                     `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn              []string                     `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt                 *string                      `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte                *string                      `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt                 *string                      `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte                *string                      `json:"updatedAt_gte,omitempty"`
	DisplayName                 *string                      `json:"displayName,omitempty"`
	DisplayNameNot              *string                      `json:"displayName_not,omitempty"`
	DisplayNameIn               []string                     `json:"displayName_in,omitempty"`
	DisplayNameNotIn            []string                     `json:"displayName_not_in,omitempty"`
	DisplayNameLt               *string                      `json:"displayName_lt,omitempty"`
	DisplayNameLte              *string                      `json:"displayName_lte,omitempty"`
	DisplayNameGt               *string                      `json:"displayName_gt,omitempty"`
	DisplayNameGte              *string                      `json:"displayName_gte,omitempty"`
	DisplayNameContains         *string                      `json:"displayName_contains,omitempty"`
	DisplayNameNotContains      *string                      `json:"displayName_not_contains,omitempty"`
	DisplayNameStartsWith       *string                      `json:"displayName_starts_with,omitempty"`
	DisplayNameNotStartsWith    *string                      `json:"displayName_not_starts_with,omitempty"`
	DisplayNameEndsWith         *string                      `json:"displayName_ends_with,omitempty"`
	DisplayNameNotEndsWith      *string                      `json:"displayName_not_ends_with,omitempty"`
	IsMain                      *bool                        `json:"isMain,omitempty"`
	IsMainNot                   *bool                        `json:"isMain_not,omitempty"`
	Type                        *CredentialType              `json:"type,omitempty"`
	TypeNot                     *CredentialType              `json:"type_not,omitempty"`
	TypeIn                      []CredentialType             `json:"type_in,omitempty"`
	TypeNotIn                   []CredentialType             `json:"type_not_in,omitempty"`
	Validated                   *bool                        `json:"validated,omitempty"`
	ValidatedNot                *bool                        `json:"validated_not,omitempty"`
	ValidationId                *string                      `json:"validationID,omitempty"`
	ValidationIdNot             *string                      `json:"validationID_not,omitempty"`
	ValidationIdIn              []string                     `json:"validationID_in,omitempty"`
	ValidationIdNotIn           []string                     `json:"validationID_not_in,omitempty"`
	ValidationIdLt              *string                      `json:"validationID_lt,omitempty"`
	ValidationIdLte             *string                      `json:"validationID_lte,omitempty"`
	ValidationIdGt              *string                      `json:"validationID_gt,omitempty"`
	ValidationIdGte             *string                      `json:"validationID_gte,omitempty"`
	ValidationIdContains        *string                      `json:"validationID_contains,omitempty"`
	ValidationIdNotContains     *string                      `json:"validationID_not_contains,omitempty"`
	ValidationIdStartsWith      *string                      `json:"validationID_starts_with,omitempty"`
	ValidationIdNotStartsWith   *string                      `json:"validationID_not_starts_with,omitempty"`
	ValidationIdEndsWith        *string                      `json:"validationID_ends_with,omitempty"`
	ValidationIdNotEndsWith     *string                      `json:"validationID_not_ends_with,omitempty"`
	Value                       *string                      `json:"value,omitempty"`
	ValueNot                    *string                      `json:"value_not,omitempty"`
	ValueIn                     []string                     `json:"value_in,omitempty"`
	ValueNotIn                  []string                     `json:"value_not_in,omitempty"`
	ValueLt                     *string                      `json:"value_lt,omitempty"`
	ValueLte                    *string                      `json:"value_lte,omitempty"`
	ValueGt                     *string                      `json:"value_gt,omitempty"`
	ValueGte                    *string                      `json:"value_gte,omitempty"`
	ValueContains               *string                      `json:"value_contains,omitempty"`
	ValueNotContains            *string                      `json:"value_not_contains,omitempty"`
	ValueStartsWith             *string                      `json:"value_starts_with,omitempty"`
	ValueNotStartsWith          *string                      `json:"value_not_starts_with,omitempty"`
	ValueEndsWith               *string                      `json:"value_ends_with,omitempty"`
	ValueNotEndsWith            *string                      `json:"value_not_ends_with,omitempty"`
	RawPassword                 *string                      `json:"rawPassword,omitempty"`
	RawPasswordNot              *string                      `json:"rawPassword_not,omitempty"`
	RawPasswordIn               []string                     `json:"rawPassword_in,omitempty"`
	RawPasswordNotIn            []string                     `json:"rawPassword_not_in,omitempty"`
	RawPasswordLt               *string                      `json:"rawPassword_lt,omitempty"`
	RawPasswordLte              *string                      `json:"rawPassword_lte,omitempty"`
	RawPasswordGt               *string                      `json:"rawPassword_gt,omitempty"`
	RawPasswordGte              *string                      `json:"rawPassword_gte,omitempty"`
	RawPasswordContains         *string                      `json:"rawPassword_contains,omitempty"`
	RawPasswordNotContains      *string                      `json:"rawPassword_not_contains,omitempty"`
	RawPasswordStartsWith       *string                      `json:"rawPassword_starts_with,omitempty"`
	RawPasswordNotStartsWith    *string                      `json:"rawPassword_not_starts_with,omitempty"`
	RawPasswordEndsWith         *string                      `json:"rawPassword_ends_with,omitempty"`
	RawPasswordNotEndsWith      *string                      `json:"rawPassword_not_ends_with,omitempty"`
	HashedPassword              *string                      `json:"hashedPassword,omitempty"`
	HashedPasswordNot           *string                      `json:"hashedPassword_not,omitempty"`
	HashedPasswordIn            []string                     `json:"hashedPassword_in,omitempty"`
	HashedPasswordNotIn         []string                     `json:"hashedPassword_not_in,omitempty"`
	HashedPasswordLt            *string                      `json:"hashedPassword_lt,omitempty"`
	HashedPasswordLte           *string                      `json:"hashedPassword_lte,omitempty"`
	HashedPasswordGt            *string                      `json:"hashedPassword_gt,omitempty"`
	HashedPasswordGte           *string                      `json:"hashedPassword_gte,omitempty"`
	HashedPasswordContains      *string                      `json:"hashedPassword_contains,omitempty"`
	HashedPasswordNotContains   *string                      `json:"hashedPassword_not_contains,omitempty"`
	HashedPasswordStartsWith    *string                      `json:"hashedPassword_starts_with,omitempty"`
	HashedPasswordNotStartsWith *string                      `json:"hashedPassword_not_starts_with,omitempty"`
	HashedPasswordEndsWith      *string                      `json:"hashedPassword_ends_with,omitempty"`
	HashedPasswordNotEndsWith   *string                      `json:"hashedPassword_not_ends_with,omitempty"`
	And                         []CredentialScalarWhereInput `json:"AND,omitempty"`
	Or                          []CredentialScalarWhereInput `json:"OR,omitempty"`
	Not                         []CredentialScalarWhereInput `json:"NOT,omitempty"`
}

type PersonUpdateWithoutIdentificationDataInput struct {
	MId           *string                                `json:"mID,omitempty"`
	Name          *string                                `json:"name,omitempty"`
	Photo         *string                                `json:"photo,omitempty"`
	Birthday      *string                                `json:"birthday,omitempty"`
	From          *string                                `json:"from,omitempty"`
	ChannelsPhone *PhoneUpdateManyInput                  `json:"channelsPhone,omitempty"`
	ChannelsEmail *EmailUpdateManyInput                  `json:"channelsEmail,omitempty"`
	Tags          *PersonUpdatetagsInput                 `json:"tags,omitempty"`
	Credentials   *CredentialUpdateManyWithoutOwnerInput `json:"credentials,omitempty"`
}

type CredentialUpdateManyWithWhereNestedInput struct {
	Where CredentialScalarWhereInput    `json:"where"`
	Data  CredentialUpdateManyDataInput `json:"data"`
}

type PartnerCreateOneWithoutAttractionInput struct {
	Create  *PartnerCreateWithoutAttractionInput `json:"create,omitempty"`
	Connect *PartnerWhereUniqueInput             `json:"connect,omitempty"`
}

type CredentialUpdateManyDataInput struct {
	DisplayName    *string         `json:"displayName,omitempty"`
	IsMain         *bool           `json:"isMain,omitempty"`
	Type           *CredentialType `json:"type,omitempty"`
	Validated      *bool           `json:"validated,omitempty"`
	ValidationId   *string         `json:"validationID,omitempty"`
	Value          *string         `json:"value,omitempty"`
	RawPassword    *string         `json:"rawPassword,omitempty"`
	HashedPassword *string         `json:"hashedPassword,omitempty"`
}

type PersonCreateOneInput struct {
	Create  *PersonCreateInput      `json:"create,omitempty"`
	Connect *PersonWhereUniqueInput `json:"connect,omitempty"`
}

type PersonUpsertNestedInput struct {
	Update PersonUpdateDataInput `json:"update"`
	Create PersonCreateInput     `json:"create"`
}

type PhoneCreateManyInput struct {
	Create []PhoneCreateInput `json:"create,omitempty"`
}

type PersonCreateWithoutIdentificationInput struct {
	MId           *string                                `json:"mID,omitempty"`
	Name          string                                 `json:"name"`
	Photo         *string                                `json:"photo,omitempty"`
	Birthday      string                                 `json:"birthday"`
	From          *string                                `json:"from,omitempty"`
	ChannelsPhone *PhoneCreateManyInput                  `json:"channelsPhone,omitempty"`
	ChannelsEmail *EmailCreateManyInput                  `json:"channelsEmail,omitempty"`
	Tags          *PersonCreatetagsInput                 `json:"tags,omitempty"`
	Credentials   *CredentialCreateManyWithoutOwnerInput `json:"credentials,omitempty"`
}

type EmailCreateManyInput struct {
	Create []EmailCreateInput `json:"create,omitempty"`
}

type CredentialWhereInput struct {
	ID                          *string                `json:"id,omitempty"`
	IDNot                       *string                `json:"id_not,omitempty"`
	IDIn                        []string               `json:"id_in,omitempty"`
	IDNotIn                     []string               `json:"id_not_in,omitempty"`
	IDLt                        *string                `json:"id_lt,omitempty"`
	IDLte                       *string                `json:"id_lte,omitempty"`
	IDGt                        *string                `json:"id_gt,omitempty"`
	IDGte                       *string                `json:"id_gte,omitempty"`
	IDContains                  *string                `json:"id_contains,omitempty"`
	IDNotContains               *string                `json:"id_not_contains,omitempty"`
	IDStartsWith                *string                `json:"id_starts_with,omitempty"`
	IDNotStartsWith             *string                `json:"id_not_starts_with,omitempty"`
	IDEndsWith                  *string                `json:"id_ends_with,omitempty"`
	IDNotEndsWith               *string                `json:"id_not_ends_with,omitempty"`
	CreatedAt                   *string                `json:"createdAt,omitempty"`
	CreatedAtNot                *string                `json:"createdAt_not,omitempty"`
	CreatedAtIn                 []string               `json:"createdAt_in,omitempty"`
	CreatedAtNotIn              []string               `json:"createdAt_not_in,omitempty"`
	CreatedAtLt                 *string                `json:"createdAt_lt,omitempty"`
	CreatedAtLte                *string                `json:"createdAt_lte,omitempty"`
	CreatedAtGt                 *string                `json:"createdAt_gt,omitempty"`
	CreatedAtGte                *string                `json:"createdAt_gte,omitempty"`
	UpdatedAt                   *string                `json:"updatedAt,omitempty"`
	UpdatedAtNot                *string                `json:"updatedAt_not,omitempty"`
	UpdatedAtIn                 []string               `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn              []string               `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt                 *string                `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte                *string                `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt                 *string                `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte                *string                `json:"updatedAt_gte,omitempty"`
	DisplayName                 *string                `json:"displayName,omitempty"`
	DisplayNameNot              *string                `json:"displayName_not,omitempty"`
	DisplayNameIn               []string               `json:"displayName_in,omitempty"`
	DisplayNameNotIn            []string               `json:"displayName_not_in,omitempty"`
	DisplayNameLt               *string                `json:"displayName_lt,omitempty"`
	DisplayNameLte              *string                `json:"displayName_lte,omitempty"`
	DisplayNameGt               *string                `json:"displayName_gt,omitempty"`
	DisplayNameGte              *string                `json:"displayName_gte,omitempty"`
	DisplayNameContains         *string                `json:"displayName_contains,omitempty"`
	DisplayNameNotContains      *string                `json:"displayName_not_contains,omitempty"`
	DisplayNameStartsWith       *string                `json:"displayName_starts_with,omitempty"`
	DisplayNameNotStartsWith    *string                `json:"displayName_not_starts_with,omitempty"`
	DisplayNameEndsWith         *string                `json:"displayName_ends_with,omitempty"`
	DisplayNameNotEndsWith      *string                `json:"displayName_not_ends_with,omitempty"`
	Owner                       *PersonWhereInput      `json:"owner,omitempty"`
	IsMain                      *bool                  `json:"isMain,omitempty"`
	IsMainNot                   *bool                  `json:"isMain_not,omitempty"`
	Type                        *CredentialType        `json:"type,omitempty"`
	TypeNot                     *CredentialType        `json:"type_not,omitempty"`
	TypeIn                      []CredentialType       `json:"type_in,omitempty"`
	TypeNotIn                   []CredentialType       `json:"type_not_in,omitempty"`
	Validated                   *bool                  `json:"validated,omitempty"`
	ValidatedNot                *bool                  `json:"validated_not,omitempty"`
	ValidationId                *string                `json:"validationID,omitempty"`
	ValidationIdNot             *string                `json:"validationID_not,omitempty"`
	ValidationIdIn              []string               `json:"validationID_in,omitempty"`
	ValidationIdNotIn           []string               `json:"validationID_not_in,omitempty"`
	ValidationIdLt              *string                `json:"validationID_lt,omitempty"`
	ValidationIdLte             *string                `json:"validationID_lte,omitempty"`
	ValidationIdGt              *string                `json:"validationID_gt,omitempty"`
	ValidationIdGte             *string                `json:"validationID_gte,omitempty"`
	ValidationIdContains        *string                `json:"validationID_contains,omitempty"`
	ValidationIdNotContains     *string                `json:"validationID_not_contains,omitempty"`
	ValidationIdStartsWith      *string                `json:"validationID_starts_with,omitempty"`
	ValidationIdNotStartsWith   *string                `json:"validationID_not_starts_with,omitempty"`
	ValidationIdEndsWith        *string                `json:"validationID_ends_with,omitempty"`
	ValidationIdNotEndsWith     *string                `json:"validationID_not_ends_with,omitempty"`
	Value                       *string                `json:"value,omitempty"`
	ValueNot                    *string                `json:"value_not,omitempty"`
	ValueIn                     []string               `json:"value_in,omitempty"`
	ValueNotIn                  []string               `json:"value_not_in,omitempty"`
	ValueLt                     *string                `json:"value_lt,omitempty"`
	ValueLte                    *string                `json:"value_lte,omitempty"`
	ValueGt                     *string                `json:"value_gt,omitempty"`
	ValueGte                    *string                `json:"value_gte,omitempty"`
	ValueContains               *string                `json:"value_contains,omitempty"`
	ValueNotContains            *string                `json:"value_not_contains,omitempty"`
	ValueStartsWith             *string                `json:"value_starts_with,omitempty"`
	ValueNotStartsWith          *string                `json:"value_not_starts_with,omitempty"`
	ValueEndsWith               *string                `json:"value_ends_with,omitempty"`
	ValueNotEndsWith            *string                `json:"value_not_ends_with,omitempty"`
	RawPassword                 *string                `json:"rawPassword,omitempty"`
	RawPasswordNot              *string                `json:"rawPassword_not,omitempty"`
	RawPasswordIn               []string               `json:"rawPassword_in,omitempty"`
	RawPasswordNotIn            []string               `json:"rawPassword_not_in,omitempty"`
	RawPasswordLt               *string                `json:"rawPassword_lt,omitempty"`
	RawPasswordLte              *string                `json:"rawPassword_lte,omitempty"`
	RawPasswordGt               *string                `json:"rawPassword_gt,omitempty"`
	RawPasswordGte              *string                `json:"rawPassword_gte,omitempty"`
	RawPasswordContains         *string                `json:"rawPassword_contains,omitempty"`
	RawPasswordNotContains      *string                `json:"rawPassword_not_contains,omitempty"`
	RawPasswordStartsWith       *string                `json:"rawPassword_starts_with,omitempty"`
	RawPasswordNotStartsWith    *string                `json:"rawPassword_not_starts_with,omitempty"`
	RawPasswordEndsWith         *string                `json:"rawPassword_ends_with,omitempty"`
	RawPasswordNotEndsWith      *string                `json:"rawPassword_not_ends_with,omitempty"`
	HashedPassword              *string                `json:"hashedPassword,omitempty"`
	HashedPasswordNot           *string                `json:"hashedPassword_not,omitempty"`
	HashedPasswordIn            []string               `json:"hashedPassword_in,omitempty"`
	HashedPasswordNotIn         []string               `json:"hashedPassword_not_in,omitempty"`
	HashedPasswordLt            *string                `json:"hashedPassword_lt,omitempty"`
	HashedPasswordLte           *string                `json:"hashedPassword_lte,omitempty"`
	HashedPasswordGt            *string                `json:"hashedPassword_gt,omitempty"`
	HashedPasswordGte           *string                `json:"hashedPassword_gte,omitempty"`
	HashedPasswordContains      *string                `json:"hashedPassword_contains,omitempty"`
	HashedPasswordNotContains   *string                `json:"hashedPassword_not_contains,omitempty"`
	HashedPasswordStartsWith    *string                `json:"hashedPassword_starts_with,omitempty"`
	HashedPasswordNotStartsWith *string                `json:"hashedPassword_not_starts_with,omitempty"`
	HashedPasswordEndsWith      *string                `json:"hashedPassword_ends_with,omitempty"`
	HashedPasswordNotEndsWith   *string                `json:"hashedPassword_not_ends_with,omitempty"`
	And                         []CredentialWhereInput `json:"AND,omitempty"`
	Or                          []CredentialWhereInput `json:"OR,omitempty"`
	Not                         []CredentialWhereInput `json:"NOT,omitempty"`
}

type EmailCreateextrasInput struct {
	Set []string `json:"set,omitempty"`
}

type PersonCreateOneWithoutIdentificationInput struct {
	Create  *PersonCreateWithoutIdentificationInput `json:"create,omitempty"`
	Connect *PersonWhereUniqueInput                 `json:"connect,omitempty"`
}

type TravelerSubscriptionWhereInput struct {
	MutationIn                 []MutationType                   `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                          `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                         `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                         `json:"updatedFields_contains_some,omitempty"`
	Node                       *TravelerWhereInput              `json:"node,omitempty"`
	And                        []TravelerSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []TravelerSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []TravelerSubscriptionWhereInput `json:"NOT,omitempty"`
}

type LocationUpsertNestedInput struct {
	Update LocationUpdateDataInput `json:"update"`
	Create LocationCreateInput     `json:"create"`
}

type PartnerWhereInput struct {
	ID              *string               `json:"id,omitempty"`
	IDNot           *string               `json:"id_not,omitempty"`
	IDIn            []string              `json:"id_in,omitempty"`
	IDNotIn         []string              `json:"id_not_in,omitempty"`
	IDLt            *string               `json:"id_lt,omitempty"`
	IDLte           *string               `json:"id_lte,omitempty"`
	IDGt            *string               `json:"id_gt,omitempty"`
	IDGte           *string               `json:"id_gte,omitempty"`
	IDContains      *string               `json:"id_contains,omitempty"`
	IDNotContains   *string               `json:"id_not_contains,omitempty"`
	IDStartsWith    *string               `json:"id_starts_with,omitempty"`
	IDNotStartsWith *string               `json:"id_not_starts_with,omitempty"`
	IDEndsWith      *string               `json:"id_ends_with,omitempty"`
	IDNotEndsWith   *string               `json:"id_not_ends_with,omitempty"`
	CreatedAt       *string               `json:"createdAt,omitempty"`
	CreatedAtNot    *string               `json:"createdAt_not,omitempty"`
	CreatedAtIn     []string              `json:"createdAt_in,omitempty"`
	CreatedAtNotIn  []string              `json:"createdAt_not_in,omitempty"`
	CreatedAtLt     *string               `json:"createdAt_lt,omitempty"`
	CreatedAtLte    *string               `json:"createdAt_lte,omitempty"`
	CreatedAtGt     *string               `json:"createdAt_gt,omitempty"`
	CreatedAtGte    *string               `json:"createdAt_gte,omitempty"`
	UpdatedAt       *string               `json:"updatedAt,omitempty"`
	UpdatedAtNot    *string               `json:"updatedAt_not,omitempty"`
	UpdatedAtIn     []string              `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn  []string              `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt     *string               `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte    *string               `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt     *string               `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte    *string               `json:"updatedAt_gte,omitempty"`
	Person          *PersonWhereInput     `json:"person,omitempty"`
	Attraction      *AttractionWhereInput `json:"attraction,omitempty"`
	And             []PartnerWhereInput   `json:"AND,omitempty"`
	Or              []PartnerWhereInput   `json:"OR,omitempty"`
	Not             []PartnerWhereInput   `json:"NOT,omitempty"`
}

type PersonUpdateManyInput struct {
	Create     []PersonCreateInput                      `json:"create,omitempty"`
	Update     []PersonUpdateWithWhereUniqueNestedInput `json:"update,omitempty"`
	Upsert     []PersonUpsertWithWhereUniqueNestedInput `json:"upsert,omitempty"`
	Delete     []PersonWhereUniqueInput                 `json:"delete,omitempty"`
	Connect    []PersonWhereUniqueInput                 `json:"connect,omitempty"`
	Set        []PersonWhereUniqueInput                 `json:"set,omitempty"`
	Disconnect []PersonWhereUniqueInput                 `json:"disconnect,omitempty"`
	DeleteMany []PersonScalarWhereInput                 `json:"deleteMany,omitempty"`
	UpdateMany []PersonUpdateManyWithWhereNestedInput   `json:"updateMany,omitempty"`
}

type PartnerSubscriptionWhereInput struct {
	MutationIn                 []MutationType                  `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                         `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                        `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                        `json:"updatedFields_contains_some,omitempty"`
	Node                       *PartnerWhereInput              `json:"node,omitempty"`
	And                        []PartnerSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []PartnerSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []PartnerSubscriptionWhereInput `json:"NOT,omitempty"`
}

type PersonUpdateWithWhereUniqueNestedInput struct {
	Where PersonWhereUniqueInput `json:"where"`
	Data  PersonUpdateDataInput  `json:"data"`
}

type EmailSubscriptionWhereInput struct {
	MutationIn                 []MutationType                `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                       `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                      `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                      `json:"updatedFields_contains_some,omitempty"`
	Node                       *EmailWhereInput              `json:"node,omitempty"`
	And                        []EmailSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []EmailSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []EmailSubscriptionWhereInput `json:"NOT,omitempty"`
}

type PersonUpsertWithWhereUniqueNestedInput struct {
	Where  PersonWhereUniqueInput `json:"where"`
	Update PersonUpdateDataInput  `json:"update"`
	Create PersonCreateInput      `json:"create"`
}

type AttractionSubscriptionWhereInput struct {
	MutationIn                 []MutationType                     `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                            `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                           `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                           `json:"updatedFields_contains_some,omitempty"`
	Node                       *AttractionWhereInput              `json:"node,omitempty"`
	And                        []AttractionSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []AttractionSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []AttractionSubscriptionWhereInput `json:"NOT,omitempty"`
}

type PersonScalarWhereInput struct {
	ID                 *string                  `json:"id,omitempty"`
	IDNot              *string                  `json:"id_not,omitempty"`
	IDIn               []string                 `json:"id_in,omitempty"`
	IDNotIn            []string                 `json:"id_not_in,omitempty"`
	IDLt               *string                  `json:"id_lt,omitempty"`
	IDLte              *string                  `json:"id_lte,omitempty"`
	IDGt               *string                  `json:"id_gt,omitempty"`
	IDGte              *string                  `json:"id_gte,omitempty"`
	IDContains         *string                  `json:"id_contains,omitempty"`
	IDNotContains      *string                  `json:"id_not_contains,omitempty"`
	IDStartsWith       *string                  `json:"id_starts_with,omitempty"`
	IDNotStartsWith    *string                  `json:"id_not_starts_with,omitempty"`
	IDEndsWith         *string                  `json:"id_ends_with,omitempty"`
	IDNotEndsWith      *string                  `json:"id_not_ends_with,omitempty"`
	CreatedAt          *string                  `json:"createdAt,omitempty"`
	CreatedAtNot       *string                  `json:"createdAt_not,omitempty"`
	CreatedAtIn        []string                 `json:"createdAt_in,omitempty"`
	CreatedAtNotIn     []string                 `json:"createdAt_not_in,omitempty"`
	CreatedAtLt        *string                  `json:"createdAt_lt,omitempty"`
	CreatedAtLte       *string                  `json:"createdAt_lte,omitempty"`
	CreatedAtGt        *string                  `json:"createdAt_gt,omitempty"`
	CreatedAtGte       *string                  `json:"createdAt_gte,omitempty"`
	UpdatedAt          *string                  `json:"updatedAt,omitempty"`
	UpdatedAtNot       *string                  `json:"updatedAt_not,omitempty"`
	UpdatedAtIn        []string                 `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn     []string                 `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt        *string                  `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte       *string                  `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt        *string                  `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte       *string                  `json:"updatedAt_gte,omitempty"`
	MId                *string                  `json:"mID,omitempty"`
	MIdNot             *string                  `json:"mID_not,omitempty"`
	MIdIn              []string                 `json:"mID_in,omitempty"`
	MIdNotIn           []string                 `json:"mID_not_in,omitempty"`
	MIdLt              *string                  `json:"mID_lt,omitempty"`
	MIdLte             *string                  `json:"mID_lte,omitempty"`
	MIdGt              *string                  `json:"mID_gt,omitempty"`
	MIdGte             *string                  `json:"mID_gte,omitempty"`
	MIdContains        *string                  `json:"mID_contains,omitempty"`
	MIdNotContains     *string                  `json:"mID_not_contains,omitempty"`
	MIdStartsWith      *string                  `json:"mID_starts_with,omitempty"`
	MIdNotStartsWith   *string                  `json:"mID_not_starts_with,omitempty"`
	MIdEndsWith        *string                  `json:"mID_ends_with,omitempty"`
	MIdNotEndsWith     *string                  `json:"mID_not_ends_with,omitempty"`
	Name               *string                  `json:"name,omitempty"`
	NameNot            *string                  `json:"name_not,omitempty"`
	NameIn             []string                 `json:"name_in,omitempty"`
	NameNotIn          []string                 `json:"name_not_in,omitempty"`
	NameLt             *string                  `json:"name_lt,omitempty"`
	NameLte            *string                  `json:"name_lte,omitempty"`
	NameGt             *string                  `json:"name_gt,omitempty"`
	NameGte            *string                  `json:"name_gte,omitempty"`
	NameContains       *string                  `json:"name_contains,omitempty"`
	NameNotContains    *string                  `json:"name_not_contains,omitempty"`
	NameStartsWith     *string                  `json:"name_starts_with,omitempty"`
	NameNotStartsWith  *string                  `json:"name_not_starts_with,omitempty"`
	NameEndsWith       *string                  `json:"name_ends_with,omitempty"`
	NameNotEndsWith    *string                  `json:"name_not_ends_with,omitempty"`
	Photo              *string                  `json:"photo,omitempty"`
	PhotoNot           *string                  `json:"photo_not,omitempty"`
	PhotoIn            []string                 `json:"photo_in,omitempty"`
	PhotoNotIn         []string                 `json:"photo_not_in,omitempty"`
	PhotoLt            *string                  `json:"photo_lt,omitempty"`
	PhotoLte           *string                  `json:"photo_lte,omitempty"`
	PhotoGt            *string                  `json:"photo_gt,omitempty"`
	PhotoGte           *string                  `json:"photo_gte,omitempty"`
	PhotoContains      *string                  `json:"photo_contains,omitempty"`
	PhotoNotContains   *string                  `json:"photo_not_contains,omitempty"`
	PhotoStartsWith    *string                  `json:"photo_starts_with,omitempty"`
	PhotoNotStartsWith *string                  `json:"photo_not_starts_with,omitempty"`
	PhotoEndsWith      *string                  `json:"photo_ends_with,omitempty"`
	PhotoNotEndsWith   *string                  `json:"photo_not_ends_with,omitempty"`
	Birthday           *string                  `json:"birthday,omitempty"`
	BirthdayNot        *string                  `json:"birthday_not,omitempty"`
	BirthdayIn         []string                 `json:"birthday_in,omitempty"`
	BirthdayNotIn      []string                 `json:"birthday_not_in,omitempty"`
	BirthdayLt         *string                  `json:"birthday_lt,omitempty"`
	BirthdayLte        *string                  `json:"birthday_lte,omitempty"`
	BirthdayGt         *string                  `json:"birthday_gt,omitempty"`
	BirthdayGte        *string                  `json:"birthday_gte,omitempty"`
	From               *string                  `json:"from,omitempty"`
	FromNot            *string                  `json:"from_not,omitempty"`
	FromIn             []string                 `json:"from_in,omitempty"`
	FromNotIn          []string                 `json:"from_not_in,omitempty"`
	FromLt             *string                  `json:"from_lt,omitempty"`
	FromLte            *string                  `json:"from_lte,omitempty"`
	FromGt             *string                  `json:"from_gt,omitempty"`
	FromGte            *string                  `json:"from_gte,omitempty"`
	FromContains       *string                  `json:"from_contains,omitempty"`
	FromNotContains    *string                  `json:"from_not_contains,omitempty"`
	FromStartsWith     *string                  `json:"from_starts_with,omitempty"`
	FromNotStartsWith  *string                  `json:"from_not_starts_with,omitempty"`
	FromEndsWith       *string                  `json:"from_ends_with,omitempty"`
	FromNotEndsWith    *string                  `json:"from_not_ends_with,omitempty"`
	And                []PersonScalarWhereInput `json:"AND,omitempty"`
	Or                 []PersonScalarWhereInput `json:"OR,omitempty"`
	Not                []PersonScalarWhereInput `json:"NOT,omitempty"`
}

type CreditCardUpdateManyDataInput struct {
	CardNumber *string         `json:"cardNumber,omitempty"`
	CardToken  *string         `json:"cardToken,omitempty"`
	Type       *CreditCardType `json:"type,omitempty"`
	LastUsed   *string         `json:"lastUsed,omitempty"`
}

type PersonUpdateManyWithWhereNestedInput struct {
	Where PersonScalarWhereInput    `json:"where"`
	Data  PersonUpdateManyDataInput `json:"data"`
}

type CreditCardScalarWhereInput struct {
	ID                      *string                      `json:"id,omitempty"`
	IDNot                   *string                      `json:"id_not,omitempty"`
	IDIn                    []string                     `json:"id_in,omitempty"`
	IDNotIn                 []string                     `json:"id_not_in,omitempty"`
	IDLt                    *string                      `json:"id_lt,omitempty"`
	IDLte                   *string                      `json:"id_lte,omitempty"`
	IDGt                    *string                      `json:"id_gt,omitempty"`
	IDGte                   *string                      `json:"id_gte,omitempty"`
	IDContains              *string                      `json:"id_contains,omitempty"`
	IDNotContains           *string                      `json:"id_not_contains,omitempty"`
	IDStartsWith            *string                      `json:"id_starts_with,omitempty"`
	IDNotStartsWith         *string                      `json:"id_not_starts_with,omitempty"`
	IDEndsWith              *string                      `json:"id_ends_with,omitempty"`
	IDNotEndsWith           *string                      `json:"id_not_ends_with,omitempty"`
	CreatedAt               *string                      `json:"createdAt,omitempty"`
	CreatedAtNot            *string                      `json:"createdAt_not,omitempty"`
	CreatedAtIn             []string                     `json:"createdAt_in,omitempty"`
	CreatedAtNotIn          []string                     `json:"createdAt_not_in,omitempty"`
	CreatedAtLt             *string                      `json:"createdAt_lt,omitempty"`
	CreatedAtLte            *string                      `json:"createdAt_lte,omitempty"`
	CreatedAtGt             *string                      `json:"createdAt_gt,omitempty"`
	CreatedAtGte            *string                      `json:"createdAt_gte,omitempty"`
	UpdatedAt               *string                      `json:"updatedAt,omitempty"`
	UpdatedAtNot            *string                      `json:"updatedAt_not,omitempty"`
	UpdatedAtIn             []string                     `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn          []string                     `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt             *string                      `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte            *string                      `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt             *string                      `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte            *string                      `json:"updatedAt_gte,omitempty"`
	CardNumber              *string                      `json:"cardNumber,omitempty"`
	CardNumberNot           *string                      `json:"cardNumber_not,omitempty"`
	CardNumberIn            []string                     `json:"cardNumber_in,omitempty"`
	CardNumberNotIn         []string                     `json:"cardNumber_not_in,omitempty"`
	CardNumberLt            *string                      `json:"cardNumber_lt,omitempty"`
	CardNumberLte           *string                      `json:"cardNumber_lte,omitempty"`
	CardNumberGt            *string                      `json:"cardNumber_gt,omitempty"`
	CardNumberGte           *string                      `json:"cardNumber_gte,omitempty"`
	CardNumberContains      *string                      `json:"cardNumber_contains,omitempty"`
	CardNumberNotContains   *string                      `json:"cardNumber_not_contains,omitempty"`
	CardNumberStartsWith    *string                      `json:"cardNumber_starts_with,omitempty"`
	CardNumberNotStartsWith *string                      `json:"cardNumber_not_starts_with,omitempty"`
	CardNumberEndsWith      *string                      `json:"cardNumber_ends_with,omitempty"`
	CardNumberNotEndsWith   *string                      `json:"cardNumber_not_ends_with,omitempty"`
	CardToken               *string                      `json:"cardToken,omitempty"`
	CardTokenNot            *string                      `json:"cardToken_not,omitempty"`
	CardTokenIn             []string                     `json:"cardToken_in,omitempty"`
	CardTokenNotIn          []string                     `json:"cardToken_not_in,omitempty"`
	CardTokenLt             *string                      `json:"cardToken_lt,omitempty"`
	CardTokenLte            *string                      `json:"cardToken_lte,omitempty"`
	CardTokenGt             *string                      `json:"cardToken_gt,omitempty"`
	CardTokenGte            *string                      `json:"cardToken_gte,omitempty"`
	CardTokenContains       *string                      `json:"cardToken_contains,omitempty"`
	CardTokenNotContains    *string                      `json:"cardToken_not_contains,omitempty"`
	CardTokenStartsWith     *string                      `json:"cardToken_starts_with,omitempty"`
	CardTokenNotStartsWith  *string                      `json:"cardToken_not_starts_with,omitempty"`
	CardTokenEndsWith       *string                      `json:"cardToken_ends_with,omitempty"`
	CardTokenNotEndsWith    *string                      `json:"cardToken_not_ends_with,omitempty"`
	Type                    *CreditCardType              `json:"type,omitempty"`
	TypeNot                 *CreditCardType              `json:"type_not,omitempty"`
	TypeIn                  []CreditCardType             `json:"type_in,omitempty"`
	TypeNotIn               []CreditCardType             `json:"type_not_in,omitempty"`
	LastUsed                *string                      `json:"lastUsed,omitempty"`
	LastUsedNot             *string                      `json:"lastUsed_not,omitempty"`
	LastUsedIn              []string                     `json:"lastUsed_in,omitempty"`
	LastUsedNotIn           []string                     `json:"lastUsed_not_in,omitempty"`
	LastUsedLt              *string                      `json:"lastUsed_lt,omitempty"`
	LastUsedLte             *string                      `json:"lastUsed_lte,omitempty"`
	LastUsedGt              *string                      `json:"lastUsed_gt,omitempty"`
	LastUsedGte             *string                      `json:"lastUsed_gte,omitempty"`
	And                     []CreditCardScalarWhereInput `json:"AND,omitempty"`
	Or                      []CreditCardScalarWhereInput `json:"OR,omitempty"`
	Not                     []CreditCardScalarWhereInput `json:"NOT,omitempty"`
}

type PersonUpdateManyDataInput struct {
	MId      *string                `json:"mID,omitempty"`
	Name     *string                `json:"name,omitempty"`
	Photo    *string                `json:"photo,omitempty"`
	Birthday *string                `json:"birthday,omitempty"`
	From     *string                `json:"from,omitempty"`
	Tags     *PersonUpdatetagsInput `json:"tags,omitempty"`
}

type CreditCardUpdateManyWithoutOwnerInput struct {
	Create     []CreditCardCreateWithoutOwnerInput                `json:"create,omitempty"`
	Delete     []CreditCardWhereUniqueInput                       `json:"delete,omitempty"`
	Connect    []CreditCardWhereUniqueInput                       `json:"connect,omitempty"`
	Set        []CreditCardWhereUniqueInput                       `json:"set,omitempty"`
	Disconnect []CreditCardWhereUniqueInput                       `json:"disconnect,omitempty"`
	Update     []CreditCardUpdateWithWhereUniqueWithoutOwnerInput `json:"update,omitempty"`
	Upsert     []CreditCardUpsertWithWhereUniqueWithoutOwnerInput `json:"upsert,omitempty"`
	DeleteMany []CreditCardScalarWhereInput                       `json:"deleteMany,omitempty"`
	UpdateMany []CreditCardUpdateManyWithWhereNestedInput         `json:"updateMany,omitempty"`
}

type AttractionUpdatetypesInput struct {
	Set []AttractionType `json:"set,omitempty"`
}

type CreditCardCreateManyWithoutOwnerInput struct {
	Create  []CreditCardCreateWithoutOwnerInput `json:"create,omitempty"`
	Connect []CreditCardWhereUniqueInput        `json:"connect,omitempty"`
}

type AttractionUpdatetagsInput struct {
	Set []string `json:"set,omitempty"`
}

type PersonUpdateInput struct {
	MId            *string                                                    `json:"mID,omitempty"`
	Name           *string                                                    `json:"name,omitempty"`
	Photo          *string                                                    `json:"photo,omitempty"`
	Birthday       *string                                                    `json:"birthday,omitempty"`
	From           *string                                                    `json:"from,omitempty"`
	ChannelsPhone  *PhoneUpdateManyInput                                      `json:"channelsPhone,omitempty"`
	ChannelsEmail  *EmailUpdateManyInput                                      `json:"channelsEmail,omitempty"`
	IDentification *IDentificationDocumentUpdateOneRequiredWithoutPersonInput `json:"identification,omitempty"`
	Tags           *PersonUpdatetagsInput                                     `json:"tags,omitempty"`
	Credentials    *CredentialUpdateManyWithoutOwnerInput                     `json:"credentials,omitempty"`
}

type AttractionUpdateManyMutationInput struct {
	Name        *string                     `json:"name,omitempty"`
	Description *string                     `json:"description,omitempty"`
	Address     *string                     `json:"address,omitempty"`
	Popularity  *int32                      `json:"popularity,omitempty"`
	Types       *AttractionUpdatetypesInput `json:"types,omitempty"`
	Tags        *AttractionUpdatetagsInput  `json:"tags,omitempty"`
}

type PartnerWhereUniqueInput struct {
	ID *string `json:"id,omitempty"`
}

type IDentificationDocumentCreateInput struct {
	Person PersonCreateOneWithoutIdentificationInput `json:"person"`
	Type   IDentificationType                        `json:"type"`
	Value  string                                    `json:"value"`
}

type CreditCardCreateOneWithoutUsesInput struct {
	Create  *CreditCardCreateWithoutUsesInput `json:"create,omitempty"`
	Connect *CreditCardWhereUniqueInput       `json:"connect,omitempty"`
}

type EmailUpdateManyMutationInput struct {
	Type   *CommunicationType      `json:"type,omitempty"`
	Value  *string                 `json:"value,omitempty"`
	Extras *EmailUpdateextrasInput `json:"extras,omitempty"`
}

type AttractionUpdateWithoutOwnerDataInput struct {
	Name        *string                         `json:"name,omitempty"`
	Description *string                         `json:"description,omitempty"`
	Address     *string                         `json:"address,omitempty"`
	Location    *LocationUpdateOneRequiredInput `json:"location,omitempty"`
	Popularity  *int32                          `json:"popularity,omitempty"`
	LikedBy     *PersonUpdateManyInput          `json:"likedBy,omitempty"`
	Types       *AttractionUpdatetypesInput     `json:"types,omitempty"`
	Tags        *AttractionUpdatetagsInput      `json:"tags,omitempty"`
}

type CredentialCreateInput struct {
	DisplayName    *string                                `json:"displayName,omitempty"`
	Owner          PersonCreateOneWithoutCredentialsInput `json:"owner"`
	IsMain         bool                                   `json:"isMain"`
	Type           *CredentialType                        `json:"type,omitempty"`
	Validated      *bool                                  `json:"validated,omitempty"`
	ValidationId   *string                                `json:"validationID,omitempty"`
	Value          string                                 `json:"value"`
	RawPassword    *string                                `json:"rawPassword,omitempty"`
	HashedPassword string                                 `json:"hashedPassword"`
}

type AttractionCreateWithoutOwnerInput struct {
	Name        string                      `json:"name"`
	Description string                      `json:"description"`
	Address     string                      `json:"address"`
	Location    LocationCreateOneInput      `json:"location"`
	Popularity  *int32                      `json:"popularity,omitempty"`
	LikedBy     *PersonCreateManyInput      `json:"likedBy,omitempty"`
	Types       *AttractionCreatetypesInput `json:"types,omitempty"`
	Tags        *AttractionCreatetagsInput  `json:"tags,omitempty"`
}

type PersonCreateOneWithoutCredentialsInput struct {
	Create  *PersonCreateWithoutCredentialsInput `json:"create,omitempty"`
	Connect *PersonWhereUniqueInput              `json:"connect,omitempty"`
}

type TravelerWhereUniqueInput struct {
	ID       *string `json:"id,omitempty"`
	Username *string `json:"username,omitempty"`
}

type PersonCreateWithoutCredentialsInput struct {
	MId            *string                                           `json:"mID,omitempty"`
	Name           string                                            `json:"name"`
	Photo          *string                                           `json:"photo,omitempty"`
	Birthday       string                                            `json:"birthday"`
	From           *string                                           `json:"from,omitempty"`
	ChannelsPhone  *PhoneCreateManyInput                             `json:"channelsPhone,omitempty"`
	ChannelsEmail  *EmailCreateManyInput                             `json:"channelsEmail,omitempty"`
	IDentification IDentificationDocumentCreateOneWithoutPersonInput `json:"identification"`
	Tags           *PersonCreatetagsInput                            `json:"tags,omitempty"`
}

type PersonUpdateOneRequiredWithoutIdentificationInput struct {
	Create  *PersonCreateWithoutIdentificationInput     `json:"create,omitempty"`
	Update  *PersonUpdateWithoutIdentificationDataInput `json:"update,omitempty"`
	Upsert  *PersonUpsertWithoutIdentificationInput     `json:"upsert,omitempty"`
	Connect *PersonWhereUniqueInput                     `json:"connect,omitempty"`
}

type CredentialUpdateInput struct {
	DisplayName    *string                                         `json:"displayName,omitempty"`
	Owner          *PersonUpdateOneRequiredWithoutCredentialsInput `json:"owner,omitempty"`
	IsMain         *bool                                           `json:"isMain,omitempty"`
	Type           *CredentialType                                 `json:"type,omitempty"`
	Validated      *bool                                           `json:"validated,omitempty"`
	ValidationId   *string                                         `json:"validationID,omitempty"`
	Value          *string                                         `json:"value,omitempty"`
	RawPassword    *string                                         `json:"rawPassword,omitempty"`
	HashedPassword *string                                         `json:"hashedPassword,omitempty"`
}

type PartnerCreateWithoutAttractionInput struct {
	Person PersonCreateOneInput `json:"person"`
}

type PersonUpdateOneRequiredWithoutCredentialsInput struct {
	Create  *PersonCreateWithoutCredentialsInput     `json:"create,omitempty"`
	Update  *PersonUpdateWithoutCredentialsDataInput `json:"update,omitempty"`
	Upsert  *PersonUpsertWithoutCredentialsInput     `json:"upsert,omitempty"`
	Connect *PersonWhereUniqueInput                  `json:"connect,omitempty"`
}

type PhoneCreateInput struct {
	Type        *CommunicationType `json:"type,omitempty"`
	CountryCode string             `json:"countryCode"`
	Number      *string            `json:"number,omitempty"`
}

type PersonUpdateWithoutCredentialsDataInput struct {
	MId            *string                                                    `json:"mID,omitempty"`
	Name           *string                                                    `json:"name,omitempty"`
	Photo          *string                                                    `json:"photo,omitempty"`
	Birthday       *string                                                    `json:"birthday,omitempty"`
	From           *string                                                    `json:"from,omitempty"`
	ChannelsPhone  *PhoneUpdateManyInput                                      `json:"channelsPhone,omitempty"`
	ChannelsEmail  *EmailUpdateManyInput                                      `json:"channelsEmail,omitempty"`
	IDentification *IDentificationDocumentUpdateOneRequiredWithoutPersonInput `json:"identification,omitempty"`
	Tags           *PersonUpdatetagsInput                                     `json:"tags,omitempty"`
}

type IDentificationDocumentCreateOneWithoutPersonInput struct {
	Create  *IDentificationDocumentCreateWithoutPersonInput `json:"create,omitempty"`
	Connect *IDentificationDocumentWhereUniqueInput         `json:"connect,omitempty"`
}

type PersonUpsertWithoutCredentialsInput struct {
	Update PersonUpdateWithoutCredentialsDataInput `json:"update"`
	Create PersonCreateWithoutCredentialsInput     `json:"create"`
}

type EmailWhereInput struct {
	Type               *CommunicationType  `json:"type,omitempty"`
	TypeNot            *CommunicationType  `json:"type_not,omitempty"`
	TypeIn             []CommunicationType `json:"type_in,omitempty"`
	TypeNotIn          []CommunicationType `json:"type_not_in,omitempty"`
	Value              *string             `json:"value,omitempty"`
	ValueNot           *string             `json:"value_not,omitempty"`
	ValueIn            []string            `json:"value_in,omitempty"`
	ValueNotIn         []string            `json:"value_not_in,omitempty"`
	ValueLt            *string             `json:"value_lt,omitempty"`
	ValueLte           *string             `json:"value_lte,omitempty"`
	ValueGt            *string             `json:"value_gt,omitempty"`
	ValueGte           *string             `json:"value_gte,omitempty"`
	ValueContains      *string             `json:"value_contains,omitempty"`
	ValueNotContains   *string             `json:"value_not_contains,omitempty"`
	ValueStartsWith    *string             `json:"value_starts_with,omitempty"`
	ValueNotStartsWith *string             `json:"value_not_starts_with,omitempty"`
	ValueEndsWith      *string             `json:"value_ends_with,omitempty"`
	ValueNotEndsWith   *string             `json:"value_not_ends_with,omitempty"`
	And                []EmailWhereInput   `json:"AND,omitempty"`
	Or                 []EmailWhereInput   `json:"OR,omitempty"`
	Not                []EmailWhereInput   `json:"NOT,omitempty"`
}

type CredentialUpdateManyMutationInput struct {
	DisplayName    *string         `json:"displayName,omitempty"`
	IsMain         *bool           `json:"isMain,omitempty"`
	Type           *CredentialType `json:"type,omitempty"`
	Validated      *bool           `json:"validated,omitempty"`
	ValidationId   *string         `json:"validationID,omitempty"`
	Value          *string         `json:"value,omitempty"`
	RawPassword    *string         `json:"rawPassword,omitempty"`
	HashedPassword *string         `json:"hashedPassword,omitempty"`
}

type CredentialSubscriptionWhereInput struct {
	MutationIn                 []MutationType                     `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                            `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                           `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                           `json:"updatedFields_contains_some,omitempty"`
	Node                       *CredentialWhereInput              `json:"node,omitempty"`
	And                        []CredentialSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []CredentialSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []CredentialSubscriptionWhereInput `json:"NOT,omitempty"`
}

type CreditCardCreateInput struct {
	Owner      TravelerCreateOneWithoutCardsInput          `json:"owner"`
	CardNumber string                                      `json:"cardNumber"`
	CardToken  string                                      `json:"cardToken"`
	Type       *CreditCardType                             `json:"type,omitempty"`
	LastUsed   *string                                     `json:"lastUsed,omitempty"`
	Uses       *PaymentEntryCreateManyWithoutWithCardInput `json:"uses,omitempty"`
}

type CreditCardUpdateManyWithWhereNestedInput struct {
	Where CreditCardScalarWhereInput    `json:"where"`
	Data  CreditCardUpdateManyDataInput `json:"data"`
}

type TravelerCreateOneWithoutCardsInput struct {
	Create  *TravelerCreateWithoutCardsInput `json:"create,omitempty"`
	Connect *TravelerWhereUniqueInput        `json:"connect,omitempty"`
}

type CreditCardCreateWithoutOwnerInput struct {
	CardNumber string                                      `json:"cardNumber"`
	CardToken  string                                      `json:"cardToken"`
	Type       *CreditCardType                             `json:"type,omitempty"`
	LastUsed   *string                                     `json:"lastUsed,omitempty"`
	Uses       *PaymentEntryCreateManyWithoutWithCardInput `json:"uses,omitempty"`
}

type TravelerCreateWithoutCardsInput struct {
	Person   PersonCreateOneInput `json:"person"`
	Username string               `json:"username"`
}

type CreditCardUpsertWithoutUsesInput struct {
	Update CreditCardUpdateWithoutUsesDataInput `json:"update"`
	Create CreditCardCreateWithoutUsesInput     `json:"create"`
}

type PaymentEntryCreateManyWithoutWithCardInput struct {
	Create  []PaymentEntryCreateWithoutWithCardInput `json:"create,omitempty"`
	Connect []PaymentEntryWhereUniqueInput           `json:"connect,omitempty"`
}

type PaymentEntryCreateInput struct {
	ExternalId      string                              `json:"externalID"`
	WithCard        CreditCardCreateOneWithoutUsesInput `json:"withCard"`
	ProductId       string                              `json:"productID"`
	Product         string                              `json:"product"`
	GatewayResponse *string                             `json:"gatewayResponse,omitempty"`
	Amount          int32                               `json:"amount"`
	DiscountId      *string                             `json:"discountID,omitempty"`
	Discount        *int32                              `json:"discount,omitempty"`
}

type PaymentEntryCreateWithoutWithCardInput struct {
	ExternalId      string  `json:"externalID"`
	ProductId       string  `json:"productID"`
	Product         string  `json:"product"`
	GatewayResponse *string `json:"gatewayResponse,omitempty"`
	Amount          int32   `json:"amount"`
	DiscountId      *string `json:"discountID,omitempty"`
	Discount        *int32  `json:"discount,omitempty"`
}

type PartnerCreateInput struct {
	Person     PersonCreateOneInput                 `json:"person"`
	Attraction AttractionCreateOneWithoutOwnerInput `json:"attraction"`
}

type CreditCardUpdateInput struct {
	Owner      *TravelerUpdateOneRequiredWithoutCardsInput `json:"owner,omitempty"`
	CardNumber *string                                     `json:"cardNumber,omitempty"`
	CardToken  *string                                     `json:"cardToken,omitempty"`
	Type       *CreditCardType                             `json:"type,omitempty"`
	LastUsed   *string                                     `json:"lastUsed,omitempty"`
	Uses       *PaymentEntryUpdateManyWithoutWithCardInput `json:"uses,omitempty"`
}

type AttractionCreateInput struct {
	Owner       PartnerCreateOneWithoutAttractionInput `json:"owner"`
	Name        string                                 `json:"name"`
	Description string                                 `json:"description"`
	Address     string                                 `json:"address"`
	Location    LocationCreateOneInput                 `json:"location"`
	Popularity  *int32                                 `json:"popularity,omitempty"`
	LikedBy     *PersonCreateManyInput                 `json:"likedBy,omitempty"`
	Types       *AttractionCreatetypesInput            `json:"types,omitempty"`
	Tags        *AttractionCreatetagsInput             `json:"tags,omitempty"`
}

type TravelerUpdateOneRequiredWithoutCardsInput struct {
	Create  *TravelerCreateWithoutCardsInput     `json:"create,omitempty"`
	Update  *TravelerUpdateWithoutCardsDataInput `json:"update,omitempty"`
	Upsert  *TravelerUpsertWithoutCardsInput     `json:"upsert,omitempty"`
	Connect *TravelerWhereUniqueInput            `json:"connect,omitempty"`
}

type EmailCreateInput struct {
	Type   *CommunicationType      `json:"type,omitempty"`
	Value  string                  `json:"value"`
	Extras *EmailCreateextrasInput `json:"extras,omitempty"`
}

type TravelerUpdateWithoutCardsDataInput struct {
	Person   *PersonUpdateOneRequiredInput `json:"person,omitempty"`
	Username *string                       `json:"username,omitempty"`
}

type IDentificationDocumentSubscriptionWhereInput struct {
	MutationIn                 []MutationType                                 `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                                        `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                                       `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                                       `json:"updatedFields_contains_some,omitempty"`
	Node                       *IDentificationDocumentWhereInput              `json:"node,omitempty"`
	And                        []IDentificationDocumentSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []IDentificationDocumentSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []IDentificationDocumentSubscriptionWhereInput `json:"NOT,omitempty"`
}

type TravelerUpsertWithoutCardsInput struct {
	Update TravelerUpdateWithoutCardsDataInput `json:"update"`
	Create TravelerCreateWithoutCardsInput     `json:"create"`
}

type CreditCardUpdateWithoutOwnerDataInput struct {
	CardNumber *string                                     `json:"cardNumber,omitempty"`
	CardToken  *string                                     `json:"cardToken,omitempty"`
	Type       *CreditCardType                             `json:"type,omitempty"`
	LastUsed   *string                                     `json:"lastUsed,omitempty"`
	Uses       *PaymentEntryUpdateManyWithoutWithCardInput `json:"uses,omitempty"`
}

type PaymentEntryUpdateManyWithoutWithCardInput struct {
	Create     []PaymentEntryCreateWithoutWithCardInput                `json:"create,omitempty"`
	Delete     []PaymentEntryWhereUniqueInput                          `json:"delete,omitempty"`
	Connect    []PaymentEntryWhereUniqueInput                          `json:"connect,omitempty"`
	Set        []PaymentEntryWhereUniqueInput                          `json:"set,omitempty"`
	Disconnect []PaymentEntryWhereUniqueInput                          `json:"disconnect,omitempty"`
	Update     []PaymentEntryUpdateWithWhereUniqueWithoutWithCardInput `json:"update,omitempty"`
	Upsert     []PaymentEntryUpsertWithWhereUniqueWithoutWithCardInput `json:"upsert,omitempty"`
	DeleteMany []PaymentEntryScalarWhereInput                          `json:"deleteMany,omitempty"`
	UpdateMany []PaymentEntryUpdateManyWithWhereNestedInput            `json:"updateMany,omitempty"`
}

type PaymentEntryUpdateInput struct {
	ExternalId      *string                                      `json:"externalID,omitempty"`
	WithCard        *CreditCardUpdateOneRequiredWithoutUsesInput `json:"withCard,omitempty"`
	ProductId       *string                                      `json:"productID,omitempty"`
	Product         *string                                      `json:"product,omitempty"`
	GatewayResponse *string                                      `json:"gatewayResponse,omitempty"`
	Amount          *int32                                       `json:"amount,omitempty"`
	DiscountId      *string                                      `json:"discountID,omitempty"`
	Discount        *int32                                       `json:"discount,omitempty"`
}

type PaymentEntryUpdateWithWhereUniqueWithoutWithCardInput struct {
	Where PaymentEntryWhereUniqueInput               `json:"where"`
	Data  PaymentEntryUpdateWithoutWithCardDataInput `json:"data"`
}

type PersonUpsertWithoutIdentificationInput struct {
	Update PersonUpdateWithoutIdentificationDataInput `json:"update"`
	Create PersonCreateWithoutIdentificationInput     `json:"create"`
}

type PaymentEntryUpdateWithoutWithCardDataInput struct {
	ExternalId      *string `json:"externalID,omitempty"`
	ProductId       *string `json:"productID,omitempty"`
	Product         *string `json:"product,omitempty"`
	GatewayResponse *string `json:"gatewayResponse,omitempty"`
	Amount          *int32  `json:"amount,omitempty"`
	DiscountId      *string `json:"discountID,omitempty"`
	Discount        *int32  `json:"discount,omitempty"`
}

type PersonSubscriptionWhereInput struct {
	MutationIn                 []MutationType                 `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                        `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                       `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                       `json:"updatedFields_contains_some,omitempty"`
	Node                       *PersonWhereInput              `json:"node,omitempty"`
	And                        []PersonSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []PersonSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []PersonSubscriptionWhereInput `json:"NOT,omitempty"`
}

type PaymentEntryUpdateManyDataInput struct {
	ExternalId      *string `json:"externalID,omitempty"`
	ProductId       *string `json:"productID,omitempty"`
	Product         *string `json:"product,omitempty"`
	GatewayResponse *string `json:"gatewayResponse,omitempty"`
	Amount          *int32  `json:"amount,omitempty"`
	DiscountId      *string `json:"discountID,omitempty"`
	Discount        *int32  `json:"discount,omitempty"`
}

type PaymentEntryUpdateManyWithWhereNestedInput struct {
	Where PaymentEntryScalarWhereInput    `json:"where"`
	Data  PaymentEntryUpdateManyDataInput `json:"data"`
}

type PaymentEntryScalarWhereInput struct {
	ID                           *string                        `json:"id,omitempty"`
	IDNot                        *string                        `json:"id_not,omitempty"`
	IDIn                         []string                       `json:"id_in,omitempty"`
	IDNotIn                      []string                       `json:"id_not_in,omitempty"`
	IDLt                         *string                        `json:"id_lt,omitempty"`
	IDLte                        *string                        `json:"id_lte,omitempty"`
	IDGt                         *string                        `json:"id_gt,omitempty"`
	IDGte                        *string                        `json:"id_gte,omitempty"`
	IDContains                   *string                        `json:"id_contains,omitempty"`
	IDNotContains                *string                        `json:"id_not_contains,omitempty"`
	IDStartsWith                 *string                        `json:"id_starts_with,omitempty"`
	IDNotStartsWith              *string                        `json:"id_not_starts_with,omitempty"`
	IDEndsWith                   *string                        `json:"id_ends_with,omitempty"`
	IDNotEndsWith                *string                        `json:"id_not_ends_with,omitempty"`
	CreatedAt                    *string                        `json:"createdAt,omitempty"`
	CreatedAtNot                 *string                        `json:"createdAt_not,omitempty"`
	CreatedAtIn                  []string                       `json:"createdAt_in,omitempty"`
	CreatedAtNotIn               []string                       `json:"createdAt_not_in,omitempty"`
	CreatedAtLt                  *string                        `json:"createdAt_lt,omitempty"`
	CreatedAtLte                 *string                        `json:"createdAt_lte,omitempty"`
	CreatedAtGt                  *string                        `json:"createdAt_gt,omitempty"`
	CreatedAtGte                 *string                        `json:"createdAt_gte,omitempty"`
	UpdatedAt                    *string                        `json:"updatedAt,omitempty"`
	UpdatedAtNot                 *string                        `json:"updatedAt_not,omitempty"`
	UpdatedAtIn                  []string                       `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn               []string                       `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt                  *string                        `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte                 *string                        `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt                  *string                        `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte                 *string                        `json:"updatedAt_gte,omitempty"`
	ExternalId                   *string                        `json:"externalID,omitempty"`
	ExternalIdNot                *string                        `json:"externalID_not,omitempty"`
	ExternalIdIn                 []string                       `json:"externalID_in,omitempty"`
	ExternalIdNotIn              []string                       `json:"externalID_not_in,omitempty"`
	ExternalIdLt                 *string                        `json:"externalID_lt,omitempty"`
	ExternalIdLte                *string                        `json:"externalID_lte,omitempty"`
	ExternalIdGt                 *string                        `json:"externalID_gt,omitempty"`
	ExternalIdGte                *string                        `json:"externalID_gte,omitempty"`
	ExternalIdContains           *string                        `json:"externalID_contains,omitempty"`
	ExternalIdNotContains        *string                        `json:"externalID_not_contains,omitempty"`
	ExternalIdStartsWith         *string                        `json:"externalID_starts_with,omitempty"`
	ExternalIdNotStartsWith      *string                        `json:"externalID_not_starts_with,omitempty"`
	ExternalIdEndsWith           *string                        `json:"externalID_ends_with,omitempty"`
	ExternalIdNotEndsWith        *string                        `json:"externalID_not_ends_with,omitempty"`
	ProductId                    *string                        `json:"productID,omitempty"`
	ProductIdNot                 *string                        `json:"productID_not,omitempty"`
	ProductIdIn                  []string                       `json:"productID_in,omitempty"`
	ProductIdNotIn               []string                       `json:"productID_not_in,omitempty"`
	ProductIdLt                  *string                        `json:"productID_lt,omitempty"`
	ProductIdLte                 *string                        `json:"productID_lte,omitempty"`
	ProductIdGt                  *string                        `json:"productID_gt,omitempty"`
	ProductIdGte                 *string                        `json:"productID_gte,omitempty"`
	ProductIdContains            *string                        `json:"productID_contains,omitempty"`
	ProductIdNotContains         *string                        `json:"productID_not_contains,omitempty"`
	ProductIdStartsWith          *string                        `json:"productID_starts_with,omitempty"`
	ProductIdNotStartsWith       *string                        `json:"productID_not_starts_with,omitempty"`
	ProductIdEndsWith            *string                        `json:"productID_ends_with,omitempty"`
	ProductIdNotEndsWith         *string                        `json:"productID_not_ends_with,omitempty"`
	Product                      *string                        `json:"product,omitempty"`
	ProductNot                   *string                        `json:"product_not,omitempty"`
	ProductIn                    []string                       `json:"product_in,omitempty"`
	ProductNotIn                 []string                       `json:"product_not_in,omitempty"`
	ProductLt                    *string                        `json:"product_lt,omitempty"`
	ProductLte                   *string                        `json:"product_lte,omitempty"`
	ProductGt                    *string                        `json:"product_gt,omitempty"`
	ProductGte                   *string                        `json:"product_gte,omitempty"`
	ProductContains              *string                        `json:"product_contains,omitempty"`
	ProductNotContains           *string                        `json:"product_not_contains,omitempty"`
	ProductStartsWith            *string                        `json:"product_starts_with,omitempty"`
	ProductNotStartsWith         *string                        `json:"product_not_starts_with,omitempty"`
	ProductEndsWith              *string                        `json:"product_ends_with,omitempty"`
	ProductNotEndsWith           *string                        `json:"product_not_ends_with,omitempty"`
	GatewayResponse              *string                        `json:"gatewayResponse,omitempty"`
	GatewayResponseNot           *string                        `json:"gatewayResponse_not,omitempty"`
	GatewayResponseIn            []string                       `json:"gatewayResponse_in,omitempty"`
	GatewayResponseNotIn         []string                       `json:"gatewayResponse_not_in,omitempty"`
	GatewayResponseLt            *string                        `json:"gatewayResponse_lt,omitempty"`
	GatewayResponseLte           *string                        `json:"gatewayResponse_lte,omitempty"`
	GatewayResponseGt            *string                        `json:"gatewayResponse_gt,omitempty"`
	GatewayResponseGte           *string                        `json:"gatewayResponse_gte,omitempty"`
	GatewayResponseContains      *string                        `json:"gatewayResponse_contains,omitempty"`
	GatewayResponseNotContains   *string                        `json:"gatewayResponse_not_contains,omitempty"`
	GatewayResponseStartsWith    *string                        `json:"gatewayResponse_starts_with,omitempty"`
	GatewayResponseNotStartsWith *string                        `json:"gatewayResponse_not_starts_with,omitempty"`
	GatewayResponseEndsWith      *string                        `json:"gatewayResponse_ends_with,omitempty"`
	GatewayResponseNotEndsWith   *string                        `json:"gatewayResponse_not_ends_with,omitempty"`
	Amount                       *int32                         `json:"amount,omitempty"`
	AmountNot                    *int32                         `json:"amount_not,omitempty"`
	AmountIn                     []int32                        `json:"amount_in,omitempty"`
	AmountNotIn                  []int32                        `json:"amount_not_in,omitempty"`
	AmountLt                     *int32                         `json:"amount_lt,omitempty"`
	AmountLte                    *int32                         `json:"amount_lte,omitempty"`
	AmountGt                     *int32                         `json:"amount_gt,omitempty"`
	AmountGte                    *int32                         `json:"amount_gte,omitempty"`
	DiscountId                   *string                        `json:"discountID,omitempty"`
	DiscountIdNot                *string                        `json:"discountID_not,omitempty"`
	DiscountIdIn                 []string                       `json:"discountID_in,omitempty"`
	DiscountIdNotIn              []string                       `json:"discountID_not_in,omitempty"`
	DiscountIdLt                 *string                        `json:"discountID_lt,omitempty"`
	DiscountIdLte                *string                        `json:"discountID_lte,omitempty"`
	DiscountIdGt                 *string                        `json:"discountID_gt,omitempty"`
	DiscountIdGte                *string                        `json:"discountID_gte,omitempty"`
	DiscountIdContains           *string                        `json:"discountID_contains,omitempty"`
	DiscountIdNotContains        *string                        `json:"discountID_not_contains,omitempty"`
	DiscountIdStartsWith         *string                        `json:"discountID_starts_with,omitempty"`
	DiscountIdNotStartsWith      *string                        `json:"discountID_not_starts_with,omitempty"`
	DiscountIdEndsWith           *string                        `json:"discountID_ends_with,omitempty"`
	DiscountIdNotEndsWith        *string                        `json:"discountID_not_ends_with,omitempty"`
	Discount                     *int32                         `json:"discount,omitempty"`
	DiscountNot                  *int32                         `json:"discount_not,omitempty"`
	DiscountIn                   []int32                        `json:"discount_in,omitempty"`
	DiscountNotIn                []int32                        `json:"discount_not_in,omitempty"`
	DiscountLt                   *int32                         `json:"discount_lt,omitempty"`
	DiscountLte                  *int32                         `json:"discount_lte,omitempty"`
	DiscountGt                   *int32                         `json:"discount_gt,omitempty"`
	DiscountGte                  *int32                         `json:"discount_gte,omitempty"`
	And                          []PaymentEntryScalarWhereInput `json:"AND,omitempty"`
	Or                           []PaymentEntryScalarWhereInput `json:"OR,omitempty"`
	Not                          []PaymentEntryScalarWhereInput `json:"NOT,omitempty"`
}

type PaymentEntryUpsertWithWhereUniqueWithoutWithCardInput struct {
	Where  PaymentEntryWhereUniqueInput               `json:"where"`
	Update PaymentEntryUpdateWithoutWithCardDataInput `json:"update"`
	Create PaymentEntryCreateWithoutWithCardInput     `json:"create"`
}

type CreditCardWhereInput struct {
	ID                      *string                 `json:"id,omitempty"`
	IDNot                   *string                 `json:"id_not,omitempty"`
	IDIn                    []string                `json:"id_in,omitempty"`
	IDNotIn                 []string                `json:"id_not_in,omitempty"`
	IDLt                    *string                 `json:"id_lt,omitempty"`
	IDLte                   *string                 `json:"id_lte,omitempty"`
	IDGt                    *string                 `json:"id_gt,omitempty"`
	IDGte                   *string                 `json:"id_gte,omitempty"`
	IDContains              *string                 `json:"id_contains,omitempty"`
	IDNotContains           *string                 `json:"id_not_contains,omitempty"`
	IDStartsWith            *string                 `json:"id_starts_with,omitempty"`
	IDNotStartsWith         *string                 `json:"id_not_starts_with,omitempty"`
	IDEndsWith              *string                 `json:"id_ends_with,omitempty"`
	IDNotEndsWith           *string                 `json:"id_not_ends_with,omitempty"`
	CreatedAt               *string                 `json:"createdAt,omitempty"`
	CreatedAtNot            *string                 `json:"createdAt_not,omitempty"`
	CreatedAtIn             []string                `json:"createdAt_in,omitempty"`
	CreatedAtNotIn          []string                `json:"createdAt_not_in,omitempty"`
	CreatedAtLt             *string                 `json:"createdAt_lt,omitempty"`
	CreatedAtLte            *string                 `json:"createdAt_lte,omitempty"`
	CreatedAtGt             *string                 `json:"createdAt_gt,omitempty"`
	CreatedAtGte            *string                 `json:"createdAt_gte,omitempty"`
	UpdatedAt               *string                 `json:"updatedAt,omitempty"`
	UpdatedAtNot            *string                 `json:"updatedAt_not,omitempty"`
	UpdatedAtIn             []string                `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn          []string                `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt             *string                 `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte            *string                 `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt             *string                 `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte            *string                 `json:"updatedAt_gte,omitempty"`
	Owner                   *TravelerWhereInput     `json:"owner,omitempty"`
	CardNumber              *string                 `json:"cardNumber,omitempty"`
	CardNumberNot           *string                 `json:"cardNumber_not,omitempty"`
	CardNumberIn            []string                `json:"cardNumber_in,omitempty"`
	CardNumberNotIn         []string                `json:"cardNumber_not_in,omitempty"`
	CardNumberLt            *string                 `json:"cardNumber_lt,omitempty"`
	CardNumberLte           *string                 `json:"cardNumber_lte,omitempty"`
	CardNumberGt            *string                 `json:"cardNumber_gt,omitempty"`
	CardNumberGte           *string                 `json:"cardNumber_gte,omitempty"`
	CardNumberContains      *string                 `json:"cardNumber_contains,omitempty"`
	CardNumberNotContains   *string                 `json:"cardNumber_not_contains,omitempty"`
	CardNumberStartsWith    *string                 `json:"cardNumber_starts_with,omitempty"`
	CardNumberNotStartsWith *string                 `json:"cardNumber_not_starts_with,omitempty"`
	CardNumberEndsWith      *string                 `json:"cardNumber_ends_with,omitempty"`
	CardNumberNotEndsWith   *string                 `json:"cardNumber_not_ends_with,omitempty"`
	CardToken               *string                 `json:"cardToken,omitempty"`
	CardTokenNot            *string                 `json:"cardToken_not,omitempty"`
	CardTokenIn             []string                `json:"cardToken_in,omitempty"`
	CardTokenNotIn          []string                `json:"cardToken_not_in,omitempty"`
	CardTokenLt             *string                 `json:"cardToken_lt,omitempty"`
	CardTokenLte            *string                 `json:"cardToken_lte,omitempty"`
	CardTokenGt             *string                 `json:"cardToken_gt,omitempty"`
	CardTokenGte            *string                 `json:"cardToken_gte,omitempty"`
	CardTokenContains       *string                 `json:"cardToken_contains,omitempty"`
	CardTokenNotContains    *string                 `json:"cardToken_not_contains,omitempty"`
	CardTokenStartsWith     *string                 `json:"cardToken_starts_with,omitempty"`
	CardTokenNotStartsWith  *string                 `json:"cardToken_not_starts_with,omitempty"`
	CardTokenEndsWith       *string                 `json:"cardToken_ends_with,omitempty"`
	CardTokenNotEndsWith    *string                 `json:"cardToken_not_ends_with,omitempty"`
	Type                    *CreditCardType         `json:"type,omitempty"`
	TypeNot                 *CreditCardType         `json:"type_not,omitempty"`
	TypeIn                  []CreditCardType        `json:"type_in,omitempty"`
	TypeNotIn               []CreditCardType        `json:"type_not_in,omitempty"`
	LastUsed                *string                 `json:"lastUsed,omitempty"`
	LastUsedNot             *string                 `json:"lastUsed_not,omitempty"`
	LastUsedIn              []string                `json:"lastUsed_in,omitempty"`
	LastUsedNotIn           []string                `json:"lastUsed_not_in,omitempty"`
	LastUsedLt              *string                 `json:"lastUsed_lt,omitempty"`
	LastUsedLte             *string                 `json:"lastUsed_lte,omitempty"`
	LastUsedGt              *string                 `json:"lastUsed_gt,omitempty"`
	LastUsedGte             *string                 `json:"lastUsed_gte,omitempty"`
	UsesEvery               *PaymentEntryWhereInput `json:"uses_every,omitempty"`
	UsesSome                *PaymentEntryWhereInput `json:"uses_some,omitempty"`
	UsesNone                *PaymentEntryWhereInput `json:"uses_none,omitempty"`
	And                     []CreditCardWhereInput  `json:"AND,omitempty"`
	Or                      []CreditCardWhereInput  `json:"OR,omitempty"`
	Not                     []CreditCardWhereInput  `json:"NOT,omitempty"`
}

type PersonCreateInput struct {
	MId            *string                                           `json:"mID,omitempty"`
	Name           string                                            `json:"name"`
	Photo          *string                                           `json:"photo,omitempty"`
	Birthday       string                                            `json:"birthday"`
	From           *string                                           `json:"from,omitempty"`
	ChannelsPhone  *PhoneCreateManyInput                             `json:"channelsPhone,omitempty"`
	ChannelsEmail  *EmailCreateManyInput                             `json:"channelsEmail,omitempty"`
	IDentification IDentificationDocumentCreateOneWithoutPersonInput `json:"identification"`
	Tags           *PersonCreatetagsInput                            `json:"tags,omitempty"`
	Credentials    *CredentialCreateManyWithoutOwnerInput            `json:"credentials,omitempty"`
}

type AttractionUpdateOneRequiredWithoutOwnerInput struct {
	Create  *AttractionCreateWithoutOwnerInput     `json:"create,omitempty"`
	Update  *AttractionUpdateWithoutOwnerDataInput `json:"update,omitempty"`
	Upsert  *AttractionUpsertWithoutOwnerInput     `json:"upsert,omitempty"`
	Connect *AttractionWhereUniqueInput            `json:"connect,omitempty"`
}

type PhoneUpdateManyMutationInput struct {
	Type        *CommunicationType `json:"type,omitempty"`
	CountryCode *string            `json:"countryCode,omitempty"`
	Number      *string            `json:"number,omitempty"`
}

type TravelerPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance TravelerPreviousValuesExec) Exec(ctx context.Context) (*TravelerPreviousValues, error) {
	var v TravelerPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance TravelerPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type TravelerPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance TravelerPreviousValuesExecArray) Exec(ctx context.Context) ([]TravelerPreviousValues, error) {
	var v []TravelerPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type TravelerPreviousValues struct {
	ID        string `json:"id"`
	CreatedAt string `json:"createdAt"`
	UpdatedAt string `json:"updatedAt"`
	Username  string `json:"username"`
}

type CreditCardEdgeExec struct {
	exec *prisma.Exec
}

func (instance *CreditCardEdgeExec) Node() *CreditCardExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "CreditCard"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "cardNumber", "cardToken", "type", "lastUsed"})

	return &CreditCardExec{ret}
}

func (instance CreditCardEdgeExec) Exec(ctx context.Context) (*CreditCardEdge, error) {
	var v CreditCardEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance CreditCardEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type CreditCardEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance CreditCardEdgeExecArray) Exec(ctx context.Context) ([]CreditCardEdge, error) {
	var v []CreditCardEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type CreditCardEdge struct {
	Cursor string `json:"cursor"`
}

type PersonPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance PersonPreviousValuesExec) Exec(ctx context.Context) (*PersonPreviousValues, error) {
	var v PersonPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance PersonPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type PersonPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance PersonPreviousValuesExecArray) Exec(ctx context.Context) ([]PersonPreviousValues, error) {
	var v []PersonPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type PersonPreviousValues struct {
	ID        string   `json:"id"`
	CreatedAt string   `json:"createdAt"`
	UpdatedAt string   `json:"updatedAt"`
	MId       *string  `json:"mID,omitempty"`
	Name      string   `json:"name"`
	Photo     *string  `json:"photo,omitempty"`
	Birthday  string   `json:"birthday"`
	From      *string  `json:"from,omitempty"`
	Tags      []string `json:"tags,omitempty"`
}

type CreditCardConnectionExec struct {
	exec *prisma.Exec
}

func (instance *CreditCardConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *CreditCardConnectionExec) Edges() *CreditCardEdgeExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "CreditCardEdge"},
		"edges",
		[]string{"cursor"})

	return &CreditCardEdgeExec{ret}
}

func (instance *CreditCardConnectionExec) Aggregate(ctx context.Context) (Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateCreditCard"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return v, err
}

func (instance CreditCardConnectionExec) Exec(ctx context.Context) (*CreditCardConnection, error) {
	var v CreditCardConnection
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance CreditCardConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type CreditCardConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance CreditCardConnectionExecArray) Exec(ctx context.Context) ([]CreditCardConnection, error) {
	var v []CreditCardConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type CreditCardConnection struct {
}

type CredentialExec struct {
	exec *prisma.Exec
}

func (instance *CredentialExec) Owner() *PersonExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Person"},
		"owner",
		[]string{"id", "createdAt", "updatedAt", "mID", "name", "photo", "birthday", "from", "tags"})

	return &PersonExec{ret}
}

func (instance CredentialExec) Exec(ctx context.Context) (*Credential, error) {
	var v Credential
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance CredentialExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type CredentialExecArray struct {
	exec *prisma.Exec
}

func (instance CredentialExecArray) Exec(ctx context.Context) ([]Credential, error) {
	var v []Credential
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type Credential struct {
	ID             string         `json:"id"`
	CreatedAt      string         `json:"createdAt"`
	UpdatedAt      string         `json:"updatedAt"`
	DisplayName    *string        `json:"displayName,omitempty"`
	IsMain         bool           `json:"isMain"`
	Type           CredentialType `json:"type"`
	Validated      *bool          `json:"validated,omitempty"`
	ValidationId   *string        `json:"validationID,omitempty"`
	Value          string         `json:"value"`
	RawPassword    *string        `json:"rawPassword,omitempty"`
	HashedPassword string         `json:"hashedPassword"`
}

type PaymentEntryExec struct {
	exec *prisma.Exec
}

func (instance *PaymentEntryExec) WithCard() *CreditCardExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "CreditCard"},
		"withCard",
		[]string{"id", "createdAt", "updatedAt", "cardNumber", "cardToken", "type", "lastUsed"})

	return &CreditCardExec{ret}
}

func (instance PaymentEntryExec) Exec(ctx context.Context) (*PaymentEntry, error) {
	var v PaymentEntry
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance PaymentEntryExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type PaymentEntryExecArray struct {
	exec *prisma.Exec
}

func (instance PaymentEntryExecArray) Exec(ctx context.Context) ([]PaymentEntry, error) {
	var v []PaymentEntry
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type PaymentEntry struct {
	ID              string  `json:"id"`
	CreatedAt       string  `json:"createdAt"`
	UpdatedAt       string  `json:"updatedAt"`
	ExternalId      string  `json:"externalID"`
	ProductId       string  `json:"productID"`
	Product         string  `json:"product"`
	GatewayResponse *string `json:"gatewayResponse,omitempty"`
	Amount          int32   `json:"amount"`
	DiscountId      *string `json:"discountID,omitempty"`
	Discount        *int32  `json:"discount,omitempty"`
}

type TravelerSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *TravelerSubscriptionPayloadExec) Node() *TravelerExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Traveler"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "username"})

	return &TravelerExec{ret}
}

func (instance *TravelerSubscriptionPayloadExec) PreviousValues() *TravelerPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "TravelerPreviousValues"},
		"previousValues",
		[]string{"id", "createdAt", "updatedAt", "username"})

	return &TravelerPreviousValuesExec{ret}
}

func (instance TravelerSubscriptionPayloadExec) Exec(ctx context.Context) (*TravelerSubscriptionPayload, error) {
	var v TravelerSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance TravelerSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type TravelerSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance TravelerSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]TravelerSubscriptionPayload, error) {
	var v []TravelerSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type TravelerSubscriptionPayload struct {
	Mutation      MutationType `json:"mutation"`
	UpdatedFields []string     `json:"updatedFields,omitempty"`
}

type PhoneExec struct {
	exec *prisma.Exec
}

func (instance PhoneExec) Exec(ctx context.Context) (*Phone, error) {
	var v Phone
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance PhoneExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type PhoneExecArray struct {
	exec *prisma.Exec
}

func (instance PhoneExecArray) Exec(ctx context.Context) ([]Phone, error) {
	var v []Phone
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type Phone struct {
	Type        CommunicationType `json:"type"`
	CountryCode string            `json:"countryCode"`
	Number      *string           `json:"number,omitempty"`
}

type TravelerConnectionExec struct {
	exec *prisma.Exec
}

func (instance *TravelerConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *TravelerConnectionExec) Edges() *TravelerEdgeExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "TravelerEdge"},
		"edges",
		[]string{"cursor"})

	return &TravelerEdgeExec{ret}
}

func (instance *TravelerConnectionExec) Aggregate(ctx context.Context) (Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateTraveler"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return v, err
}

func (instance TravelerConnectionExec) Exec(ctx context.Context) (*TravelerConnection, error) {
	var v TravelerConnection
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance TravelerConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type TravelerConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance TravelerConnectionExecArray) Exec(ctx context.Context) ([]TravelerConnection, error) {
	var v []TravelerConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type TravelerConnection struct {
}

type TravelerExec struct {
	exec *prisma.Exec
}

func (instance *TravelerExec) Person() *PersonExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Person"},
		"person",
		[]string{"id", "createdAt", "updatedAt", "mID", "name", "photo", "birthday", "from", "tags"})

	return &PersonExec{ret}
}

type CardsParamsExec struct {
	Where   *CreditCardWhereInput
	OrderBy *CreditCardOrderByInput
	Skip    *int32
	After   *string
	Before  *string
	First   *int32
	Last    *int32
}

func (instance *TravelerExec) Cards(params *CardsParamsExec) *CreditCardExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := instance.exec.Client.GetMany(
		instance.exec,
		wparams,
		[3]string{"CreditCardWhereInput", "CreditCardOrderByInput", "CreditCard"},
		"cards",
		[]string{"id", "createdAt", "updatedAt", "cardNumber", "cardToken", "type", "lastUsed"})

	return &CreditCardExecArray{ret}
}

func (instance TravelerExec) Exec(ctx context.Context) (*Traveler, error) {
	var v Traveler
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance TravelerExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type TravelerExecArray struct {
	exec *prisma.Exec
}

func (instance TravelerExecArray) Exec(ctx context.Context) ([]Traveler, error) {
	var v []Traveler
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type Traveler struct {
	ID        string `json:"id"`
	CreatedAt string `json:"createdAt"`
	UpdatedAt string `json:"updatedAt"`
	Username  string `json:"username"`
}

type CreditCardExec struct {
	exec *prisma.Exec
}

func (instance *CreditCardExec) Owner() *TravelerExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Traveler"},
		"owner",
		[]string{"id", "createdAt", "updatedAt", "username"})

	return &TravelerExec{ret}
}

type UsesParamsExec struct {
	Where   *PaymentEntryWhereInput
	OrderBy *PaymentEntryOrderByInput
	Skip    *int32
	After   *string
	Before  *string
	First   *int32
	Last    *int32
}

func (instance *CreditCardExec) Uses(params *UsesParamsExec) *PaymentEntryExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := instance.exec.Client.GetMany(
		instance.exec,
		wparams,
		[3]string{"PaymentEntryWhereInput", "PaymentEntryOrderByInput", "PaymentEntry"},
		"uses",
		[]string{"id", "createdAt", "updatedAt", "externalID", "productID", "product", "gatewayResponse", "amount", "discountID", "discount"})

	return &PaymentEntryExecArray{ret}
}

func (instance CreditCardExec) Exec(ctx context.Context) (*CreditCard, error) {
	var v CreditCard
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance CreditCardExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type CreditCardExecArray struct {
	exec *prisma.Exec
}

func (instance CreditCardExecArray) Exec(ctx context.Context) ([]CreditCard, error) {
	var v []CreditCard
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type CreditCard struct {
	ID         string         `json:"id"`
	CreatedAt  string         `json:"createdAt"`
	UpdatedAt  string         `json:"updatedAt"`
	CardNumber string         `json:"cardNumber"`
	CardToken  string         `json:"cardToken"`
	Type       CreditCardType `json:"type"`
	LastUsed   *string        `json:"lastUsed,omitempty"`
}

type PhoneConnectionExec struct {
	exec *prisma.Exec
}

func (instance *PhoneConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *PhoneConnectionExec) Edges() *PhoneEdgeExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PhoneEdge"},
		"edges",
		[]string{"cursor"})

	return &PhoneEdgeExec{ret}
}

func (instance *PhoneConnectionExec) Aggregate(ctx context.Context) (Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregatePhone"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return v, err
}

func (instance PhoneConnectionExec) Exec(ctx context.Context) (*PhoneConnection, error) {
	var v PhoneConnection
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance PhoneConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type PhoneConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance PhoneConnectionExecArray) Exec(ctx context.Context) ([]PhoneConnection, error) {
	var v []PhoneConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type PhoneConnection struct {
}

type AttractionExec struct {
	exec *prisma.Exec
}

func (instance *AttractionExec) Owner() *PartnerExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Partner"},
		"owner",
		[]string{"id", "createdAt", "updatedAt"})

	return &PartnerExec{ret}
}

func (instance *AttractionExec) Location() *LocationExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Location"},
		"location",
		[]string{"longitude", "latitude"})

	return &LocationExec{ret}
}

type LikedByParamsExec struct {
	Where   *PersonWhereInput
	OrderBy *PersonOrderByInput
	Skip    *int32
	After   *string
	Before  *string
	First   *int32
	Last    *int32
}

func (instance *AttractionExec) LikedBy(params *LikedByParamsExec) *PersonExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := instance.exec.Client.GetMany(
		instance.exec,
		wparams,
		[3]string{"PersonWhereInput", "PersonOrderByInput", "Person"},
		"likedBy",
		[]string{"id", "createdAt", "updatedAt", "mID", "name", "photo", "birthday", "from", "tags"})

	return &PersonExecArray{ret}
}

func (instance AttractionExec) Exec(ctx context.Context) (*Attraction, error) {
	var v Attraction
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance AttractionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type AttractionExecArray struct {
	exec *prisma.Exec
}

func (instance AttractionExecArray) Exec(ctx context.Context) ([]Attraction, error) {
	var v []Attraction
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type Attraction struct {
	ID          string           `json:"id"`
	CreatedAt   string           `json:"createdAt"`
	UpdatedAt   string           `json:"updatedAt"`
	Name        string           `json:"name"`
	Description string           `json:"description"`
	Address     string           `json:"address"`
	Popularity  *int32           `json:"popularity,omitempty"`
	Types       []AttractionType `json:"types,omitempty"`
	Tags        []string         `json:"tags,omitempty"`
}

type PersonEdgeExec struct {
	exec *prisma.Exec
}

func (instance *PersonEdgeExec) Node() *PersonExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Person"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "mID", "name", "photo", "birthday", "from", "tags"})

	return &PersonExec{ret}
}

func (instance PersonEdgeExec) Exec(ctx context.Context) (*PersonEdge, error) {
	var v PersonEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance PersonEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type PersonEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance PersonEdgeExecArray) Exec(ctx context.Context) ([]PersonEdge, error) {
	var v []PersonEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type PersonEdge struct {
	Cursor string `json:"cursor"`
}

type AttractionSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *AttractionSubscriptionPayloadExec) Node() *AttractionExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Attraction"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "name", "description", "address", "popularity", "types", "tags"})

	return &AttractionExec{ret}
}

func (instance *AttractionSubscriptionPayloadExec) PreviousValues() *AttractionPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AttractionPreviousValues"},
		"previousValues",
		[]string{"id", "createdAt", "updatedAt", "name", "description", "address", "popularity", "types", "tags"})

	return &AttractionPreviousValuesExec{ret}
}

func (instance AttractionSubscriptionPayloadExec) Exec(ctx context.Context) (*AttractionSubscriptionPayload, error) {
	var v AttractionSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance AttractionSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type AttractionSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance AttractionSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]AttractionSubscriptionPayload, error) {
	var v []AttractionSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type AttractionSubscriptionPayload struct {
	Mutation      MutationType `json:"mutation"`
	UpdatedFields []string     `json:"updatedFields,omitempty"`
}

type AttractionPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance AttractionPreviousValuesExec) Exec(ctx context.Context) (*AttractionPreviousValues, error) {
	var v AttractionPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance AttractionPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type AttractionPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance AttractionPreviousValuesExecArray) Exec(ctx context.Context) ([]AttractionPreviousValues, error) {
	var v []AttractionPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type AttractionPreviousValues struct {
	ID          string           `json:"id"`
	CreatedAt   string           `json:"createdAt"`
	UpdatedAt   string           `json:"updatedAt"`
	Name        string           `json:"name"`
	Description string           `json:"description"`
	Address     string           `json:"address"`
	Popularity  *int32           `json:"popularity,omitempty"`
	Types       []AttractionType `json:"types,omitempty"`
	Tags        []string         `json:"tags,omitempty"`
}

type PaymentEntryConnectionExec struct {
	exec *prisma.Exec
}

func (instance *PaymentEntryConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *PaymentEntryConnectionExec) Edges() *PaymentEntryEdgeExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PaymentEntryEdge"},
		"edges",
		[]string{"cursor"})

	return &PaymentEntryEdgeExec{ret}
}

func (instance *PaymentEntryConnectionExec) Aggregate(ctx context.Context) (Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregatePaymentEntry"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return v, err
}

func (instance PaymentEntryConnectionExec) Exec(ctx context.Context) (*PaymentEntryConnection, error) {
	var v PaymentEntryConnection
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance PaymentEntryConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type PaymentEntryConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance PaymentEntryConnectionExecArray) Exec(ctx context.Context) ([]PaymentEntryConnection, error) {
	var v []PaymentEntryConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type PaymentEntryConnection struct {
}

type PartnerEdgeExec struct {
	exec *prisma.Exec
}

func (instance *PartnerEdgeExec) Node() *PartnerExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Partner"},
		"node",
		[]string{"id", "createdAt", "updatedAt"})

	return &PartnerExec{ret}
}

func (instance PartnerEdgeExec) Exec(ctx context.Context) (*PartnerEdge, error) {
	var v PartnerEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance PartnerEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type PartnerEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance PartnerEdgeExecArray) Exec(ctx context.Context) ([]PartnerEdge, error) {
	var v []PartnerEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type PartnerEdge struct {
	Cursor string `json:"cursor"`
}

type CredentialSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *CredentialSubscriptionPayloadExec) Node() *CredentialExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Credential"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "displayName", "isMain", "type", "validated", "validationID", "value", "rawPassword", "hashedPassword"})

	return &CredentialExec{ret}
}

func (instance *CredentialSubscriptionPayloadExec) PreviousValues() *CredentialPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "CredentialPreviousValues"},
		"previousValues",
		[]string{"id", "createdAt", "updatedAt", "displayName", "isMain", "type", "validated", "validationID", "value", "rawPassword", "hashedPassword"})

	return &CredentialPreviousValuesExec{ret}
}

func (instance CredentialSubscriptionPayloadExec) Exec(ctx context.Context) (*CredentialSubscriptionPayload, error) {
	var v CredentialSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance CredentialSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type CredentialSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance CredentialSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]CredentialSubscriptionPayload, error) {
	var v []CredentialSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type CredentialSubscriptionPayload struct {
	Mutation      MutationType `json:"mutation"`
	UpdatedFields []string     `json:"updatedFields,omitempty"`
}

type PartnerExec struct {
	exec *prisma.Exec
}

func (instance *PartnerExec) Person() *PersonExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Person"},
		"person",
		[]string{"id", "createdAt", "updatedAt", "mID", "name", "photo", "birthday", "from", "tags"})

	return &PersonExec{ret}
}

func (instance *PartnerExec) Attraction() *AttractionExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Attraction"},
		"attraction",
		[]string{"id", "createdAt", "updatedAt", "name", "description", "address", "popularity", "types", "tags"})

	return &AttractionExec{ret}
}

func (instance PartnerExec) Exec(ctx context.Context) (*Partner, error) {
	var v Partner
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance PartnerExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type PartnerExecArray struct {
	exec *prisma.Exec
}

func (instance PartnerExecArray) Exec(ctx context.Context) ([]Partner, error) {
	var v []Partner
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type Partner struct {
	ID        string `json:"id"`
	CreatedAt string `json:"createdAt"`
	UpdatedAt string `json:"updatedAt"`
}

type CredentialPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance CredentialPreviousValuesExec) Exec(ctx context.Context) (*CredentialPreviousValues, error) {
	var v CredentialPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance CredentialPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type CredentialPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance CredentialPreviousValuesExecArray) Exec(ctx context.Context) ([]CredentialPreviousValues, error) {
	var v []CredentialPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type CredentialPreviousValues struct {
	ID             string         `json:"id"`
	CreatedAt      string         `json:"createdAt"`
	UpdatedAt      string         `json:"updatedAt"`
	DisplayName    *string        `json:"displayName,omitempty"`
	IsMain         bool           `json:"isMain"`
	Type           CredentialType `json:"type"`
	Validated      *bool          `json:"validated,omitempty"`
	ValidationId   *string        `json:"validationID,omitempty"`
	Value          string         `json:"value"`
	RawPassword    *string        `json:"rawPassword,omitempty"`
	HashedPassword string         `json:"hashedPassword"`
}

type LocationEdgeExec struct {
	exec *prisma.Exec
}

func (instance *LocationEdgeExec) Node() *LocationExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Location"},
		"node",
		[]string{"longitude", "latitude"})

	return &LocationExec{ret}
}

func (instance LocationEdgeExec) Exec(ctx context.Context) (*LocationEdge, error) {
	var v LocationEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance LocationEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type LocationEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance LocationEdgeExecArray) Exec(ctx context.Context) ([]LocationEdge, error) {
	var v []LocationEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type LocationEdge struct {
	Cursor string `json:"cursor"`
}

type CredentialEdgeExec struct {
	exec *prisma.Exec
}

func (instance *CredentialEdgeExec) Node() *CredentialExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Credential"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "displayName", "isMain", "type", "validated", "validationID", "value", "rawPassword", "hashedPassword"})

	return &CredentialExec{ret}
}

func (instance CredentialEdgeExec) Exec(ctx context.Context) (*CredentialEdge, error) {
	var v CredentialEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance CredentialEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type CredentialEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance CredentialEdgeExecArray) Exec(ctx context.Context) ([]CredentialEdge, error) {
	var v []CredentialEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type CredentialEdge struct {
	Cursor string `json:"cursor"`
}

type PersonExec struct {
	exec *prisma.Exec
}

type ChannelsPhoneParamsExec struct {
	Where   *PhoneWhereInput
	OrderBy *PhoneOrderByInput
	Skip    *int32
	After   *string
	Before  *string
	First   *int32
	Last    *int32
}

func (instance *PersonExec) ChannelsPhone(params *ChannelsPhoneParamsExec) *PhoneExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := instance.exec.Client.GetMany(
		instance.exec,
		wparams,
		[3]string{"PhoneWhereInput", "PhoneOrderByInput", "Phone"},
		"channelsPhone",
		[]string{"type", "countryCode", "number"})

	return &PhoneExecArray{ret}
}

type ChannelsEmailParamsExec struct {
	Where   *EmailWhereInput
	OrderBy *EmailOrderByInput
	Skip    *int32
	After   *string
	Before  *string
	First   *int32
	Last    *int32
}

func (instance *PersonExec) ChannelsEmail(params *ChannelsEmailParamsExec) *EmailExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := instance.exec.Client.GetMany(
		instance.exec,
		wparams,
		[3]string{"EmailWhereInput", "EmailOrderByInput", "Email"},
		"channelsEmail",
		[]string{"type", "value", "extras"})

	return &EmailExecArray{ret}
}

func (instance *PersonExec) IDentification() *IDentificationDocumentExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "IdentificationDocument"},
		"identification",
		[]string{"id", "createdAt", "updatedAt", "type", "value"})

	return &IDentificationDocumentExec{ret}
}

type CredentialsParamsExec struct {
	Where   *CredentialWhereInput
	OrderBy *CredentialOrderByInput
	Skip    *int32
	After   *string
	Before  *string
	First   *int32
	Last    *int32
}

func (instance *PersonExec) Credentials(params *CredentialsParamsExec) *CredentialExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := instance.exec.Client.GetMany(
		instance.exec,
		wparams,
		[3]string{"CredentialWhereInput", "CredentialOrderByInput", "Credential"},
		"credentials",
		[]string{"id", "createdAt", "updatedAt", "displayName", "isMain", "type", "validated", "validationID", "value", "rawPassword", "hashedPassword"})

	return &CredentialExecArray{ret}
}

func (instance PersonExec) Exec(ctx context.Context) (*Person, error) {
	var v Person
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance PersonExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type PersonExecArray struct {
	exec *prisma.Exec
}

func (instance PersonExecArray) Exec(ctx context.Context) ([]Person, error) {
	var v []Person
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type Person struct {
	ID        string   `json:"id"`
	CreatedAt string   `json:"createdAt"`
	UpdatedAt string   `json:"updatedAt"`
	MId       *string  `json:"mID,omitempty"`
	Name      string   `json:"name"`
	Photo     *string  `json:"photo,omitempty"`
	Birthday  string   `json:"birthday"`
	From      *string  `json:"from,omitempty"`
	Tags      []string `json:"tags,omitempty"`
}

type CreditCardSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *CreditCardSubscriptionPayloadExec) Node() *CreditCardExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "CreditCard"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "cardNumber", "cardToken", "type", "lastUsed"})

	return &CreditCardExec{ret}
}

func (instance *CreditCardSubscriptionPayloadExec) PreviousValues() *CreditCardPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "CreditCardPreviousValues"},
		"previousValues",
		[]string{"id", "createdAt", "updatedAt", "cardNumber", "cardToken", "type", "lastUsed"})

	return &CreditCardPreviousValuesExec{ret}
}

func (instance CreditCardSubscriptionPayloadExec) Exec(ctx context.Context) (*CreditCardSubscriptionPayload, error) {
	var v CreditCardSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance CreditCardSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type CreditCardSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance CreditCardSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]CreditCardSubscriptionPayload, error) {
	var v []CreditCardSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type CreditCardSubscriptionPayload struct {
	Mutation      MutationType `json:"mutation"`
	UpdatedFields []string     `json:"updatedFields,omitempty"`
}

type IDentificationDocumentEdgeExec struct {
	exec *prisma.Exec
}

func (instance *IDentificationDocumentEdgeExec) Node() *IDentificationDocumentExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "IdentificationDocument"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "type", "value"})

	return &IDentificationDocumentExec{ret}
}

func (instance IDentificationDocumentEdgeExec) Exec(ctx context.Context) (*IDentificationDocumentEdge, error) {
	var v IDentificationDocumentEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance IDentificationDocumentEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type IDentificationDocumentEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance IDentificationDocumentEdgeExecArray) Exec(ctx context.Context) ([]IDentificationDocumentEdge, error) {
	var v []IDentificationDocumentEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type IDentificationDocumentEdge struct {
	Cursor string `json:"cursor"`
}

type CreditCardPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance CreditCardPreviousValuesExec) Exec(ctx context.Context) (*CreditCardPreviousValues, error) {
	var v CreditCardPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance CreditCardPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type CreditCardPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance CreditCardPreviousValuesExecArray) Exec(ctx context.Context) ([]CreditCardPreviousValues, error) {
	var v []CreditCardPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type CreditCardPreviousValues struct {
	ID         string         `json:"id"`
	CreatedAt  string         `json:"createdAt"`
	UpdatedAt  string         `json:"updatedAt"`
	CardNumber string         `json:"cardNumber"`
	CardToken  string         `json:"cardToken"`
	Type       CreditCardType `json:"type"`
	LastUsed   *string        `json:"lastUsed,omitempty"`
}

type IDentificationDocumentExec struct {
	exec *prisma.Exec
}

func (instance *IDentificationDocumentExec) Person() *PersonExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Person"},
		"person",
		[]string{"id", "createdAt", "updatedAt", "mID", "name", "photo", "birthday", "from", "tags"})

	return &PersonExec{ret}
}

func (instance IDentificationDocumentExec) Exec(ctx context.Context) (*IDentificationDocument, error) {
	var v IDentificationDocument
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance IDentificationDocumentExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type IDentificationDocumentExecArray struct {
	exec *prisma.Exec
}

func (instance IDentificationDocumentExecArray) Exec(ctx context.Context) ([]IDentificationDocument, error) {
	var v []IDentificationDocument
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type IDentificationDocument struct {
	ID        string             `json:"id"`
	CreatedAt string             `json:"createdAt"`
	UpdatedAt string             `json:"updatedAt"`
	Type      IDentificationType `json:"type"`
	Value     string             `json:"value"`
}

type CredentialConnectionExec struct {
	exec *prisma.Exec
}

func (instance *CredentialConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *CredentialConnectionExec) Edges() *CredentialEdgeExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "CredentialEdge"},
		"edges",
		[]string{"cursor"})

	return &CredentialEdgeExec{ret}
}

func (instance *CredentialConnectionExec) Aggregate(ctx context.Context) (Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateCredential"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return v, err
}

func (instance CredentialConnectionExec) Exec(ctx context.Context) (*CredentialConnection, error) {
	var v CredentialConnection
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance CredentialConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type CredentialConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance CredentialConnectionExecArray) Exec(ctx context.Context) ([]CredentialConnection, error) {
	var v []CredentialConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type CredentialConnection struct {
}

type EmailEdgeExec struct {
	exec *prisma.Exec
}

func (instance *EmailEdgeExec) Node() *EmailExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Email"},
		"node",
		[]string{"type", "value", "extras"})

	return &EmailExec{ret}
}

func (instance EmailEdgeExec) Exec(ctx context.Context) (*EmailEdge, error) {
	var v EmailEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance EmailEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type EmailEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance EmailEdgeExecArray) Exec(ctx context.Context) ([]EmailEdge, error) {
	var v []EmailEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type EmailEdge struct {
	Cursor string `json:"cursor"`
}

type EmailSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *EmailSubscriptionPayloadExec) Node() *EmailExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Email"},
		"node",
		[]string{"type", "value", "extras"})

	return &EmailExec{ret}
}

func (instance *EmailSubscriptionPayloadExec) PreviousValues() *EmailPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "EmailPreviousValues"},
		"previousValues",
		[]string{"type", "value", "extras"})

	return &EmailPreviousValuesExec{ret}
}

func (instance EmailSubscriptionPayloadExec) Exec(ctx context.Context) (*EmailSubscriptionPayload, error) {
	var v EmailSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance EmailSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type EmailSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance EmailSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]EmailSubscriptionPayload, error) {
	var v []EmailSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type EmailSubscriptionPayload struct {
	Mutation      MutationType `json:"mutation"`
	UpdatedFields []string     `json:"updatedFields,omitempty"`
}

type EmailPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance EmailPreviousValuesExec) Exec(ctx context.Context) (*EmailPreviousValues, error) {
	var v EmailPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance EmailPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type EmailPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance EmailPreviousValuesExecArray) Exec(ctx context.Context) ([]EmailPreviousValues, error) {
	var v []EmailPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type EmailPreviousValues struct {
	Type   CommunicationType `json:"type"`
	Value  string            `json:"value"`
	Extras []string          `json:"extras,omitempty"`
}

type PhonePreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance PhonePreviousValuesExec) Exec(ctx context.Context) (*PhonePreviousValues, error) {
	var v PhonePreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance PhonePreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type PhonePreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance PhonePreviousValuesExecArray) Exec(ctx context.Context) ([]PhonePreviousValues, error) {
	var v []PhonePreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type PhonePreviousValues struct {
	Type        CommunicationType `json:"type"`
	CountryCode string            `json:"countryCode"`
	Number      *string           `json:"number,omitempty"`
}

type PhoneSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *PhoneSubscriptionPayloadExec) Node() *PhoneExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Phone"},
		"node",
		[]string{"type", "countryCode", "number"})

	return &PhoneExec{ret}
}

func (instance *PhoneSubscriptionPayloadExec) PreviousValues() *PhonePreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PhonePreviousValues"},
		"previousValues",
		[]string{"type", "countryCode", "number"})

	return &PhonePreviousValuesExec{ret}
}

func (instance PhoneSubscriptionPayloadExec) Exec(ctx context.Context) (*PhoneSubscriptionPayload, error) {
	var v PhoneSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance PhoneSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type PhoneSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance PhoneSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]PhoneSubscriptionPayload, error) {
	var v []PhoneSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type PhoneSubscriptionPayload struct {
	Mutation      MutationType `json:"mutation"`
	UpdatedFields []string     `json:"updatedFields,omitempty"`
}

type IDentificationDocumentSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *IDentificationDocumentSubscriptionPayloadExec) Node() *IDentificationDocumentExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "IdentificationDocument"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "type", "value"})

	return &IDentificationDocumentExec{ret}
}

func (instance *IDentificationDocumentSubscriptionPayloadExec) PreviousValues() *IDentificationDocumentPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "IdentificationDocumentPreviousValues"},
		"previousValues",
		[]string{"id", "createdAt", "updatedAt", "type", "value"})

	return &IDentificationDocumentPreviousValuesExec{ret}
}

func (instance IDentificationDocumentSubscriptionPayloadExec) Exec(ctx context.Context) (*IDentificationDocumentSubscriptionPayload, error) {
	var v IDentificationDocumentSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance IDentificationDocumentSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type IDentificationDocumentSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance IDentificationDocumentSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]IDentificationDocumentSubscriptionPayload, error) {
	var v []IDentificationDocumentSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type IDentificationDocumentSubscriptionPayload struct {
	Mutation      MutationType `json:"mutation"`
	UpdatedFields []string     `json:"updatedFields,omitempty"`
}

type IDentificationDocumentPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance IDentificationDocumentPreviousValuesExec) Exec(ctx context.Context) (*IDentificationDocumentPreviousValues, error) {
	var v IDentificationDocumentPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance IDentificationDocumentPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type IDentificationDocumentPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance IDentificationDocumentPreviousValuesExecArray) Exec(ctx context.Context) ([]IDentificationDocumentPreviousValues, error) {
	var v []IDentificationDocumentPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type IDentificationDocumentPreviousValues struct {
	ID        string             `json:"id"`
	CreatedAt string             `json:"createdAt"`
	UpdatedAt string             `json:"updatedAt"`
	Type      IDentificationType `json:"type"`
	Value     string             `json:"value"`
}

type PaymentEntryEdgeExec struct {
	exec *prisma.Exec
}

func (instance *PaymentEntryEdgeExec) Node() *PaymentEntryExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PaymentEntry"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "externalID", "productID", "product", "gatewayResponse", "amount", "discountID", "discount"})

	return &PaymentEntryExec{ret}
}

func (instance PaymentEntryEdgeExec) Exec(ctx context.Context) (*PaymentEntryEdge, error) {
	var v PaymentEntryEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance PaymentEntryEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type PaymentEntryEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance PaymentEntryEdgeExecArray) Exec(ctx context.Context) ([]PaymentEntryEdge, error) {
	var v []PaymentEntryEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type PaymentEntryEdge struct {
	Cursor string `json:"cursor"`
}

type AttractionEdgeExec struct {
	exec *prisma.Exec
}

func (instance *AttractionEdgeExec) Node() *AttractionExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Attraction"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "name", "description", "address", "popularity", "types", "tags"})

	return &AttractionExec{ret}
}

func (instance AttractionEdgeExec) Exec(ctx context.Context) (*AttractionEdge, error) {
	var v AttractionEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance AttractionEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type AttractionEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance AttractionEdgeExecArray) Exec(ctx context.Context) ([]AttractionEdge, error) {
	var v []AttractionEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type AttractionEdge struct {
	Cursor string `json:"cursor"`
}

type PartnerConnectionExec struct {
	exec *prisma.Exec
}

func (instance *PartnerConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *PartnerConnectionExec) Edges() *PartnerEdgeExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PartnerEdge"},
		"edges",
		[]string{"cursor"})

	return &PartnerEdgeExec{ret}
}

func (instance *PartnerConnectionExec) Aggregate(ctx context.Context) (Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregatePartner"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return v, err
}

func (instance PartnerConnectionExec) Exec(ctx context.Context) (*PartnerConnection, error) {
	var v PartnerConnection
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance PartnerConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type PartnerConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance PartnerConnectionExecArray) Exec(ctx context.Context) ([]PartnerConnection, error) {
	var v []PartnerConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type PartnerConnection struct {
}

type LocationSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *LocationSubscriptionPayloadExec) Node() *LocationExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Location"},
		"node",
		[]string{"longitude", "latitude"})

	return &LocationExec{ret}
}

func (instance *LocationSubscriptionPayloadExec) PreviousValues() *LocationPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "LocationPreviousValues"},
		"previousValues",
		[]string{"longitude", "latitude"})

	return &LocationPreviousValuesExec{ret}
}

func (instance LocationSubscriptionPayloadExec) Exec(ctx context.Context) (*LocationSubscriptionPayload, error) {
	var v LocationSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance LocationSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type LocationSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance LocationSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]LocationSubscriptionPayload, error) {
	var v []LocationSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type LocationSubscriptionPayload struct {
	Mutation      MutationType `json:"mutation"`
	UpdatedFields []string     `json:"updatedFields,omitempty"`
}

type LocationConnectionExec struct {
	exec *prisma.Exec
}

func (instance *LocationConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *LocationConnectionExec) Edges() *LocationEdgeExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "LocationEdge"},
		"edges",
		[]string{"cursor"})

	return &LocationEdgeExec{ret}
}

func (instance *LocationConnectionExec) Aggregate(ctx context.Context) (Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateLocation"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return v, err
}

func (instance LocationConnectionExec) Exec(ctx context.Context) (*LocationConnection, error) {
	var v LocationConnection
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance LocationConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type LocationConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance LocationConnectionExecArray) Exec(ctx context.Context) ([]LocationConnection, error) {
	var v []LocationConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type LocationConnection struct {
}

type LocationPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance LocationPreviousValuesExec) Exec(ctx context.Context) (*LocationPreviousValues, error) {
	var v LocationPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance LocationPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type LocationPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance LocationPreviousValuesExecArray) Exec(ctx context.Context) ([]LocationPreviousValues, error) {
	var v []LocationPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type LocationPreviousValues struct {
	Longitude float64 `json:"longitude"`
	Latitude  float64 `json:"latitude"`
}

type IDentificationDocumentConnectionExec struct {
	exec *prisma.Exec
}

func (instance *IDentificationDocumentConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *IDentificationDocumentConnectionExec) Edges() *IDentificationDocumentEdgeExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "IdentificationDocumentEdge"},
		"edges",
		[]string{"cursor"})

	return &IDentificationDocumentEdgeExec{ret}
}

func (instance *IDentificationDocumentConnectionExec) Aggregate(ctx context.Context) (Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateIdentificationDocument"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return v, err
}

func (instance IDentificationDocumentConnectionExec) Exec(ctx context.Context) (*IDentificationDocumentConnection, error) {
	var v IDentificationDocumentConnection
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance IDentificationDocumentConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type IDentificationDocumentConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance IDentificationDocumentConnectionExecArray) Exec(ctx context.Context) ([]IDentificationDocumentConnection, error) {
	var v []IDentificationDocumentConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type IDentificationDocumentConnection struct {
}

type PageInfoExec struct {
	exec *prisma.Exec
}

func (instance PageInfoExec) Exec(ctx context.Context) (*PageInfo, error) {
	var v PageInfo
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance PageInfoExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type PageInfoExecArray struct {
	exec *prisma.Exec
}

func (instance PageInfoExecArray) Exec(ctx context.Context) ([]PageInfo, error) {
	var v []PageInfo
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type PageInfo struct {
	HasNextPage     bool    `json:"hasNextPage"`
	HasPreviousPage bool    `json:"hasPreviousPage"`
	StartCursor     *string `json:"startCursor,omitempty"`
	EndCursor       *string `json:"endCursor,omitempty"`
}

type EmailConnectionExec struct {
	exec *prisma.Exec
}

func (instance *EmailConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *EmailConnectionExec) Edges() *EmailEdgeExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "EmailEdge"},
		"edges",
		[]string{"cursor"})

	return &EmailEdgeExec{ret}
}

func (instance *EmailConnectionExec) Aggregate(ctx context.Context) (Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateEmail"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return v, err
}

func (instance EmailConnectionExec) Exec(ctx context.Context) (*EmailConnection, error) {
	var v EmailConnection
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance EmailConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type EmailConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance EmailConnectionExecArray) Exec(ctx context.Context) ([]EmailConnection, error) {
	var v []EmailConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type EmailConnection struct {
}

type PartnerSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *PartnerSubscriptionPayloadExec) Node() *PartnerExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Partner"},
		"node",
		[]string{"id", "createdAt", "updatedAt"})

	return &PartnerExec{ret}
}

func (instance *PartnerSubscriptionPayloadExec) PreviousValues() *PartnerPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PartnerPreviousValues"},
		"previousValues",
		[]string{"id", "createdAt", "updatedAt"})

	return &PartnerPreviousValuesExec{ret}
}

func (instance PartnerSubscriptionPayloadExec) Exec(ctx context.Context) (*PartnerSubscriptionPayload, error) {
	var v PartnerSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance PartnerSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type PartnerSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance PartnerSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]PartnerSubscriptionPayload, error) {
	var v []PartnerSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type PartnerSubscriptionPayload struct {
	Mutation      MutationType `json:"mutation"`
	UpdatedFields []string     `json:"updatedFields,omitempty"`
}

type TravelerEdgeExec struct {
	exec *prisma.Exec
}

func (instance *TravelerEdgeExec) Node() *TravelerExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Traveler"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "username"})

	return &TravelerExec{ret}
}

func (instance TravelerEdgeExec) Exec(ctx context.Context) (*TravelerEdge, error) {
	var v TravelerEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance TravelerEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type TravelerEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance TravelerEdgeExecArray) Exec(ctx context.Context) ([]TravelerEdge, error) {
	var v []TravelerEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type TravelerEdge struct {
	Cursor string `json:"cursor"`
}

type PartnerPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance PartnerPreviousValuesExec) Exec(ctx context.Context) (*PartnerPreviousValues, error) {
	var v PartnerPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance PartnerPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type PartnerPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance PartnerPreviousValuesExecArray) Exec(ctx context.Context) ([]PartnerPreviousValues, error) {
	var v []PartnerPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type PartnerPreviousValues struct {
	ID        string `json:"id"`
	CreatedAt string `json:"createdAt"`
	UpdatedAt string `json:"updatedAt"`
}

type PersonConnectionExec struct {
	exec *prisma.Exec
}

func (instance *PersonConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *PersonConnectionExec) Edges() *PersonEdgeExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PersonEdge"},
		"edges",
		[]string{"cursor"})

	return &PersonEdgeExec{ret}
}

func (instance *PersonConnectionExec) Aggregate(ctx context.Context) (Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregatePerson"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return v, err
}

func (instance PersonConnectionExec) Exec(ctx context.Context) (*PersonConnection, error) {
	var v PersonConnection
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance PersonConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type PersonConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance PersonConnectionExecArray) Exec(ctx context.Context) ([]PersonConnection, error) {
	var v []PersonConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type PersonConnection struct {
}

type AttractionConnectionExec struct {
	exec *prisma.Exec
}

func (instance *AttractionConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *AttractionConnectionExec) Edges() *AttractionEdgeExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AttractionEdge"},
		"edges",
		[]string{"cursor"})

	return &AttractionEdgeExec{ret}
}

func (instance *AttractionConnectionExec) Aggregate(ctx context.Context) (Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateAttraction"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return v, err
}

func (instance AttractionConnectionExec) Exec(ctx context.Context) (*AttractionConnection, error) {
	var v AttractionConnection
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance AttractionConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type AttractionConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance AttractionConnectionExecArray) Exec(ctx context.Context) ([]AttractionConnection, error) {
	var v []AttractionConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type AttractionConnection struct {
}

type PersonSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *PersonSubscriptionPayloadExec) Node() *PersonExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Person"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "mID", "name", "photo", "birthday", "from", "tags"})

	return &PersonExec{ret}
}

func (instance *PersonSubscriptionPayloadExec) PreviousValues() *PersonPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PersonPreviousValues"},
		"previousValues",
		[]string{"id", "createdAt", "updatedAt", "mID", "name", "photo", "birthday", "from", "tags"})

	return &PersonPreviousValuesExec{ret}
}

func (instance PersonSubscriptionPayloadExec) Exec(ctx context.Context) (*PersonSubscriptionPayload, error) {
	var v PersonSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance PersonSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type PersonSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance PersonSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]PersonSubscriptionPayload, error) {
	var v []PersonSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type PersonSubscriptionPayload struct {
	Mutation      MutationType `json:"mutation"`
	UpdatedFields []string     `json:"updatedFields,omitempty"`
}

type EmailExec struct {
	exec *prisma.Exec
}

func (instance EmailExec) Exec(ctx context.Context) (*Email, error) {
	var v Email
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance EmailExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type EmailExecArray struct {
	exec *prisma.Exec
}

func (instance EmailExecArray) Exec(ctx context.Context) ([]Email, error) {
	var v []Email
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type Email struct {
	Type   CommunicationType `json:"type"`
	Value  string            `json:"value"`
	Extras []string          `json:"extras,omitempty"`
}

type PaymentEntryPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance PaymentEntryPreviousValuesExec) Exec(ctx context.Context) (*PaymentEntryPreviousValues, error) {
	var v PaymentEntryPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance PaymentEntryPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type PaymentEntryPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance PaymentEntryPreviousValuesExecArray) Exec(ctx context.Context) ([]PaymentEntryPreviousValues, error) {
	var v []PaymentEntryPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type PaymentEntryPreviousValues struct {
	ID              string  `json:"id"`
	CreatedAt       string  `json:"createdAt"`
	UpdatedAt       string  `json:"updatedAt"`
	ExternalId      string  `json:"externalID"`
	ProductId       string  `json:"productID"`
	Product         string  `json:"product"`
	GatewayResponse *string `json:"gatewayResponse,omitempty"`
	Amount          int32   `json:"amount"`
	DiscountId      *string `json:"discountID,omitempty"`
	Discount        *int32  `json:"discount,omitempty"`
}

type PaymentEntrySubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *PaymentEntrySubscriptionPayloadExec) Node() *PaymentEntryExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PaymentEntry"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "externalID", "productID", "product", "gatewayResponse", "amount", "discountID", "discount"})

	return &PaymentEntryExec{ret}
}

func (instance *PaymentEntrySubscriptionPayloadExec) PreviousValues() *PaymentEntryPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PaymentEntryPreviousValues"},
		"previousValues",
		[]string{"id", "createdAt", "updatedAt", "externalID", "productID", "product", "gatewayResponse", "amount", "discountID", "discount"})

	return &PaymentEntryPreviousValuesExec{ret}
}

func (instance PaymentEntrySubscriptionPayloadExec) Exec(ctx context.Context) (*PaymentEntrySubscriptionPayload, error) {
	var v PaymentEntrySubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance PaymentEntrySubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type PaymentEntrySubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance PaymentEntrySubscriptionPayloadExecArray) Exec(ctx context.Context) ([]PaymentEntrySubscriptionPayload, error) {
	var v []PaymentEntrySubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type PaymentEntrySubscriptionPayload struct {
	Mutation      MutationType `json:"mutation"`
	UpdatedFields []string     `json:"updatedFields,omitempty"`
}

type LocationExec struct {
	exec *prisma.Exec
}

func (instance LocationExec) Exec(ctx context.Context) (*Location, error) {
	var v Location
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance LocationExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type LocationExecArray struct {
	exec *prisma.Exec
}

func (instance LocationExecArray) Exec(ctx context.Context) ([]Location, error) {
	var v []Location
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type Location struct {
	Longitude float64 `json:"longitude"`
	Latitude  float64 `json:"latitude"`
}

type PhoneEdgeExec struct {
	exec *prisma.Exec
}

func (instance *PhoneEdgeExec) Node() *PhoneExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Phone"},
		"node",
		[]string{"type", "countryCode", "number"})

	return &PhoneExec{ret}
}

func (instance PhoneEdgeExec) Exec(ctx context.Context) (*PhoneEdge, error) {
	var v PhoneEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance PhoneEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type PhoneEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance PhoneEdgeExecArray) Exec(ctx context.Context) ([]PhoneEdge, error) {
	var v []PhoneEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type PhoneEdge struct {
	Cursor string `json:"cursor"`
}
